[{"categories":["数据库","运维"],"content":"Redis 主从复制可以实现数据库的读写分离，即主节点负责接收写请求、从节点负责接收读请求，是高性能 Redis 服务的基础。所以配置 Redis 主从复制应当作为开发者的技能之一，后文内容包括：\n 单机配置一主二从的主从复制服务 服务验证；  环境信息\n$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.2 LTS Release: 20.04 Codename: focal $ redis-server -v Redis server v=6.2.6 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=9c9e426e2f96cc51 配置过程 主节点使用 6379 端口，两个从节点分别使用 6380 和 6381 端口。\nRedis 配置文件 复制两份 Redis 配置文件分别为两个从节点的配置文件：\ncp -a /etc/redis/redis.conf /etc/redis/redis-server-6380.conf cp -a /etc/redis/redis.conf /etc/redis/redis-server-6381.conf 修改两个配置文件的内容，修改及新增内容如下：\n# redis-6380.conf # 修改项 port 6380 pidfile /run/redis/redis-server-6380.pid logfile /var/log/redis/redis-server-6380.log dbfilename dump-6380.rdb # 新增项 slaveof 127.0.0.1 6379 # redis-6381.conf # 修改项 port 6381 pidfile /run/redis/redis-server-6381.pid logfile /var/log/redis/redis-server-6381.log dbfilename dump-6381.rdb # 新增项 slaveof 127.0.0.1 6379 systemd 配置文件 复制两份 systemd 配置文件分别作为两个从节点的服务启动文件：\ncp -a /lib/systemd/system/redis-server.service /lib/systemd/system/redis-server-6380.service cp -a /lib/systemd/system/redis-server.service /lib/systemd/system/redis-server-6381.service 修改两个配置文件的内容，均为修改项，如下：\n# redis-server-6380.service [Service] ExecStart=/usr/bin/redis-server /etc/redis/redis-server-6380.conf PIDFile=/run/redis/redis-server-6380.pid # redis-server-6381.service [Service] ExecStart=/usr/bin/redis-server /etc/redis/redis-server-6381.conf PIDFile=/run/redis/redis-server-6381.pid 修改之后，需要执行如下命令进行重新加载：\nsystemctl daemon-reload 启动服务 配置完成后，通过 systemd 的管理命令分别在 3 个终端各启动 1 个服务，命令及显示如下：\n# 主节点 $ systemctl start redis-server.service $ redis-cli -p 6379 127.0.0.1:6379\u0026gt; INFO Replication # Replication role:master connected_slaves:2 slave0:ip=127.0.0.1,port=6380,state=online,offset=308,lag=0 slave1:ip=127.0.0.1,port=6381,state=online,offset=308,lag=1 # 其它 ... # 从节点 6380 $ systemctl start redis-server-6380.service $ redis-cli -p 6380 127.0.0.1:6380\u0026gt; INFO Replication # Replication role:slave master_host:127.0.0.1 master_port:6379 # 其它 ... # 从节点 6381 $ systemctl start redis-server-6381.service $ redis-cli -p 6381 127.0.0.1:6381\u0026gt; INFO Replication # Replication role:slave master_host:127.0.0.1 master_port:6379 # 其它 ... 读写 Redis 数据库 是否发生主从复制，可按如下的命令依次执行进行验证。\n# 主节点 127.0.0.1:6379\u0026gt; SET topic master-slave-replication OK # 从节点 6380 127.0.0.1:6380\u0026gt; GET topic \u0026#34;master-slave-replication\u0026#34; # 从节点 6381 127.0.0.1:6381\u0026gt; GET topic \u0026#34;master-slave-replication\u0026#34; 其它 systemd 是 Linux 服务器管理服务的其中一种方式，服务的启动与关闭也可以通过 redis-server 命令或其它方式进行实现。Redis 使用到的目录及文件信息包括：\n /run/redis/：存放 Redis 服务的 pid 文件，由 pidfile 配置项决定；  /var/log/redis/：存放 Redis 服务的日志文件，由 logfile 配置项决定； /var/lib/redis：存放 RDB 文件，由 dir 和 dbfilename 配置项决定；  完整脚本 #!/bin/bash  SLAVE1_PORT=6380 SLAVE2_PORT=6381 cat /etc/redis/redis.conf | \\ sed \u0026#34;s/^port\\ 6379/port\\ $SLAVE1_PORT/g\u0026#34; | \\ sed \u0026#34;s/^pidfile \\/run\\/redis\\/redis-server\\.pid/pidfile \\/run\\/redis\\/redis-server-$SLAVE1_PORT\\.pid/g\u0026#34; | \\ sed \u0026#34;s/^logfile \\/var\\/log\\/redis\\/redis-server\\.log/logfile \\/var\\/log\\/redis\\/redis-server-$SLAVE1_PORT\\.log/g\u0026#34; | \\ sed \u0026#34;s/^dbfilename dump\\.rdb/dbfilename dump-$SLAVE1_PORT\\.rdb/g\u0026#34; | \\ sed \u0026#34;\\$a\\\\slaveof 127.0.0.1 6379\\\\\u0026#34; \u0026gt; /etc/redis/redis-server-$SLAVE1_PORT.conf chown redis.redis /etc/redis/redis-server-$SLAVE1_PORT.conf cat /etc/redis/redis.conf | \\ sed \u0026#34;s/^port\\ 6379/port\\ $SLAVE2_PORT/g\u0026#34; | \\ sed \u0026#34;s/^pidfile \\/run\\/redis\\/redis-server\\.pid/pidfile \\/run\\/redis\\/redis-server-$SLAVE2_PORT\\.pid/g\u0026#34; | \\ sed \u0026#34;s/^logfile \\/var\\/log\\/redis\\/redis-server\\.log/logfile \\/var\\/log\\/redis\\/redis-server-$SLAVE2_PORT\\.log/g\u0026#34; | \\ sed \u0026#34;s/^dbfilename dump\\.rdb/dbfilename dump-$SLAVE2_PORT\\.rdb/g\u0026#34; | \\ sed \u0026#34;\\$a\\\\slaveof 127.0.0.1 6379\\\\\u0026#34; \u0026gt; /etc/redis/redis-server-$SLAVE2_PORT.conf chown redis.redis /etc/redis/redis-server-$SLAVE2_PORT.conf cat /lib/systemd/system/redis-server.service | \\ sed \u0026#34;s/\\/etc\\/redis\\/redis\\.conf/\\/etc\\/redis\\/redis-server-$SLAVE1_PORT\\.conf/g\u0026#34; | \\ sed \u0026#34;s/\\/run\\/redis\\/redis-server\\.pid/\\/run\\/redis\\/redis-server-$SLAVE1_PORT\\.pid/g\u0026#34; \u0026gt; /lib/systemd/system/redis-server-$SLAVE1_PORT.service chown root.root /lib/systemd/system/redis-server-$SLAVE1_PORT.service cat /lib/systemd/system/redis-server.service | \\ sed \u0026#34;s/\\/etc\\/redis\\/redis\\.conf/\\/etc\\/redis\\/redis-server-$SLAVE2_PORT\\.conf/g\u0026#34; | \\ sed \u0026#34;s/\\/run\\/redis\\/redis-server\\.pid/\\/run\\/redis\\/redis-server-$SLAVE2_PORT\\.pid/g\u0026#34; \u0026gt; /lib/systemd/system/redis-server-$SLAVE2_PORT.service chown root.root /lib/systemd/system/redis-server-$SLAVE2_PORT.service systemctl daemon-reload systemctl start redis-server.service systemctl start redis-server-$SLAVE1_PORT.service systemctl start redis-server-$SLAVE2_PORT.service 总结  Redis 主从复制的配置过程； Redis 服务相关配置项说明； ","date":"2022-03-30","img":"","permalink":"/posts/redis-master-slave-replication-deployment/","series":null,"tags":["Redis"],"title":"Redis 主从复制配置过程"},{"categories":["数据库"],"content":"栈（Stack）和队列（Queue）是编程中常用的两种数据结构，下面通过 Redis 的列表（List）类型来实现栈和队列。\n栈 栈是一种受限的线性表，即“只能在一端进行插入和删除操作”，其特点是后进先出（Last In First Out，LIFO）。假设列表的右端为栈顶（插入和删除的一端），则需要使用到 RPUSH 和 RPOP 两个命令。\n127.0.0.1:6379\u0026gt; RPUSH stack 1 2 3 4 5 6 (integer) 6 127.0.0.1:6379\u0026gt; RPOP stack \u0026#34;6\u0026#34; 127.0.0.1:6379\u0026gt; RPUSH stack 7 8 9 (integer) 8 127.0.0.1:6379\u0026gt; RPOP stack \u0026#34;9\u0026#34; 127.0.0.1:6379\u0026gt; RPOP stack \u0026#34;8\u0026#34; 上述命令的说明如下：\n RPUSH stack 1 2 3 4 5 6 ：按插入的先后顺序，此时列表为 [1, 2, 3, 4, 5, 6]； RPOP：从列表右端弹出 1 个元素，该元素为 6，此时列表为 [1, 2, 3, 4, 5]； RPUSH stack 7 8 9：列表右端插入 3 个元素，此时列表为 [1, 2, 3, 4, 5, 7, 8, 9]； 最后的两次 RPOP stack：分别弹出元素 9 和 8，此时列表为 [1, 2, 3, 4, 5, 7]；  队列 队列也是一种受限的线性表，即“一端只能插入，另一端只能删除”，其特点是先进先出（First In First Out，FIFO）。假设列表的左端是队首（删除的一端），右端是队尾（插入的一端），则需要使用到 LPUSH 和 LPOP 两个命令。\n127.0.0.1:6379\u0026gt; RPUSH queue 1 2 3 4 5 6 (integer) 6 127.0.0.1:6379\u0026gt; LPOP queue \u0026#34;1\u0026#34; 127.0.0.1:6379\u0026gt; RPUSH queue 7 8 9 (integer) 8 127.0.0.1:6379\u0026gt; LPOP queue \u0026#34;2\u0026#34; 127.0.0.1:6379\u0026gt; LPOP queue \u0026#34;3\u0026#34; 上述命令的说明如下：\n RPUSH queue 1 2 3 4 5 6：按插入的先后顺序，此时列表为 [1, 2, 3, 4, 5, 6]； LPOP queue：从列表左端弹出 1 个元素，此时列表为 [2, 3, 4, 5, 6]； RPUSH queue 7 8 9：列表右端插入 3 个元素，此时列表为 [2, 3, 4, 5, 6, 7, 8, 9]； 最后两次 LPOP queue：分别从左端弹出元素 2 和 3，此时列表为 [4, 5, 6, 7, 8, 9]； ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/examples/stack-and-queue/","series":["Redis 命令手册"],"tags":["Redis"],"title":"列表模拟栈和队列"},{"categories":["数据库"],"content":"Redis 服务器中与服务相关的命令，集群的配置过程可参考《Redis 集群配置过程》。\nCLUSTER nodes：显示集群主从关系 127.0.0.1:6380\u0026gt; CLUSTER nodes ac3f5aaae24bcd142b8303abedc5f57187ebc20e 127.0.0.1:6385@16385 slave 82ac1fe6c0af98d252ea96d4e84e7315eff31f8c 0 1649562125672 2 connected 9242c455757da4ad2f5aa818d75d12cde38231c2 127.0.0.1:6383@16383 slave 9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e 0 1649562126000 3 connected 5cc9ed2602986aeffaf9997f3c38c675092a4810 127.0.0.1:6384@16384 slave 92a1fd50a1c8dc003e905ac828b0db64773d6b66 0 1649562126674 1 connected 9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e 127.0.0.1:6382@16382 master - 0 1649562124670 3 connected 10923-16383 92a1fd50a1c8dc003e905ac828b0db64773d6b66 127.0.0.1:6380@16380 myself,master - 0 1649562122000 1 connected 0-5460 82ac1fe6c0af98d252ea96d4e84e7315eff31f8c 127.0.0.1:6381@16381 master - 0 1649562125000 2 connected 5461-10922 CLUSTER slots：显示哈希槽分配信息 127.0.0.1:6380\u0026gt; CLUSTER slots 1) 1) (integer) 0 2) (integer) 5460 3) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6380 3) \u0026#34;92a1fd50a1c8dc003e905ac828b0db64773d6b66\u0026#34; 4) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6384 3) \u0026#34;5cc9ed2602986aeffaf9997f3c38c675092a4810\u0026#34; 2) 1) (integer) 5461 2) (integer) 10922 3) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6381 3) \u0026#34;82ac1fe6c0af98d252ea96d4e84e7315eff31f8c\u0026#34; 4) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6385 3) \u0026#34;ac3f5aaae24bcd142b8303abedc5f57187ebc20e\u0026#34; 3) 1) (integer) 10923 2) (integer) 16383 3) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6382 3) \u0026#34;9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e\u0026#34; 4) 1) \u0026#34;127.0.0.1\u0026#34; 2) (integer) 6383 3) \u0026#34;9242c455757da4ad2f5aa818d75d12cde38231c2\u0026#34; CLUSTER keyslot：显示 key 对应的哈希槽 127.0.0.1:6380\u0026gt; CLUSTER keyslot user:1:name (integer) 12440 ","date":"2022-04-10","img":"","permalink":"/doc-redis-commands/cluster-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"集群相关"},{"categories":["数据库"],"content":"Redis 服务器中与服务相关的命令。\nINFO：查看当前服务器信息 格式：INFO [section]\n127.0.0.1:6380\u0026gt; INFO # Server redis_version:6.2.6 redis_git_sha1:00000000 redis_git_dirty:0 redis_build_id:9c9e426e2f96cc51 redis_mode:standalone os:Linux 5.4.0-77-generic x86_64 arch_bits:64 # 还有很多 ... SHUTDOWN：客户端断开连接 格式：SHUTDOWN [NOSAVE|SAVE]\n127.0.0.1:6379\u0026gt; SHUTDOWN SAVE not connected\u0026gt; EXIT：退出客户端 127.0.0.1:6379\u0026gt; EXIT ","date":"2022-03-30","img":"","permalink":"/doc-redis-commands/server-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"服务相关"},{"categories":["数据库"],"content":"Redis 服务器中与有序集合相关的命令。\nZADD：添加元素 ZADD 用于将一个或多个带分数的元素添加到有序集合中，返回成功添加到有序集合的元素个数。\n当添加元素已在有序集合中时，更新元素的分数使其在有序集合中保持正确的位置。\n格式：ZADD key score member [score member ...]\n127.0.0.1:6379\u0026gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei (integer) 2 127.0.0.1:6379\u0026gt; ZADD student:weights 64.2 xiaoming (integer) 0 ZSCORE：获取元素的分数 格式：ZSCORE key member\n127.0.0.1:6379\u0026gt; ZSCORE student:weights xiaoming \u0026#34;64.200000000000003\u0026#34; 127.0.0.1:6379\u0026gt; ZSCORE student:weights xiaolei \u0026#34;67.5\u0026#34; ZRANGE：获取指定位置区间上的元素 ZRANGE 可以获取指定位置区间上的元素，包括区间的两端。\n格式：ZRANGE key min max\n127.0.0.1:6379\u0026gt; ZADD student:weights 81.5 xiaopang (integer) 1 127.0.0.1:6379\u0026gt; ZRANGE student:weights 1 2 1) \u0026#34;xiaolei\u0026#34; 2) \u0026#34;xiaopang\u0026#34; 127.0.0.1:6379\u0026gt; ZRANGE student:weights 2 2 1) \u0026#34;xiaopang\u0026#34; ZRANGEBYSCORE：获取指定分数区间上的元素 ZRANGEBYSCORE 可指定分数区间获取元素。\n+inf 表示正无穷，-inf 表示负无穷。\n格式：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES 1) \u0026#34;xiaolei\u0026#34; 2) \u0026#34;67.5\u0026#34; 3) \u0026#34;xiaopang\u0026#34; 4) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 1 1 1) \u0026#34;xiaopang\u0026#34; 2) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 1 2 1) \u0026#34;xiaopang\u0026#34; 2) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 0 2 1) \u0026#34;xiaolei\u0026#34; 2) \u0026#34;67.5\u0026#34; 3) \u0026#34;xiaopang\u0026#34; 4) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) \u0026#34;xiaoming\u0026#34; 2) \u0026#34;64.200000000000003\u0026#34; 3) \u0026#34;xiaolei\u0026#34; 4) \u0026#34;67.5\u0026#34; 5) \u0026#34;xiaopang\u0026#34; 6) \u0026#34;81.5\u0026#34; ZINCRBY：增加某个元素的分数 ZINCRBY 的返回值为修改后的分数。\n格式：ZINCRBY key increment member\n127.0.0.1:6379\u0026gt; ZINCRBY student:weights 0.5 xiaoming \u0026#34;64.700000000000003\u0026#34; 127.0.0.1:6379\u0026gt; ZINCRBY student:weights -0.5 xiaoming \u0026#34;64.200000000000003\u0026#34; ZCARD：获取集合中元素的个数 格式：ZCARD key\n127.0.0.1:6379\u0026gt; ZCARD student:weights (integer) 3 ZCOUNT：获取指定分数范围内的元素个数 格式：ZCOUNT key min max\n127.0.0.1:6379\u0026gt; ZCOUNT student:weights 65 85 (integer) 2 ZREM：删除一个或多个元素 ZREM 返回删除成功的元素个数。\n格式：ZREM key member [member ...]\n127.0.0.1:6379\u0026gt; ZREM student:weights xiaoming xiaolei (integer) 2 127.0.0.1:6379\u0026gt; ZREM student:weights notaname (integer) 0 ZREMRANGEBYRANK：通过指定位置区间删除集合元素 格式：ZREMRANGEBYRANK key start stop\n127.0.0.1:6379\u0026gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei (integer) 2 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) \u0026#34;xiaoming\u0026#34; 2) \u0026#34;63.200000000000003\u0026#34; 3) \u0026#34;xiaolei\u0026#34; 4) \u0026#34;67.5\u0026#34; 5) \u0026#34;xiaopang\u0026#34; 6) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZREMRANGEBYRANK student:weights 0 1 (integer) 2 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) \u0026#34;xiaopang\u0026#34; 2) \u0026#34;81.5\u0026#34; ZREMRANGEBYSCORE：通过指定分数区间删除集合元素 格式：ZREMRANGEBYSCORE key min max\n127.0.0.1:6379\u0026gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei 81.5 xiaopang (integer) 3 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) \u0026#34;xiaoming\u0026#34; 2) \u0026#34;63.200000000000003\u0026#34; 3) \u0026#34;xiaolei\u0026#34; 4) \u0026#34;67.5\u0026#34; 5) \u0026#34;xiaopang\u0026#34; 6) \u0026#34;81.5\u0026#34; 127.0.0.1:6379\u0026gt; ZREMRANGEBYSCORE student:weights 80 85 (integer) 1 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) \u0026#34;xiaoming\u0026#34; 2) \u0026#34;63.200000000000003\u0026#34; 3) \u0026#34;xiaolei\u0026#34; 4) \u0026#34;67.5\u0026#34; ZRANK：获取元素的排序 格式：ZRANK key member\n127.0.0.1:6379\u0026gt; ZRANK student:weights xiaolei (integer) 1 127.0.0.1:6379\u0026gt; ZRANK student:weights notaname (nil) ZREVRANK：降序获取元素的排序 格式：ZREVRANK key member\n127.0.0.1:6379\u0026gt; ZREVRANK student:weights xiaolei (integer) 0 ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/zset-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"有序集合相关"},{"categories":["数据库"],"content":"Redis 服务器中与集合相关的命令。\nSADD：向集合中添加元素，若元素存在则忽略本次操作 SADD 返回成功添加到集合的元素个数，集合中已存在的元素不作添加处理。\n格式：SADD key member [member ...]\n127.0.0.1:6379\u0026gt; SADD odds 1 3 5 7 (integer) 4 127.0.0.1:6379\u0026gt; SADD odds 7 9 (integer) 1 # 此时，只有元素 9 被成功添加 SREM：删除集合中的元素 SREM 返回成功删除的元素个数。\n格式：SREM key member [member ...]\n127.0.0.1:6379\u0026gt; SREM odds 9 7 (integer) 2 127.0.0.1:6379\u0026gt; SMEMBERS odds 1) \u0026#34;1\u0026#34; 2) \u0026#34;3\u0026#34; 3) \u0026#34;5\u0026#34; SMEMBERS：获取集合中的所有元素 格式：SMEMBERS key\n127.0.0.1:6379\u0026gt; SMEMBERS odds 1) \u0026#34;1\u0026#34; 2) \u0026#34;3\u0026#34; 3) \u0026#34;5\u0026#34; SCARD：获取集合中元素的个数 格式：SCARD key\n127.0.0.1:6379\u0026gt; SCARD odds (integer) 3 SRANDMEMBER：随机获取集合中指定个数的元素 格式：SRNADMEMBER key [count]\n127.0.0.1:6379\u0026gt; SMEMBERS odds 1) \u0026#34;1\u0026#34; 2) \u0026#34;3\u0026#34; 3) \u0026#34;5\u0026#34; 127.0.0.1:6379\u0026gt; SRANDMEMBER odds \u0026#34;1\u0026#34; 127.0.0.1:6379\u0026gt; SRANDMEMBER odds 2 1) \u0026#34;1\u0026#34; 2) \u0026#34;5\u0026#34; SPOP：从集合中随机弹出一个或多个元素 格式：SPOP key [count]\n127.0.0.1:6379\u0026gt; SPOP odds 1 1) \u0026#34;3\u0026#34; 127.0.0.1:6379\u0026gt; SMEMBERS odds 1) \u0026#34;1\u0026#34; 2) \u0026#34;5\u0026#34; 127.0.0.1:6379\u0026gt; SPOP odds 2 1) \u0026#34;1\u0026#34; 2) \u0026#34;5\u0026#34; 127.0.0.1:6379\u0026gt; SMEMBERS odds (empty array) SDIFF：集合运算，取差集 SDIFF 可以对多个集合进行取差集操作。\n格式：SDIFF key [key ...]\n127.0.0.1:6379\u0026gt; SADD integers 1 2 3 4 5 6 7 8 9 10 (integer) 10 127.0.0.1:6379\u0026gt; SADD odds 1 3 5 7 9 (integer) 5 127.0.0.1:6379\u0026gt; SDIFF integers odds 1) \u0026#34;2\u0026#34; 2) \u0026#34;4\u0026#34; 3) \u0026#34;6\u0026#34; 4) \u0026#34;8\u0026#34; 5) \u0026#34;10\u0026#34; SINTER：集合运算，取交集 SINTER 可以对多个集合进行取交集操作。\n格式：SINTER key [key ...]\n127.0.0.1:6379\u0026gt; SINTER integers odds 1) \u0026#34;1\u0026#34; 2) \u0026#34;3\u0026#34; 3) \u0026#34;5\u0026#34; 4) \u0026#34;7\u0026#34; 5) \u0026#34;9\u0026#34; SUNION：集合运算，取并集 SUNION 可以对多个集合进行取并集操作。\n格式：SUNION key [key ...]\n127.0.0.1:6379\u0026gt; SADD odds 1 3 5 7 9 (integer) 0 127.0.0.1:6379\u0026gt; SADD evens 2 4 6 8 10 (integer) 5 127.0.0.1:6379\u0026gt; SUNION odds evens 1) \u0026#34;1\u0026#34; 2) \u0026#34;2\u0026#34; 3) \u0026#34;3\u0026#34; 4) \u0026#34;4\u0026#34; 5) \u0026#34;5\u0026#34; 6) \u0026#34;6\u0026#34; 7) \u0026#34;7\u0026#34; 8) \u0026#34;8\u0026#34; 9) \u0026#34;9\u0026#34; 10) \u0026#34;10\u0026#34; SDIFFSTORE：集合运算，存储差集 SDIFFSTORE 可以将多个集合的取差集的运算结果保存到另一个键中，返回值为差集的元素个数。\n格式：SDIFFSTORE destination key [key ...]\n127.0.0.1:6379\u0026gt; SDIFFSTORE new:odds integers evens (integer) 5 SINTERSTORE：集合运算，存储交集 SINTERSTORE 可以将多个集合的取交集的运算结果保存到另一个键中，返回值为交集的元素个数。\n格式：SINTERSTORE destination key [key ...]\n127.0.0.1:6379\u0026gt; SINTERSTORE new:evens integers evens (integer) 5 SUNIONSTORE：集合运算，存储并集 SUNIONSTORE 可以将多个集合的取并集的运算结果保存到另一个键中，返回值为并集的元素个数。\n格式：SUNIONSTORE destination key [key ...]\n127.0.0.1:6379\u0026gt; SUNIONSTORE new:integers odds evens (integer) 10 127.0.0.1:6379\u0026gt; SMEMBERS new:integers 1) \u0026#34;1\u0026#34; 2) \u0026#34;2\u0026#34; 3) \u0026#34;3\u0026#34; 4) \u0026#34;4\u0026#34; 5) \u0026#34;5\u0026#34; 6) \u0026#34;6\u0026#34; 7) \u0026#34;7\u0026#34; 8) \u0026#34;8\u0026#34; 9) \u0026#34;9\u0026#34; 10) \u0026#34;10\u0026#34; ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/set-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"集合相关"},{"categories":["数据库"],"content":"Redis 服务器中与列表值相关的命令。\nLPUSH：向列表左端添加元素 LPUSH 返回添加元素后列表的长度。\n格式：LPUSH key element [element ...]\n127.0.0.1:6379\u0026gt; LPUSH colors green yellow red blue gray (integer) 5 # 此时列表为 [gray blue yellow red green] LPUSHX：向列表左端添加元素 LPUSHX 与 LPUSH 类似，但只有在 key 存在的情况，操作才有效。\n格式：LPUSHX key element [element ...]\n127.0.0.1:6379\u0026gt; KEYS colors (empty array) 127.0.0.1:6379\u0026gt; LPUSHX colors red green blue (integer) 0 RPUSH：向列表右端添加元素 RPUSH 返回添加元素后列表的长度。\n格式：RPUSH key element [element ...]\n127.0.0.1:6379\u0026gt; RPUSH colors lightgreen lightyellow lightred lightblue (integer) 9 # 此时列表为 [gray blue yellow red green # lightgreen lightyellow lightred lightblue] RPUSHX：向列表右端添加元素 RPUSHX 与 RPUSH 类似，但只能存在的键有效。\n格式：RPUSHX key element [element ...]\n127.0.0.1:6379\u0026gt; KEYS colors (empty array) 127.0.0.1:6379\u0026gt; RPUSHX colors red green blue (integer) 0 127.0.0.1:6379\u0026gt; KEYS colors (empty array) LPOP：从列表左端弹出元素 LPOP 返回弹出的元素。\n格式：LPOP key [count]\n127.0.0.1:6379\u0026gt; LPOP colors 2 1) \u0026#34;gray\u0026#34; 2) \u0026#34;blue\u0026#34; # 此时列表为 [yellow red green # lightgreen lightyellow lightred lightblue] RPOP：从列表右端弹出元素 RPOP 返回弹出的元素。\n格式：RPOP key [count]\n127.0.0.1:6379\u0026gt; RPOP colors 2 1) \u0026#34;lightblue\u0026#34; 2) \u0026#34;lightred\u0026#34; # 此时列表为 [yellow red green # lightgreen lightyellow] LLEN：获取列表中元素的个数 格式：LLEN key\n127.0.0.1:6379\u0026gt; LLEN colors (integer) 5 LRANGE：获取列表指定区间上的元素 LRANGE 指定的区间包括两端。\n格式：LRANGE key start stop\n127.0.0.1:6379\u0026gt; LRANGE colors 2 -1 1) \u0026#34;green\u0026#34; 2) \u0026#34;lightgreen\u0026#34; 3) \u0026#34;lightyellow\u0026#34; LREM：删除列表中前 count 个指定的元素 格式：LREM key count element\n127.0.0.1:6379\u0026gt; LPUSH colors yellow yellow yellow (integer) 8 # 此时列表为 [yellow yellow yellow yellow red green # lightgreen lightyellow] 127.0.0.1:6379\u0026gt; LREM colors 3 yellow (integer) 3 # 此时列表为 [yellow red green # lightgreen lightyellow] LINDEX：获取指定位置上的元素 格式：LINDEX key index\n127.0.0.1:6379\u0026gt; LINDEX colors 2 \u0026#34;green\u0026#34; LSET：设置列表中指定位置上元素的值 格式：LSET key index element\n127.0.0.1:6379\u0026gt; LSET colors 0 blue OK # 此时列表为 [blue red green # lightgreen lightyellow] LTRIM：对列表进行裁剪 LTRIM 裁剪列表并保存到原有列表中。\n格式：LTRIM key start stop\n127.0.0.1:6379\u0026gt; LTRIM colors 0 2 OK # 列表只保留了前 3 个元素 127.0.0.1:6379\u0026gt; LRANGE colors 0 9 1) \u0026#34;blue\u0026#34; 2) \u0026#34;yellow\u0026#34; 3) \u0026#34;green\u0026#34; LINSERT：向列表插入元素 LINSERT 用于在列表元素前或后插入指定元素。\n格式：LINSERT key BEFORE|AFTER pivot element\n127.0.0.1:6379\u0026gt; LINSERT colors BEFORE blue red (integer) 4 127.0.0.1:6379\u0026gt; LRANGE colors 0 -1 1) \u0026#34;red\u0026#34; 2) \u0026#34;blue\u0026#34; 3) \u0026#34;yellow\u0026#34; 4) \u0026#34;green\u0026#34; RPOPLPUSH：操作两个列表，对元素进行弹出再推入 RPOPLPUSH 返回值为第 1 个列表弹出的元素。\n格式：RPOPLPUSH source destination\n127.0.0.1:6379\u0026gt; RPOPLPUSH colors other:colors \u0026#34;green\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE colors 0 -1 1) \u0026#34;red\u0026#34; 2) \u0026#34;blue\u0026#34; 3) \u0026#34;yellow\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE other:colors 0 -1 1) \u0026#34;green\u0026#34; BLPOP：阻塞式从列表左端弹出元素 BLPOP 同样用于从列表左端弹出元素，但是当列表为空，该命令会阻塞列表直到超时或列表有元素可弹出，超时时间单位为秒。\n格式：BLPOP key [key ...] timeout\n127.0.0.1:6379\u0026gt; BLPOP mock:list 2 (nil) (2.06s) BRPOP：阻塞式从列表右端弹出元素 BRPOP 同样用于从列表右端弹出元素，但是当列表为空，该命令会阻塞列表直到超时或列表有元素可弹出，超时时间单位为秒。\n格式：BRPOP key [key ...] timeout\n127.0.0.1:6379\u0026gt; BRPOP mock:list 2` (nil) (2.05s) RPUSHX：向已存在的列表右端添加元素 RPUSHX 用于将一个或多个元素添加到已存在列表，若列表不存在，则操作无效。\n格式：RPUSHX key element [element ...]\n127.0.0.1:6379\u0026gt; LRANGE colors 0 -1 1) \u0026#34;red\u0026#34; 2) \u0026#34;blue\u0026#34; 3) \u0026#34;yellow\u0026#34; 127.0.0.1:6379\u0026gt; RPUSHX colors green (integer) 4 127.0.0.1:6379\u0026gt; LRANGE colors 0 -1 1) \u0026#34;red\u0026#34; 2) \u0026#34;blue\u0026#34; 3) \u0026#34;yellow\u0026#34; 4) \u0026#34;green\u0026#34; 127.0.0.1:6379\u0026gt; RPUSHX not:exists:colors green (integer) 0 BRPOPLPUSH：操作两个列表，对元素进行弹出再推入 BRPOPLPUSH 与 RPOPLPUSH 类似，但如果列表中没有元素会阻塞直到等待超时或有元素弹出，超时时间的单位为秒。\n格式：BRPOPLPUSH source destination timeout\n127.0.0.1:6379\u0026gt; RPUSH colors red green yellow (integer) 3 127.0.0.1:6379\u0026gt; BRPOPLPUSH colors dest:colors 10 \u0026#34;yellow\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE colors 0 -1 1) \u0026#34;red\u0026#34; 2) \u0026#34;green\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE dest:colors 0 -1 1) \u0026#34;yellow\u0026#34; ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/list-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"列表值相关"},{"categories":["数据库"],"content":"Redis 服务器中与字符串值相关的命令。\nSET：设置键值对 SET 用于设置单个值为字符串的健值对。\n格式：SET key value\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK SETNX：键不存在时才设置值 SETNX 只有在键不存在的情况下，才可以设置值。\n格式：SETNX key value\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; SETNX user:1:name xiaohong (integer) 0 # 此处设置不成功 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; 127.0.0.1:6379\u0026gt; EXISTS user:1:email (integer) 0 # 键 user:1:email 不存在 127.0.0.1:6379\u0026gt; SETNX user:1:email foo@bar.com (integer) 1 # 设置成功 SETEX：设置具有生存时间的键值对 SETEX 可以设置一个具有生存时间的键值对，过期时间的单位为秒。\n格式：SETEX key seconds value\n127.0.0.1:6379\u0026gt; SETEX user:1:name 10 xiaoming OK 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; # 10 秒内访问 127.0.0.1:6379\u0026gt; GET user:1:name (nil) # 10 秒外访问 PSETEX：设置具有过期时间的键值对 PSETEX 与 SETEX 类似，但其生存时间的单位为微秒。\n格式：PSETEX key millIseconds value\n127.0.0.1:6379\u0026gt; PSETEX user:1:name 10000 xiaoming OK 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; # 10 秒内访问 127.0.0.1:6379\u0026gt; GET user:1:name (nil) # 10 秒外访问 GET：取特定键对应的值 GET 用于获取获取特定键对应的值。\n格式：GET key\n127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; GETSET：设置值并返回旧值 GETSET 可以为设置一个值并返回 key 的旧值，若 key 不存在则返回 nil。\n格式：GETSET key value\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; GETSET user:1:name xiaohong \u0026#34;xiaoming\u0026#34; GETRANGE：返回字符串值的字符子串 GETRANGE 用于返回字符串值的字符子串，包括两端。\n格式：GETRANGE key start end\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; GETRANGE user:1:name 2 3 \u0026#34;ao\u0026#34; SETRANGE：给字符串值的指定位置设置新字符 SETRANGE 给字符串值的指定位置设置新字符并返回新字符串的长度。\n格式：SETRANGE key offset value\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; SETRANGE user:1:name 4 hong (integer) 8 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaohong\u0026#34; MSET：同时设置多个键值对 MSET 用于设置多个键值对。\n格式：MSET key value [key value ...]\n127.0.0.1:6379\u0026gt; MSET user:1:age 18 user:1:gender male OK MSETNX：同时设置多个键值对 MSETNX 用于同时设置多个键值对，当有一个键是存在时，该命令其它键的赋值也不会生效。\n格式：MSETNX key value [key value ...]\n127.0.0.1:6379\u0026gt; KEYS user* (empty array) 127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; MSETNX user:1:name xiaoming user:2:name xiaohong (integer) 0 # 因为 user:1:name 存在，所以 user:2:name 没能被赋值 127.0.0.1:6379\u0026gt; EXISTS user:1:name user:2:name (integer) 1 127.0.0.1:6379\u0026gt; EXISTS user:1:name (integer) 1 127.0.0.1:6379\u0026gt; EXISTS user:2:name (integer) 0 127.0.0.1:6379\u0026gt; GET user:2:name (nil) MGET：同时取多个值 MGET 用于同时取多个值。\n格式：MGET key [key ...]\n127.0.0.1:6379\u0026gt; MGET user:1:age user:1:gender 1) \u0026#34;18\u0026#34; 2) \u0026#34;male\u0026#34; STRLEN：获取字符串的长度 STRLEN 可以获取指定键对应字符串值的长度。\n格式：STRLEN key\n127.0.0.1:6379\u0026gt; STRLEN user:1:name (integer) 8 127.0.0.1:6379\u0026gt; SET welcome 你好 OK 127.0.0.1:6379\u0026gt; STRLEN welcome (integer) 6 APPEND：追加字符串，返回追加后字符串的长度 APPEND 可以向字符串值追加新的字符，返回值为追加后新字符串的长度。\n格式：APPEND key value\n127.0.0.1:6379\u0026gt; APPEND user:1:name Li (integer) 10 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaomingLi\u0026#34; GETBIT：获取字符串值指定位置上的二进制值 指定位置指的是字符串的二进制存储形式中从左至右的偏移量，以 0 开始计数。\n格式：GETBIT key offset\n127.0.0.1:6379\u0026gt; SET user:2:name abc OK # abc 的二进制存储形式为 # a: 01100001 # b: 01100010 # c: 01100011 127.0.0.1:6379\u0026gt; BITCOUNT user:2:name (integer) 10 GETBIT user:2:name 1 (integer) 1 SETBIT：设置字符串值指定位置上的二进制值 返回值为原指定位置上的二进制值\n格式：SETBIT key offset value\n127.0.0.1:6379\u0026gt; SETBIT user:2:name 6 1 (integer) 0 # 此时 a 已变成 c 127.0.0.1:6379\u0026gt; GET user:2:name \u0026#34;cbc\u0026#34; BITCOUNT：返回字符串类型值的二进制值中 1 的个数 下标指的字符在字符串中的位置，而不是字符串二进制形式的比特位置。\n格式：BITCOUNT key [start end]\n127.0.0.1:6379\u0026gt; SET user:2:name abc OK 127.0.0.1:6379\u0026gt; BITCOUNT user:2:name (integer) 10 127.0.0.1:6379\u0026gt; BITCOUNT user:2:name 0 2 (integer) 10 127.0.0.1:6379\u0026gt; BITCOUNT user:2:name 1 1 (integer) 3 # 实际取的字符 b 的二进制形式中 1 的个数 BITOP：对多个字符串类型值进行位运算 BITOP 支持的运算符包括 AND、OR、XOR 和 NOT，并将运算结果保存到目标 key 中。\n格式：BITOP operation destkey key [key ...]\n127.0.0.1:6379\u0026gt; SET char:1 a OK 127.0.0.1:6379\u0026gt; SET char:2 z OK 127.0.0.1:6379\u0026gt; BITOP AND char:1:2:and:result char:1 char:2 (integer) 1 127.0.0.1:6379\u0026gt; GET char:1:2:and:result \u0026#34;`\u0026#34; 127.0.0.1:6379\u0026gt; BITOP XOR char:1:2:xor:result char:1 char:2 (integer) 1 127.0.0.1:6379\u0026gt; GET char:1:2:xor:result \u0026#34;\\x1b\u0026#34; BITPOS：获取字符串类型值的二进制中第一个是 0 或 1 的位置 格式：BITPOS key bit [start] [end]\n127.0.0.1:6379\u0026gt; BITPOS char:1 0 0 7 (integer) 0 # 字符 a 的二进制形式的第 0 位为 0 127.0.0.1:6379\u0026gt; BITPOS char:1 1 0 (integer) 1 # 字符 a 的二进制形式的第 1 位为 1 INCR：数值递增 INCR 返回递增后的数值，若指定的 key 不存在，则先对其初始化为 0，再进行数值递增。\n格式：INCR key\n127.0.0.1:6379\u0026gt; SET job:crash:count 100 OK 127.0.0.1:6379\u0026gt; INCR job:crash:count (integer) 101 127.0.0.1:6379\u0026gt; INCR job🏃count (integer) 1 # 此时键 job🏃count 并不存在 INCRBY：以指定数值对键值进行递增 INCRBY 返回递增后的数值，若指定的 key 不存在，则先对其初始化为 0，再进行数值递增。支持负值操作。\n格式：INCRBY key increment\n127.0.0.1:6379\u0026gt; INCRBY job:crash:count 2 (integer) 103 DECR：数值递减 格式：DECR key\n127.0.0.1:6379\u0026gt; DECR job:crash:count (integer) 102 DECRBY：以指定数值对键值进行递减 DECRBY 支持负值操作。\n格式：DECRBY key decrement\n127.0.0.1:6379\u0026gt; DECRBY job:crash:count 2 (integer) 100 INCRBYFLOAT：以指定浮点数值对键值进行递增 INCRBYFLOAT 可通过指定浮点数对键值进行加减，若指定 key 不存在，则先进行创建。\n127.0.0.1:6379\u0026gt; INCRBYFLOAT job:1:weight 0.4 \u0026#34;0.4\u0026#34; 127.0.0.1:6379\u0026gt; INCRBYFLOAT job:1:weight 0.4 \u0026#34;0.4\u0026#34; 127.0.0.1:6379\u0026gt; INCRBYFLOAT job:1:weight -0.2 \u0026#34;0.2\u0026#34; ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/string-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"字符串值相关"},{"categories":["数据库"],"content":"Redis 服务器中与 key 相关的命令。\nKEYS：获取数据库中匹配规则的键名 KEYS 命令遍历数据库中的所有键，支持 glob 风格通配符格式，在存在大量键值对的 Redis 服务器上应谨慎使用。\n格式：KEYS patten\n127.0.0.1:6379\u0026gt; KEYS * (empty array) 127.0.0.1:6379\u0026gt; SET config:logLevel Fatal OK 127.0.0.1:6379\u0026gt; KEYS config:* 1) \u0026#34;config:logLevel\u0026#34;  glob 风格通配符格式\n   符号 含义     ? 匹配一个字符   * 匹配任意多个字符   [] 匹配括号间的任一字符   \\ 转义     EXISTS：判断键名是否存在 EXISTS 用于判断键名是否存在，返回值为存在键名的个数。\n格式：EXISTS key [key ...]\n127.0.0.1:6379\u0026gt; EXISTS config:logLevel config:pagination (integer) 1 127.0.0.1:6379\u0026gt; EXISTS config:pagination (integer) 0 EXPIRE：给键设置过期时间 EXPIRE 可以给一个键设置一个以秒为单位的过期时间。\n格式：EXPIRE key seconds\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; EXPIRE user:1:name 5 (integer) 1 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; # 5 秒内访问 127.0.0.1:6379\u0026gt; GET user:1:name (nil) # 5 秒后访问 EXPIREAT：给键设置过期时间 EXPIREAT 通过指定一个 UNIX 时间戳为键设置一个过期时间。\n格式：EXPIREAT key timestamp\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; EXPIREAT user:1:name 1648470000 (integer) 1 # 1648470000 为 2022-03-28 20:20:00 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; PEXPIRE：给键设置过期时间 PEXPIRE 与 EXPIRE 类似，不同之处在于 PEXPIRE 的时间单位是微秒。\n格式：PEXPIRE key milliseconds\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; PEXPIRE user:1:name 10000 (integer) 1 127.0.0.1:6379\u0026gt; GET user:1:name \u0026#34;xiaoming\u0026#34; # 10 秒内访问 127.0.0.1:6379\u0026gt; GET user:1:name (nil) # 10 秒后访问 PEXPIREAT：给键设置过期时间 PEXPIREAT 与 EXPIREAT 类似，不同之外在于 PEXPIREAT 的时间单位是微秒。\n格式：PEXPIREAT key milliseconds-timestamp\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; TTL user:1:name (integer) -1 127.0.0.1:6379\u0026gt; PEXPIREAT user:1:name 1648470000000 (integer) 1 PERSIST：移除键的过期时间 PERSIST 可以移除键的过期，使其永不失效。\n格式：PERSIST key\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; EXPIRE user:1:name 100 (integer) 1 127.0.0.1:6379\u0026gt; TTL user:1:name (integer) 93 127.0.0.1:6379\u0026gt; PERSIST user:1:name (integer) 1 127.0.0.1:6379\u0026gt; TTL user:1:name (integer) -1 TTL：返回键的剩余生存时间 TTL 返回以秒为单位的键的剩余生存时间，对长期有效的键使用会返回 -1。\n格式：TTL key\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; EXPIRE user:1:name 100 (integer) 1 127.0.0.1:6379\u0026gt; TTL user:1:name (integer) 93 127.0.0.1:6379\u0026gt; SET user:1:name xiaoming (integer) 1 127.0.0.1:6379\u0026gt; TTL user:1:name (integer) -1 PTTL：返回键的剩余生存时间 PTTL 与 TTL 类似，不同之外在于返回的剩余生存时间的单位为微秒。\n格式：PTTL key\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; PTTL user:1:name (integer) -1 127.0.0.1:6379\u0026gt; EXPIRE user:1:name 100 (integer) 1 127.0.0.1:6379\u0026gt; PTTL user:1:name (integer) 93978 RENAME：修改键名 RENAME 可用于修改键名。\n格式：RENAME key newkey\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; RENAME user:1:name user:2:name OK 127.0.0.1:6379\u0026gt; GET user:2:name \u0026#34;xiaoming\u0026#34; RENAMENX：修改键名 RENAMENX 命令只有在给定的新键名不存在时，才会起作用。\n格式：RENAMENX key newkey\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; KEYS user:newname* (empty array) 127.0.0.1:6379\u0026gt; RENAMENX user:1:name user:newname:1:name (integer) 1 127.0.0.1:6379\u0026gt; GET user:1:name (nil) 127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; RENAMENX user:1:name user:1:name (integer) 0 # 新键名不变，但执行不成功 DEL：删除一个或多个键 DEL 用于删除一个或多个键，返回值为删除键的个数。\n格式：DEL key [key ...]\n127.0.0.1:6379\u0026gt; DEL config:logLevel config:pagination (integer) 1 # config:pagination 此时并不存在，故返回值为 1 RANDOMKEY：随机返回一个键 格式：RANDOMKEY key\n127.0.0.1:6379\u0026gt; RANDOMKEY \u0026#34;student:weights\u0026#34; DUMP：序列化给定的键 DUMP 可以序列化指定的键并返回序列化的值。\n格式：DUMP key\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; DUMP user:1:name \u0026#34;\\x00\\bxiaoming\\t\\x00\\xe6u\\x97\\x84\\x19\\x1c\\x01\\x81\u0026#34; TYPE：获取指定键对应值的类型 TYPE 用于获取指定键对应值的类型，返回值包括 string | hash | list | set | zset | stream\n格式：TYPE key\n127.0.0.1:6379\u0026gt; SET user:1:name xiaoming OK 127.0.0.1:6379\u0026gt; TYPE user:1:name string DBSIZE：返回数据库中 key 的数量 格式：DBSIZE\n127.0.0.1:6379\u0026gt; DBSIZE (integer) 26 ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/key-related/","series":["Redis 命令手册"],"tags":["Redis"],"title":"键相关"},{"categories":["数据库"],"content":"Redis 是开源的、高性能的数据结构存储系统，在框架设计中常常被当作缓存服务器。不同于传统的关系型数据库（如 MySQL、PostgreSQL），Redis 将数据以键值对的方式存储于内存并且支持数据持久化。尽管 Redis 采用了单线程模型来处理请求，但其通过 I/O 多路复用技术做到了应用级别的异步，运行的性能也十分良好。\n根据操作对象的不同，可将 Redis 中的命令分成以下几类：\n 键相关命令 字符串值相关命令 列表值相关命令 集合值相关命令 有序集合值相关命令 流类型值相关命令 服务相关命令  介绍完命令后，本文还会通过以下几个示例更一步说明命令的用法：\n 列表模拟栈和队  ","date":"2022-03-27","img":"","permalink":"/doc-redis-commands/introduction/","series":["Redis 命令手册"],"tags":["Redis"],"title":"介绍"},{"categories":["Go"],"content":"在网络或 I/O 连接中，可以使用 net/rpc 包实现对一个对象的导出方法的调用，即远程过程调用（Remote Procedure Call，RPC）。通过向 RPC 服务注册一个对象，使其可被远程调用，进而实现一些复杂的业务逻辑。\n项目结构 示例项目的结构如下：\nclient - client.go - json_client.go models - greeting.go server - json_server.go - server.go 注册服务 一个可被远程调用的方法须满足以下条件：\n 方法所属结构是公开的； 方法是分开的； 方法的参数类型是分开的； 方法带两个参数，第 2 个参数为指针； 方法返回值为 error 类型；  如下，在 models/greeting.go 中定义了一个服务：\ntype GreetingArg struct { Name string } type GreetingReply struct { Message string } type Greeting struct {} // SayHello 方法满足上述条件 func (Greeting) SayHello(arg GreetingArg, reply *GreetingReply) error { reply.Message = \u0026#34;hello, \u0026#34; + arg.Name return nil } 现在，在 server/server.go 中编写服务器端代码：\npackage main import ( \u0026#34;gorpc/models\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { server := rpc.NewServer() if err := server.Register(\u0026amp;models.Greeting{}); err != nil { log.Fatalln(err) } listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:2022\u0026#34;) if err != nil { log.Fatalln(err) } defer listener.Close() server.Accept(listener) } 服务器端注册了 Greeting 服务并监听了 2022 端口，等待客户端连接。在客户端 client/client.go 的代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;gorpc/models\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:2022\u0026#34;) if err != nil { log.Fatalln(err) } defer conn.Close() client := rpc.NewClient(conn) greetingArg := models.GreetingArg{Name: \u0026#34;a2htray\u0026#34;} greetingReply := models.GreetingReply{} if err = client.Call(\u0026#34;Greeting.SayHello\u0026#34;, greetingArg, \u0026amp;greetingReply); err != nil { log.Fatalln(err) } fmt.Println(greetingReply.Message) } 上述代码完成了以下几件事：\n 使用 net.Dial 连接 2022 端口； 在 TCP 连接之上，使用 rpc.NewClient 创建一个 RPC 客户端； 使用 client.Call 远程调用 Greeting 的 SayHello 方法； 返回的值体现在 greetingReply 变量中；  jsonrpc net/rpc 的传输数据使用 encoding/gob 进行编码解码，并且不支持跨语言调用，即只能使用 Go 编写的程序进行调用。encoding/gob 编码解码在源码中有给出：\n// rpc/server.go func (server *Server) ServeConn(conn io.ReadWriteCloser) { buf := bufio.NewWriter(conn) srv := \u0026amp;gobServerCodec{ rwc: conn, dec: gob.NewDecoder(conn), enc: gob.NewEncoder(buf), encBuf: buf, } server.ServeCodec(srv) } 除了 net/rpc，还可以使用 net/rpc/jsonrpc 实现 RPC 功能，该方式支持跨语言调用。新建 server/json_server.go，代码如下：\npackage main import ( \u0026#34;gorpc/models\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main() { err := rpc.Register(\u0026amp;models.Greeting{}) if err != nil { log.Fatalln(err) } listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:2023\u0026#34;) if err != nil { log.Fatalln(err) } defer listener.Close() for { conn, err := listener.Accept() if err != nil { log.Fatalln(err) } go jsonrpc.ServeConn(conn) } } 上述代码完成了以下几件事：\n 在 RPC 服务上注册了 Greeting； 监听了 2023 端口，使用 for 循环接受客户端连续； 对每一个连接使用协程进行处理；  新建 client/json_client.go，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;gorpc/models\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main() { client, err := jsonrpc.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:2023\u0026#34;) if err != nil { log.Fatalln(err) } defer client.Close() greetingArg := models.GreetingArg{Name: \u0026#34;a2htray\u0026#34;} greetingReply := models.GreetingReply{} if err = client.Call(\u0026#34;Greeting.SayHello\u0026#34;, greetingArg, \u0026amp;greetingReply); err != nil { log.Fatalln(err) } fmt.Println(greetingReply.Message) } 上述代码完成了以下几件事：\n 使用 jsonrpc.Dial 连接到端口 2023； 使用 client.Call 调用了 Greeting.SayHello 方法； 打印输出返回信息；  rpc 与 jsonrpc 的区别 Go 内置的 rpc 与 jsonrpc 的区别在于：\n rpc 使用 gob 编码解码，jsonrpc 使用 json 编码解码； rpc 不支持跨语言调用，jsonrpc 支持跨语言调用； jsonrpc 在构建在 rpc 之上使用不同数据交换格式的 RPC 服务；  参考  golang下的rpc框架jsonrpc理解和使用示例 golang实现RPC的几种方式  ","date":"2022-04-10","img":"/images/operating-system-remote-procedure-call-1.png","permalink":"/posts/go-built-in-rpc-package/","series":null,"tags":["rpc","jsonrpc"],"title":"Go 内置的 RPC 包"},{"categories":["Go"],"content":"Go 1.18 在 2022 年 3 月 15 日发布，根据团队的博文介绍，1.18 版本包含 4 个重要特性：\n 泛型； fuzzing； 工作空间； 20% 的性能提升；  泛型 泛型是一种无须关心具体操作类型的编码方式，它将逻辑实现与具体类型解耦，体现在程序中的 3 个地方：\n 函数和类型的类型参数； 用于指定类型的集合； 类型推断，不需要显式指定类型；   本节是官方泛型教程的截取或修改内容，详细请查看此处。\n 不同类型求和函数 package main import \u0026#34;fmt\u0026#34; // sumInts 计算 int slice 的和 func sumInts(values []int) int { var total int for _, value := range values { total += value } return total } // sumFloat32s 计算 float32 slice 的和 func sumFloat32s(values []float32) float32 { var total float32 for _, value := range values { total += value } return total } // sum 计算的 slice 元素可以是 int 类型或 float32 类型 func sum[Element int | float32](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { intValues := []int{1, 2, 3} float32Values := []float32{4, 5, 6} fmt.Println(sumInts(intValues)) fmt.Println(sumFloat32s(float32Values)) // sum(intValues) 等价于 sum[int](intValues) \tfmt.Println(sum(intValues)) fmt.Println(sum[int](intValues)) // sum(float32Values) 等价于 sum[float32](float32Values) \tfmt.Println(sum(float32Values)) fmt.Println(sum[float32](float32Values)) } 类型约束 示例 1：\npackage main import \u0026#34;fmt\u0026#34; // Number 类型约束，限制 Number 可以是 int 或 float32 type Number interface { int | float32 } // sum 求和 // [Element Number] 限定 Element 需要符合 Number 类型约束 // 即 Element 只能是 int 或 float32 func sum[Element Number](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { intValues := []int{1, 2, 3} float32Values := []float32{4, 5, 6} fmt.Println(sum(intValues)) fmt.Println(sum(float32Values)) } 示例 2：\npackage main import \u0026#34;fmt\u0026#34; // Flag 底层类型为 int type Flag int const ( Flag_A Flag = iota Flag_B Flag_C ) // Number 类型约束 // ~ 操作符表示底层类型为 int 的类型也符合 type Number interface { float32 | ~int } func sum[Element Number](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { flagValues := []Flag{ Flag_A, Flag_B, Flag_C, } float32Values := []float32{4, 5, 6} fmt.Println(sum(flagValues)) fmt.Println(sum(float32Values)) } 示例 3：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) type Flag int func (f Flag) String() string { return strconv.Itoa(int(f)) } const Flag_A Flag = iota // Number 包含了方法的类型约束 // 指定了 Number 类型的底层类型是 int 并实现了 String() string 方法 type Number interface { ~int String() string } func PrintNumber[V Number](number V) { fmt.Println(number.String()) } func main() { PrintNumber(Flag_A) } 示例 4：\npackage main import \u0026#34;fmt\u0026#34; type Flag int const ( Flag_A Flag = iota ) // PrintNumber 使用 ~ 操作符，定义类型底层实现 func PrintNumber[Number ~int](value Number) { fmt.Println(value) } func main() { PrintNumber(Flag_A) PrintNumber(1) } 总结  使用泛型可以减少相同逻辑（不同具体类型）的代码量； 使用 ~ 操作符指定底层类型； 类型约束中可以声明方法； ","date":"2022-04-10","img":"","permalink":"/posts/go-1.18-release-features/","series":null,"tags":["Go 1.18"],"title":"Go 1.18 特性 - 泛型"},{"categories":["Go"],"content":"Protocol Buffer 的介绍与语法已在文章《Protocol Buffer 语法》给出，本文则演示了 Protocol Buffer 如何减少了传输数据的大小。\n使用 protoc 命令生成 pb 代码文件 首先新建 proto/user.proto 文件来定义数据结构，其内容如下：\nsyntax = \u0026#34;proto3\u0026#34;;option go_package = \u0026#34;/model\u0026#34;;message User { string name = 1; enum Gender { MALE = 0; FEMALE = 1; }; Gender gender = 2;}然后，执行如下命令生成源代码文件：\nprotoc --go_out=. proto\\user.proto 主程序 main 主程序的作用是比较不同 User 结构序列化后的字节数据的大小。首先，新建 main.go 文件并定义一个 User 结构，如下：\ntype User struct { Name string Gender int32 } 主程序的逻辑如下：\nfunc main() { user := \u0026amp;User{ Name: \u0026#34;a2htray\u0026#34;, Gender: 1, } data, err = json.Marshal(user) fmt.Println(data, err) } 执行输出如下：\n[123 34 78 97 109 101 34 58 34 97 50 104 116 114 97 121 34 44 34 71 101 110 100 101 114 34 58 49 125] 29 \u0026lt;nil\u0026gt; 从输出可知，自定义的 User 的值序列化后的字节长度为 29。\n接着，使用 Protocol Buffer 生成的 User 结构并使用 proto.Marshal 方法对值进行序列化，代码如下：\nfunc main() { userPB := \u0026amp;model.User{ Name: \u0026#34;a2htray\u0026#34;, Gender: 1, } data, err = proto.Marshal(userPB) fmt.Println(data, len(data), err) } 执行输出如下：\n[10 7 97 50 104 116 114 97 121 16 1] 11 \u0026lt;nil\u0026gt; 从输出可知，Protocol Buffer 生成的 User 类型的值序列化后的字节长度为 11。\n综上，分别使用 JSON 和 Protocol Buffer 序列化相同的数据信息，使用 Protocol Buffer 得到的字节长度要更小，更有得于在网络中的传输。\n完整代码 演示完成后，当前项目的目录结构如下：\nmodel - user.pb.go # 通过 protoc 命令生成 proto - user.proto # 定义数据结构 main.go main.go 的完整内容如下：\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;./model\u0026#34; \u0026#34;google.golang.org/protobuf/proto\u0026#34; ) type User struct { Name string Gender int32 } func main() { user := \u0026amp;User{ Name: \u0026#34;a2htray\u0026#34;, Gender: 1, } data, err := json.Marshal(user) fmt.Println(data, len(data), err) userPB := \u0026amp;model.User{ Name: \u0026#34;a2htray\u0026#34;, Gender: 1, } data, err = proto.Marshal(userPB) fmt.Println(data, len(data), err) } 总结  Protocol Buffer 序列化的数据量更小； ","date":"2022-04-09","img":"","permalink":"/posts/protocol-buffer-reduce-data-size/","series":null,"tags":["protocol buffer"],"title":"Protocol Buffer 减少传输数据的大小"},{"categories":["Go"],"content":"Protocol Buffer（Protobuf） 是一种高效的数据结构序列化的机制，同时也是一种结构化数据的存储格式。\n 序列化与反序列化\n 序列化：将数据结构或对象转换成二进制串的过程； 反序列化：将序列化后的二进制串转换成数据结构或对象的过程；   语法 /* * 语法 *//* * 指定 Protobuf 解析使用的版本，可以是 proto3 或 proto2 */syntax = \u0026#34;proto3\u0026#34;;/* * message 定义中的每一个字段都有一个唯一标识，该标识用于在二进制格式中识别字段 * 字段的标识一旦使用就不要进行修改 * 当标识为 1 到 15 时，使用一个字节进行编码，字节信息中包含字段的标识以及类型 * 当标识为 16 到 2047 时，使用两个字节进行编码 * Field numbers in the range 16 through 2047 take two bytes. So you should reserve the numbers 1 through 15 for very frequently occurring message elements. * 在编码的过程中，标识使用应当留有余地，便于将来扩展 * 标识最小的值是 1，最大的值为 2^29-1 * 不能使用的标识为 19000 到 19999 * 不能再使用已经被 reserved 的标识 *//* 定义 message 的语法： message ${MessageName} { ${Scalar Value Type} ${FieldName1} = ${Tag Number1}; . . . ${Scalar Value Type} ${FieldNameN} = ${Tag NumberN}; } */message MessageTypes { /* * 标量值类型 */ string stringType = 1; // 字符串可以是 UTF-8 编码，也可以是一个 7 比特的 ASCII 字符，默认为“”  // 数值类型，默认为 0  int32 int32Type = 2; // 使用变量长度进行编码，如果是负数，请使用 sint32  int64 int64Type = 3; // 使用变量长度进行编码，如果是负数，请使用 sint64  uint32 uInt32Type = 4; // 使用变量长度进行编码  uint64 uInt64Type = 5; // 使用变量长度进行编码  sint32 sInt32Type = 6; // 使用变量长度进行编码，处理负数更高效  sint64 sInt64Type = 7; // 使用变量长度进行编码，处理负数更高效  fixed32 fixed32Type = 8; // 变量总是占 4 个字节，当值大于 2^28 时，比使用 uint32 更有效率  fixed64 fixed64Type = 9; // 变量总是占 8 个字节，当值大于 2^56 时，比使用 uint64 更有效率  sfixed32 sfixed32Type = 10; // 变量总是占 4 个字节  sfixed64 sfixed64Type = 11; // 变量总是占 8 个字节  bool boolType = 12; // 布尔类型，默认为 false  bytes bytesType = 13; // 可包含任意长度的字节数组，默认为长度为 0 的字节数组  double doubleType = 14; float floatType = 15; enum Week { UNDEFINED = 0; // 第 1 个值  SUNDAY = 1; MONDAY = 2; TUESDAY = 3; WEDNESDAY = 4; THURSDAY = 5; FRIDAY = 6; SATURDAY = 7; } Week wkDayType = 16; /* * 定义标量值类型的集合 * Syntax: repeated ${ScalarType} ${name} = TagValue */ repeated string listOfString = 17; // List[String] }/* * 在其它 message 中使用已定义的 message */message Person { string fname = 1; string sname = 2;}message City { Person p = 1;}/* * 嵌套的 message 定义 */message NestedMessages { message FirstLevelNestedMessage { string firstString = 1; message SecondLevelNestedMessage { string secondString = 2; } } FirstLevelNestedMessage msg = 1; FirstLevelNestedMessage.SecondLevelNestedMessage msg2 = 2;}/* * .proto 文件的引入 */// one.proto // message One { // string oneMsg = 1; // } // two.proto // import \u0026#34;myproject/one.proto\u0026#34; // message Two { // string twoMsg = 2; // } /* * 高级知识点 *//* * message 发生改变时，永远不要修改或使用已经删除字段的标识 *//* * 使用 reserved 保留已删除的标识或字段名 */message ReservedMessage { reserved 0, 1, 2, 3 to 10; // 这里的标识不可再使用  reserved \u0026#34;firstMsg\u0026#34;, \u0026#34;secondMsg\u0026#34;, \u0026#34;thirdMsg\u0026#34;; // 这里的字段名不可再使用 }/* * 引用其它文件中定义的 message */import \u0026#34;google/protobuf/any.proto\u0026#34;;message AnySampleMessage { repeated google.protobuf.Any.details = 1;}/* * OneOf * 相同于 union，只能是其中一个 * 使用 oneof 的 message 不能被 repeated */message OneOfMessage { oneof msg { string fname = 1; string sname = 2; };}/* * Maps * map 字段不能被 repeated */message MessageWithMaps { map\u0026lt;string, string\u0026gt; mapOfMessages = 1;}/* * Packages * 声明一个包名，防止同名的 message * 语法: package ${packageName}; 访问方式 ${packageName}.${messageName} = ${tagNumber}; *//* * 在 RPC 系统中使用，其中可以定义方法 */message SearchRequest { string queryString = 1;}message SearchResponse { string queryResponse = 1;}service SearchService { rpc Search (SearchRequest) returns (SearchResponse);}数据类型 Protobuf 内置的数据类型以及在 Go 中对应的数据类型：\n   Protobuf Go     double float64   float float32   int32 int32   int64 int64   uint32 uint32   uint64 uint64   sint32 int32   sint64 int64   fixed32 uint32   fixed64 uint64   sfixed64 int64   bool bool   string string   bytes []byte    书写规范 代码编写要遵循某种特定的规则，如 Python 的 PEP8，.proto 文件的内容也应该按照统一的格式，这样才能规范团队编码风格，易于他人理解。\n message 采用驼峰命名法且首字母大写；  message UserConfig {} // 符合 message user_config {} // 不符合  字段名采用下划线分隔命名法且均小写；  message Product { string fasta_origin = 1;} // 符合 message Product { string FastaOrigin = 1} // 不符合  枚举型命名格式与 message 相同，枚举值全部大写，并且用下划线分隔命名法；  enum Week { MY_MONDAY = 0} // 符合 enum Week { MyMonday = 0} // 不符合  service 和方法名都采用驼峰命名法，并且首字母大写；  service Greeter { rpc SayHello(HelloRequest) returns (HelloReply);} // 符合 service Greeter { rpc say_hello(HelloRequest) returns (HelloReply);} // 不符合 与 JSON 的区别    Protobuf JSON     由 Google 开发、用于序列化和反序列化结构化数据的高效编码方式 轻量型的数据交换格式   可自定义规则、方法的消息格式 仅仅只是一种消息格式   二进制格式 文本格式   支持的语言有限 绝大部分语言都支持   微服务间数据传输的格式 WEB 应用与服务器间的传输格式   相同数据序列化后的数据量较小 相同数据序列化后的数据量较大    参考  https://learnxinyminutes.com/docs/protocol-buffer-3/ https://zhuanlan.zhihu.com/p/95869546  ","date":"2022-04-08","img":"","permalink":"/posts/protocol-buffer-syntax/","series":null,"tags":["protocol buffer"],"title":"Protocol Buffer 语法"},{"categories":["Python","可视化"],"content":"每当有快速绘制图表的需求时，第一时间反应到的肯定是 Matplotlib，因为其官方提供了详细的 API 文档及示例。但是每次在编码时，总是时不时地需要查看文档，不利用于可视化快速成型。所以在本文中罗列一些 bar 图的快速实现，方便 Ctrl+C/V。\n基本实现 import matplotlib.pyplot as plt import numpy as np data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) plt.bar( x, # bar 在 x 轴的位置 data, width=0.6, # bar 的宽度 label=\u0026#39;Sales\u0026#39;, ) plt.xticks( x, # 标签的位置 [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;], ) plt.legend() plt.title(\u0026#39;Products\u0026#39;) bar 设置颜色 import matplotlib.pyplot as plt import numpy as np colors = [\u0026#39;#009392\u0026#39;, \u0026#39;#39b185\u0026#39;, \u0026#39;#9ccb86\u0026#39;, \u0026#39;#e9e29c\u0026#39;, \u0026#39;#eeb479\u0026#39;, \u0026#39;#e88471\u0026#39;, \u0026#39;#cf5974\u0026#39;] data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) plt.bar( x, data, width=0.6, color=colors, # 单值或者可迭代对象，如果长度与数组不匹配则会从头反复使用色值 ) plt.xticks( x, [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;], ) plt.title(\u0026#39;Sales\u0026#39;) 显示数值 import matplotlib.pyplot as plt import numpy as np colors = [\u0026#39;#009392\u0026#39;, \u0026#39;#39b185\u0026#39;, \u0026#39;#9ccb86\u0026#39;, \u0026#39;#e9e29c\u0026#39;, \u0026#39;#eeb479\u0026#39;, \u0026#39;#e88471\u0026#39;, \u0026#39;#cf5974\u0026#39;] data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) bar = plt.bar( x, data, width=0.6, color=colors, ) plt.bar_label( bar, label_type=\u0026#39;edge\u0026#39;, # 标签显示的位置，edge 为默认值；如果是 center 则显示在 bar 中间（垂直水平居中） ) plt.xticks( x, [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;], ) plt.title(\u0026#39;Sales\u0026#39;) 层叠 bar 图 import matplotlib.pyplot as plt import numpy as np data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) bar1 = plt.bar( x, data_man, label=\u0026#39;Man\u0026#39;, color=\u0026#39;#009392\u0026#39;, ) bar2 = plt.bar( x, data_woman, bottom=data_man, label=\u0026#39;Woman\u0026#39;, color=\u0026#39;#cf5974\u0026#39;, ) plt.bar_label( bar1, label_type=\u0026#39;center\u0026#39;, labels=data_man, # 设置显示的值 ) plt.bar_label( bar2, label_type=\u0026#39;center\u0026#39;, labels=data_woman, ) plt.xticks( x, [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;], ) plt.legend() 多条 bar 通过调整 bar 的位置和宽度来实现多条 bar 不重叠显示。\nimport matplotlib.pyplot as plt import numpy as np data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) width = 0.4 bar1 = plt.bar( x - width/2, # 位置 data_man, width=width, # 宽度 label=\u0026#39;Man\u0026#39;, color=\u0026#39;#eeb479\u0026#39;, ) bar2 = plt.bar( x + width/2, data_woman, width=width, label=\u0026#39;Woman\u0026#39;, color=\u0026#39;#cf5974\u0026#39;, ) plt.bar_label(bar1) plt.bar_label(bar2) plt.legend() 动态 bar 图 import matplotlib.pyplot as plt import numpy as np from matplotlib.animation import FuncAnimation data_man = [120, 200, 150, 80, 70, 110, 130] frames = 10 fig = plt.figure() axes = fig.add_subplot(1,1,1) axes.set_ylim(0, 250) def generate_animate_data(data, n): \u0026#34;\u0026#34;\u0026#34;生成每帧的数据\u0026#34;\u0026#34;\u0026#34; animate_data = [] for v in data: animate_data.append(np.linspace(0, v, n)) return np.array(animate_data) animate_data = generate_animate_data(data_man, frames) def animate(i): plt.bar( [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;], animate_data[:,i], color=\u0026#39;#eeb479\u0026#39;, label=\u0026#39;Man\u0026#39; ) ani = FuncAnimation( fig, animate, frames=frames, # 帧数 interval=300, ) plt.title(\u0026#39;Man\u0026#39;) bar 图案 plt.bar 函数有两个可选参数 facecolor 和 edgecolor 控制。\nimport matplotlib.pyplot as plt import numpy as np bar_styles = { \u0026#39;man\u0026#39;: { \u0026#39;facecolor\u0026#39;: \u0026#39;#ee8479\u0026#39;, \u0026#39;edgecolor\u0026#39;: \u0026#39;black\u0026#39;, \u0026#39;hatch\u0026#39;: \u0026#39;//\u0026#39;, }, \u0026#39;woman\u0026#39;: { \u0026#39;facecolor\u0026#39;: \u0026#39;#cf5974\u0026#39;, \u0026#39;edgecolor\u0026#39;: \u0026#39;black\u0026#39;, \u0026#39;hatch\u0026#39;: \u0026#39;--\u0026#39;, } } data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) width = 0.4 bar1 = plt.bar( x - width/2, data_man, width=width, label=\u0026#39;Man\u0026#39;, **bar_styles[\u0026#39;man\u0026#39;] ) bar2 = plt.bar( x + width/2, data_woman, width=width, label=\u0026#39;Woman\u0026#39;, **bar_styles[\u0026#39;woman\u0026#39;] ) plt.bar_label(bar1) plt.bar_label(bar2) plt.legend() ","date":"2022-04-05","img":"","permalink":"/posts/python-matplotlib-bar-tips/","series":null,"tags":["Matplotlib"],"title":"Matplotlib Bar 图常规编码"},{"categories":["Python","数据挖掘"],"content":"k-means 算法是一种无监督的聚类算法，其优点是逻辑简单、易于实现。\n基本原理 质心是指一个簇中样本的均值向量，k-means 中的 means 就是从这里来的。当确定 k 个质心后，需要计算样本与 k 个质心的距离，而样本则归属于距离最近的质心所在的簇。随着算法的迭代，质心的位置会发生变化。质心的变化程度也是算法结束的一个条件，迭代前后质心位置变化通常使用 SSE 来刻画。\n其中 $n$ 是质心的维数，$c^{(t)}_{ij}$ 表示 $t$ 次迭代中第 $i$ 个质心的第 $j$ 维值。\n步骤  确定 k 值、最大迭代数及误差值； 随机选择 k 个样本作为质心； 分别计算样本与质心的距离，将样本划分到 k 个簇； 重新计算 k 个簇的质心，比较前后质心的误差；  若误差小于等于设置的误差值，则算法结束； 若误差大于设置的误差值，则执行步骤 5；   判断是否达到最大迭代数，若未达到则执行步骤 3，否则算法结束；  问题 选择 k-means 算法做聚类分析时，以下几个问题值得注意：\n 初始质心的选择； k 值的确定； 距离公式的确定；  k-means 算法容易局部最优，并且算法的结果在很大程度上取决于初始质心的选择，不同的初始质心可能会得到截然不同的聚类结果。同时，在面对未知类别个数的数据集时，如何确定 k 值也是一件麻烦事。通常做法都在小样本集上尝试不同的 k 值，然后比较聚类的结果并将 k 值定为跑得最好结果的那次 k 值。距离公式的选择则是需要依靠领域知识，因为在不同的领域中，样本的相似度的计算方式会有所不同。\n完整代码 import numpy as np import matplotlib.pyplot as plt def distance(x1, x2): \u0026#34;\u0026#34;\u0026#34;欧式距离\u0026#34;\u0026#34;\u0026#34; return np.sqrt(np.sum(np.power(x1 - x2, 2))) def sse(centroids1, centroids2): return np.sum(np.sqrt(np.sum(np.power(centroids1 - centroids2, 2), axis=1))) def update_centroid(centroids, data): r, _ = data.shape cluster_idxs = [] for i in range(len(centroids)): cluster_idxs.append([]) for i in range(r): ds = np.array([distance(data[i], centroid) for centroid in centroids]) sorted_idxs = np.argsort(ds) cluster_idxs[sorted_idxs[0]].append(i) new_centroids = [] for i, cluster_idx in enumerate(cluster_idxs): if len(cluster_idx) == 0: new_centroids.append(centroids[i]) else: new_centroids.append(np.mean(data[cluster_idx], axis=0)) return np.array(new_centroids) def initial_centroids(k, data): r, _ = data.shape idxs = np.arange(0, r) np.random.shuffle(idxs) return data[idxs[:k]] def cluster(centroids, data): r, _ = data.shape cluster_idxs = [] for i in range(len(centroids)): cluster_idxs.append([]) for i in range(r): ds = np.array([distance(data[i], centroid) for centroid in centroids]) sorted_idxs = np.argsort(ds) cluster_idxs[sorted_idxs[0]].append(i) return cluster_idxs data = np.random.uniform(5, 10, size=(400, 2)) k = 5 colors = [\u0026#39;#4e9e9d\u0026#39;, \u0026#39;#86cc7f\u0026#39;, \u0026#39;#506798\u0026#39;, \u0026#39;#4f1b63\u0026#39;, \u0026#39;#fbe85a\u0026#39;] tol = 1e-6 iteration = 12 plt.figure(figsize=(10, 4)) fig = plt.figure(figsize=(10, 15)) axes = fig.subplots(nrows=3, ncols=2) centroids = initial_centroids(k, data) i = 0 while iteration \u0026gt;= 0: if iteration % 2 == 1: cluster_idxs = cluster(centroids, data) for color_idx, cluster_idx in enumerate(cluster_idxs): fig.axes[i].scatter(data[cluster_idx][:,0], data[cluster_idx][:,1], c=colors[color_idx]) fig.axes[i].scatter(centroids[:,0], centroids[:,1], s=30, marker=\u0026#39;*\u0026#39;, c=\u0026#39;red\u0026#39;) fig.axes[i].set_title(\u0026#39;iter %d\u0026#39; % iteration) i = i + 1 new_centroids = update_centroid(centroids, data) if sse(new_centroids, centroids) \u0026lt;= tol: centroids = new_centroids break centroids = new_centroids iteration = iteration - 1 下图是执行得到的一次结果图：\n其它  帖子讨论了 k-means 和 c-means 是否是相同的概念，得票最多的回答认为是同一概念，所以本文对两者不作区分；  总结  k-means 算法结束的两个条件；  迭代结束； 质心位置变化小于误差值；   Python 实现 k-means 算法； ","date":"2022-04-02","img":"","permalink":"/posts/data-analysis-kmeans/","series":null,"tags":["k-means"],"title":"K-Means 基本原理及其实现"},{"categories":["Go","Web"],"content":"Revel 是一个以高效率、高性能著称的 Go Web 框架，提供了路由、参数解析和验证、会话机制、模板机制、缓存和任务管理等诸多常用的 Web 开发功能。同时作为一个全栈的 MVC 框架， Revel 通过模块实现了组件的复用，因此可以大大提高开发者的效率。其高性能则是依托 Go 语言的性能，相信这个不必多说。但相较于其它职责相对单一的 Web 框架（如 Gin、go-restful），Revel 只能说是在保证性能的基础上尽可能地对开发者友好。\n问题重现 环境\n  Go 的版本：go1.16.9 windows/amd64\n  Revel：v1.0.0\n  今天在试验 Revel 项目时，运行新建的项目会报错，如下：\n$ revel run -a . ERROR 10:46:39 file.go:372: Error seeking=github.com/revel/revel count=1 App Import Path=github.com/revel/revel filesystem path=github.com/revel/revel errors=\u0026#34;[-: no required module provides package github.com/revel/revel; to add it:\\n\\tgo get github.com/revel/revel]\u0026#34; Downloading related packages ... completed. Revel executing: run a Revel application WARN 10:46:41 harness.go:175: No http.addr specified in the app.conf listening on localhost interface only. This will not allow external access to your application Changed detected, recompiling Parsing packages, (may require download if not cached)...Changed detected, recompiling Completed ERROR 10:46:44 build.go:406: Build errors errors=\u0026#34;C:\\\\Users\\\\a2htray\\\\go\\\\pkg\\\\mod\\\\github.com\\\\revel\\\\revel@v1.0.0\\\\cache\\\\memcached.go:11:2: no required module provides package github.com/bradfitz/gomemcache/memcache; to add it:\\n\\tgo get github.com/bradfitz/gomemcache/memcache\\nC:\\\\Users\\\\a2htray\\\\go\\\\pkg\\\\mod\\\\github.com\\\\revel\\\\revel@v1.0.0\\\\cache\\\\redis.go:10:2: no required module provides package github.com/garyburd/redigo/redis; to add it:\\n\\tgo get github.com/garyburd/redigo/redis\\nC:\\\\Users\\\\a2htray\\\\go\\\\pkg\\\\mod\\\\github.com\\\\revel\\\\revel@v1.0.0\\\\cache\\\\inmemory.go:12:2: no required module provides package github.com/patrickmn/go-cache; to add it:\\n\\tgo get github.com/patrickmn/go-cache\\n\u0026#34; C:\\Users\\a2htray\\go\\src\\omics-framework\\C:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\memcached.go:11 WARN 10:46:44 build.go:420: Could not find in GO path file=C:\\\\Users\\\\a2htray\\\\go\\\\pkg\\\\mod\\\\github.com\\\\revel\\\\revel@v1.0.0\\\\cache\\\\memcached.go:11 ERROR 10:46:44 harness.go:239: Build detected an error error=\u0026#34;Go Compilation Error (in C:\\\\Users\\\\a2htray\\\\go\\\\pkg\\\\mod\\\\github.com\\\\revel\\\\revel@v1.0.0\\\\cache\\\\memcached.go:11:2): no required module provides package github.com/bradfitz/gomemcache/memcache; to add it:\u0026#34; Error compiling code, to view error details see proxy running on http://:9000 Time to recompile 2.4257731s 新建的 Revel 项目使用 go.mod 对包进行管理，初始的包如下：\nrequire ( github.com/go-stack/stack v1.8.1 // indirect github.com/revel/modules v1.0.0 github.com/revel/revel v1.0.0 ) 通过错误输出，可知当前项目缺少了 3 个包：\ngithub.com/bradfitz/gomemcache/memcache github.com/garyburd/redigo/redis github.com/patrickmn/go-cache 解决办法 既然是项目缺少包，那就只要把缺失的包 go get 一下即可。\n$ go get github.com/bradfitz/gomemcache/memcache $ go get github.com/garyburd/redigo/redis $ go get github.com/patrickmn/go-cache 再次运行：\n$ revel run -a . Revel executing: run a Revel application WARN 11:33:47 harness.go:175: No http.addr specified in the app.conf listening on localhost interface only. This will not allow external access to your application Changed detected, recompiling Parsing packages, (may require download if not cached)... Completed Changed detected, recompiling INFO 11:33:54 app run.go:34: Running revel server INFO 11:33:54 app plugin.go:9: Go to /@tests to run the tests. Revel proxy is listening, point your browser to : Revel engine is listening on.. localhost:52469 9000 Time to recompile 7.0696399s 其它 在这个 issue 1528  里，有人说是 Go 版本问题，即在 Go 1.15 中是可以运行的。我想解决上面的问题，就把缺失包补上就可以了，而且也猜应该不是 Go 版本问题，毕竟 Revel 的 cache 实现中也确实使用了这 3 个包。再深入想一想，如果 Revel 项目也是通过 Go Module 管理包的话，revel run 的时候就会自动下载这些包。\n","date":"2022-03-31","img":"","permalink":"/posts/go-revel-run-require-packages/","series":null,"tags":["Revel"],"title":"Go 1.16 运行 Revel 项目"},{"categories":["Web"],"content":"同源策略（Same-Origin Policy，SOP）是一种保护 Web 资源的安全机制，它限制了不同源之间的资源访问。需要说明的是，SOP 只作用于应用脚本，这意味着在 HTML 标签中可以引入不同源的图片、CSS 文件或动态加载的脚本文件（见验证 1）。\n同源 URL 统一资源标识符（Uniform Resource Locator，URL）标识了一个 Web 资源，其格式为：\nschema://host[:port][/path ...]\n其中 schema 可为 http 或 https，port 默认为 80。如果两个 URL 的 schema、host、port 都相同时，则认为这两个 URL 是同源的。现有 URL 为 http://foo.com/bar，以下是其它 URL 是否同源的说明。\n   URL 是否同源 说明     https://foo.com 否 schema 不同   http://bar.com 否 host 不同   http://foo.com:81/bar 否 port 不同   http://foo.com/zot 是 3 个都相同    访问规则 通常，直接读取跨域资源是不允许的，但仍然可以通过内嵌跨域资源进行访问。以下是允许跨域访问的规则：\n   方式 说明     iframes 响应头的 X-Frame-Options 字段可以设置 \u0026lt;frame\u0026gt;、\u0026lt;iframe\u0026gt;、\u0026lt;embed\u0026gt; 或 object 标签可引用的页面，但跨域读 iframe 里的内容是不允许的   CSS \u0026lt;link\u0026gt; 标签的 href 属性和 CSS 文件中的 @import 指令   forms 此处不应该是读取，而是说 \u0026lt;form\u0026gt; 的 action 属性可以设置不同源的 URL，指的是目标服务可以接收不同源的数据   images 通过 \u0026lt;img\u0026gt; 标签访问跨域图片，但在 canvas 元素里加载跨域图片是不允许的   multimedia 通过 \u0026lt;video\u0026gt; 和 \u0026lt;audio\u0026gt; 标签加载跨域的多媒体资源   script 通过 \u0026lt;script\u0026gt;  标签加载跨域的脚本，但请求跨域的 API 是不允许的    所以以上的规则容易变成 Web 服务攻击的入口，应当警惕。\n验证 验证 1 示例目录结构\n验证 1 - static - images profile.jpg index.html main.go // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { fs := http.FileServer(http.Dir(\u0026#34;./static/\u0026#34;)) http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static\u0026#34;, fs)) log.Fatal(http.ListenAndServe(\u0026#34;:8001\u0026#34;, nil)) } \u0026lt;!-- index.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;验证 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;图片不受同源策略限制\u0026lt;/p\u0026gt; \u0026lt;img width=\u0026#34;100\u0026#34; height=\u0026#34;100\u0026#34; alt=\u0026#34;profile\u0026#34; src=\u0026#34;http://localhost:8001/static/images/profile.jpg\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结  URL 是否同源取决于 schema、host、port 是否一致； 尽管跨域访问是不允许的，但仍然有一定的跨域可访问规则； ","date":"2022-03-29","img":"","permalink":"/posts/web-same-origin-policy/","series":null,"tags":["Web 安全"],"title":"同源策略 Same-Origin Policy"},{"categories":["Python"],"content":"在开发过程中，开发者常常需要对文件执行读写操作，仅以此文记录读写文件的常规用法。\n打开和关闭文件 Python 的内建函数 open 可以打开一个文件，可返回一个文件对象 TextIOWrapper（也称文件句柄）。打开的文件应当及时关闭，否则过多的文件对象容易造成内存占用，导致程序运行内存不足。按照是否调用文件对象的 close 方法，有两种打开和关闭文件的代码书写方式：\n 显式 close 隐式 close  显式 close\ndef open1(): f = open(\u0026#39;./students.dat\u0026#39;) try: lines = f.readlines() print(lines) finally: f.close() 隐式 close\ndef open2(): with open(\u0026#39;./students.dat\u0026#39;) as f: lines = f.readlines() print(lines)  支持 with 语句的对象需要实现 __enter__ 和 __exit__ 两个方法，其中 TextIOWrapper 类实现了 __exit__ 方法，IOBase 类实现了 __enter__ 方法。\n 上述两个函数的作用相同，都是用于打开 students.dat 文件并打印所有的行。\nopen 函数 内建函数 open 的签名如下：\ndef open( file: _OpenFile, mode: OpenTextMode = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: _Opener | None = ..., ) -\u0026gt; TextIOWrapper: ...  file：字符串文件路径或实现了 os.PathLike 抽象类的实例； mode：打开模式，默认 r，可选； buffering：设置缓冲策略，可选； encoding：编码格式，可选； errors：编码或解码发生错误时的错误信息，可选； newline：断行的方式，可用的参数值有 None、' '、'\\n'、'\\r' 和 '\\r\\n'，可选； closefd：必须为 True，否则报错，可选； opener：自定义的打开器，调用的函数，返回一个文件描述符，可选；  os.PathLike 抽象类 os.PathLike 是一个抽象类，定义了 __fspath__ 方法，任何实现了 __fspath__ 方法的类的实例都可以作为 open 函数的 file 参数值。\nimport os class MyFile(os.PathLike): def __init__(self, filename) -\u0026gt; None: self.filename = filename def __fspath__(self): return self.filename def open3(): with open(MyFile(\u0026#39;./students.dat\u0026#39;)) as f: lines = f.readlines() print(lines) mode 参数值 mode 参数值可为：\n   Mode      'r' 读打开（默认）   'w' 读打开，若文件不存在则创建，若文件存在则会清空文件内容   'x' 以独占的方式创建文件，如果文件已存在则报错   'a' 以追加的形式打开文件，文件不存在会创建，文件存在的话，不会清空文件内容   't' 文本模式（默认）   'b' 二进制打开文件   '+' 以更新的方式打开文件    f.close 方法 当文件对象调用 close 方法后，对象的 closed 属性会置为 True，也可以通过该属性可以检查文件对象是否关闭。\ndef view_f_closed(): f = open(\u0026#39;./students.dat\u0026#39;) f.close() print(f.closed) 读写文件 文件对象中有如下几个方法可用于读取文件内容：\n   方法 用法     .read(size=-1) 按指定的字节数读取文件内容，当 size 为 -1 时，表示读取全部   .readline(size=-1) 按指定的字符数读取一行的内容，当 size 为 None 或 -1 时，表示读取整行内容   .readlines() 读取文件中所有的行    文件对象中有如下几个方法可用于写入文件内容：\n   方法 用法     .write(string) 向文件写入字符串   .writelines(seq) 向文件中写入多行，换行符需要开发者指定    编码问题 若文件中存在中文，需要指定 encoding 参数的值，如：\ndef read_chinese(): with open(\u0026#39;./students.zh-cn.dat\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: lines = f.readlines() print(lines) 遍历文件所有的行 下面列表读取文件所有的行的几种方式。\n方式 1\ndef iterate_lines1(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: line = f.readline() while line != \u0026#39;\u0026#39;: print(line, end=\u0026#39;\u0026#39;) line = f.readline() 方式 2\ndef iterate_lines2(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: lines = f.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) 方式 3\ndef iterate_lines3(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: for line in f: print(line, end=\u0026#39;\u0026#39;) 总结 本文的完整代码如下：\nimport os def open1(): f = open(\u0026#39;./students.dat\u0026#39;) try: lines = f.readlines() print(lines) finally: f.close() def open2(): with open(\u0026#39;./students.dat\u0026#39;) as f: lines = f.readlines() print(lines) class MyFile(os.PathLike): def __init__(self, filename) -\u0026gt; None: self.filename = filename def __fspath__(self): return self.filename def open3(): with open(MyFile(\u0026#39;./students.dat\u0026#39;)) as f: lines = f.readlines() print(lines) def view_f_closed(): f = open(\u0026#39;./students.dat\u0026#39;) f.close() print(f.closed) def read_chinese(): with open(\u0026#39;./students.zh-cn.dat\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: lines = f.readlines() print(lines) def iterate_lines1(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: line = f.readline() while line != \u0026#39;\u0026#39;: print(line, end=\u0026#39;\u0026#39;) line = f.readline() def iterate_lines2(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: lines = f.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) def iterate_lines3(): with open(\u0026#39;./students.dat\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: for line in f: print(line, end=\u0026#39;\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;书写方式 1:\u0026#39;) open1() print(\u0026#39;书写方式 2:\u0026#39;) open2() print(\u0026#39;实现了 os.PathLike 抽象类\u0026#39;) open3() print(\u0026#39;调用 f.close 后:\u0026#39;) view_f_closed() print(\u0026#39;遍历所有的行 1:\u0026#39;) iterate_lines1() print(\u0026#39;遍历所有的行 2:\u0026#39;) iterate_lines2() print(\u0026#39;遍历所有的行 3:\u0026#39;) iterate_lines3() print(\u0026#34;读取中文:\u0026#34;) read_chinese() 运行输出为：\n书写方式 1: [\u0026#39;xiaoming\\n\u0026#39;, \u0026#39;xiaohong\\n\u0026#39;, \u0026#39;xiaolei\\n\u0026#39;, \u0026#39;xiaopang\\n\u0026#39;] 书写方式 2: [\u0026#39;xiaoming\\n\u0026#39;, \u0026#39;xiaohong\\n\u0026#39;, \u0026#39;xiaolei\\n\u0026#39;, \u0026#39;xiaopang\\n\u0026#39;] 实现了 os.PathLike 抽象类 [\u0026#39;xiaoming\\n\u0026#39;, \u0026#39;xiaohong\\n\u0026#39;, \u0026#39;xiaolei\\n\u0026#39;, \u0026#39;xiaopang\\n\u0026#39;] 调用 f.close 后: True 遍历所有的行 1: xiaoming xiaohong xiaolei xiaopang 遍历所有的行 2: xiaoming xiaohong xiaolei xiaopang 遍历所有的行 3: xiaoming xiaohong xiaolei xiaopang 读取中文: [\u0026#39;小明\\n\u0026#39;, \u0026#39;小红\\n\u0026#39;, \u0026#39;小磊\\n\u0026#39;, \u0026#39;小胖\\n\u0026#39;] 本文可总结为以下几点：\n 打开文件后，应该及时关闭。如果不想显式地调用 close 方法，推荐使用 with 语句； open 函数的 mode 参数指定了文件打开的模式，mode 参数的几个可选值非常重要； 列举了几个读写文件的常用方法，如读的 read、readline 和 readlines；写的 write 和 writelines； 3 种遍历文件所有行的方式； ","date":"2022-03-28","img":"","permalink":"/posts/python-read-and-write-file/","series":null,"tags":["文件操作"],"title":"Python 读写文件"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/offline/","series":null,"tags":null,"title":"Offline"}]