<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Zod 的学习与使用：Record 数据结构（三）</title><url>/post/learn-zod/02_record_schema/</url><categories><category>前端技术</category><category>Zod</category></categories><tags><tag>Zod</tag><tag>TypeScript</tag></tags><content type="html"><![CDATA[   学习资料： https://zod.dev/api 辅助：豆包 Zod 版本：4 Zod 中定义的 Record 对应着 TS 中的 Record，用于构建键值对。
1 2 3 4 5 6 7 8 import * as z from &#39;zod&#39; const StudentSchema = z.record(z.string(), z.string()) type Student = z.infer&lt;typeof StudentSchema&gt; // 等价于 type Student = Record&lt;string, string&gt; JSON 和对象 TS 中 Record 与 JSON 和对象相似，对应的概念如下：
Record：编译时的类型约束（类型工具），是对 “键值对对象” 的类型描述 JSON：文本格式（字符串），是数据传输 / 存储的 “序列化标准” 对象：运行时的数据结构（实体），是编程语言层面的 “键值对集合” Record 和对象的键名规则支持字符串 / 数字 / 布尔 / Symbol，但都会转换成字符串，而 JSON 的键名规则，仅支持双引号包裹的字符串。
而 Zod 的 Record 是 TS Record 的运行时校验实现。
示例 Record 的使用示例。
通过 z.union 约束键名规则
1 2 3 // union 约束键名规则为字符串、数字或符号 const KeyTypeSchema = z.union([z.string(), z.number(), z.symbol()]) const ObjectSchema = z.record(KeyTypeSchema, z.any()) 通过 z.enum 约束键名取值
1 2 3 // enum 约束键名取值为 &#34;a&#34;、&#34;b&#34; 或 &#34;c&#34; const KeyValueSchema = z.enum([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]) const ObjectSchema = z.record(KeyValueSchema, z.any()) 支持键名的校验
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const KeySchema = z.union([ z.string().min(4).max(10), z.number().int().min(0).max(100), ]) const ObjectSchema = z.record(KeySchema, z.any()) ObjectSchema.parse({ &#34;abcd&#34;: &#34;123&#34;, 10: &#34;456&#34;, }) // ObjectSchema.parse({ // &#34;a&#34;: &#34;123&#34;, // 10: &#34;456&#34;, // }) // 报错 z.partialRecord 在使用 z.enum 作为 z.record 的第一个参数时，会穷尽检查所有的枚举值是否存在，而使用 z.partialRecord 则会进行部分选择。
1 2 3 4 5 6 7 8 9 10 11 12 const KeySchema = z.enum([&#34;id&#34;, &#34;name&#34;, &#34;email&#34;]) const ObjectSchema = z.partialRecord(KeySchema, z.string()) ObjectSchema.parse({ id: &#34;123&#34;, name: &#34;张三&#34;, }) ObjectSchema.parse({ id: &#34;123&#34;, name: &#34;张三&#34;, email: &#34;zhangsan@example.com&#34;, })   ]]></content></entry><entry><title>Zod 的学习与使用：定义模式（二）</title><url>/post/learn-zod/01_define_schema/</url><categories><category>前端技术</category><category>Zod</category></categories><tags><tag>Zod</tag><tag>TypeScript</tag></tags><content type="html"><![CDATA[   学习资料： https://zod.dev/api 辅助：豆包 Zod 版本：4 模式，也就是数据结构，使用 Zod 时，我们要先定义模式，即定义数据结构的规则，然后调用 .parse 或 safeParse 进行校验。
开发环境的搭建 本节要搭建一个能运行 Zod 库的 TypeScript 开发环境，步骤如下：
1 2 3 4 5 6 7 # 项目目录 $ mkdir learn_zod $ cd learn_zod $ npm init -y # 安装依赖 $ npm install zod $ npm install -D typescript @types/node ts-node typescript：TS 编译器 @types/node：Node.js 的 TS 类型声明 ts-node：无需手动编译，直接运行 TS 文件 创建 TS 配置文件：
1 $ touch tsconfig.json 内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;ES2020&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;CommonJS&amp;#34;, &amp;#34;outDir&amp;#34;: &amp;#34;./dist&amp;#34;, &amp;#34;rootDir&amp;#34;: &amp;#34;./src&amp;#34;, &amp;#34;strict&amp;#34;: true, &amp;#34;esModuleInterop&amp;#34;: true, &amp;#34;skipLibCheck&amp;#34;: true, &amp;#34;forceConsistentCasingInFileNames&amp;#34;: true }, &amp;#34;include&amp;#34;: [ &amp;#34;src/**/*&amp;#34; ], &amp;#34;exclude&amp;#34;: [ &amp;#34;node_modules&amp;#34; ] } 1 2 # 创建测试 ts 文件目录 $ mkdir -p src/tests 跑个示例 验证开发环境是否最小完备：
1 $ touch src/tests/zod_env.ts 内容如下：
1 2 3 4 5 6 7 import * as z from …  ]]></content></entry><entry><title>Zod 的学习与使用：Zod 基础知识（一）</title><url>/post/learn-zod/00_zod_triple/</url><categories><category>前端技术</category><category>Zod</category></categories><tags><tag>Zod</tag><tag>TypeScript</tag></tags><content type="html"><![CDATA[   学习资料： https://zod.dev/ 辅助：豆包 Zod 版本：4 学习一个新的技术、框架或包，首先要解决的是事物的三个问题：
是什么 做什么 有什么 本文就是围绕 Zod 回答上面的三个问题，并在后续的文章中介绍“怎么用”。
是什么 TypeScript-first schema validation with static type inference.
一言以蔽之，Zod 是具有静态类型推导能力，以 TypeScript 优先的模式校验包。
Zod 的出现，解决了“TS 类型编译后消息、无法校验运行时数据”的问题，由此可见，Zod 是将类型安全（模式校验）从编译时延伸到运行时的工具。
编译时的类型安全由 TS 提供，如果使用的 JS，由 Zod 进行提供，这也就是上面“静态类型推导能力”的展现。而运行时的模式校验，则完全由 Zod 提供。
做什么 模式校验，即是对数据结构的校验，针对这一点，Zod 提供以下的能力：
校验数据类型与值规则 基础类型校验 复合类型校验 格式校验与逻辑判断 自动联动 TypeScript 类型：使用 z.infer 自定义校验规则 容错式校验与错误处理：parse -&amp;gt; 严格模式，safeParse -&amp;gt; 容错模式 数据转换：检验的同时可对数据进行转换 上述能力可适用于以下场景：
前端表单校验 API 数据校验 配置文件校验 跨端/跨服务数据校验 数据库操作校验 总的来说，Zod 能做的事可归纳于 3 点：
校验：校验任意来源数据的类型、格式、值规则，覆盖基础类型到复杂结构 联动：自动推导 TypeScript 类型，实现 “一份定义，同时满足编译时类型检查和运行时数据校验” 适配：支持自定义规则、容错处理、数据转换，能无缝适配前端表单、API 校验、配置校验等各类实战场景 有什么 Zod 的目的是验证数据结构，那么 Zod 就必然包含数据类型定义，有：
基础数据类型（Primitive Type） 胁迫数据类型（Coercion Type） 胁迫，代表一定的强制，即值会做一次强制转换。
基础数据类型包括：
1 2 3 4 5 6 7 8 9 10 import * as z from &amp;#34;zod&amp;#34; z.string() z.number() z.bigint() z.boolean() …  ]]></content></entry><entry><title>过年期间，除了吃喝、玩乐、锻炼，还要把 IT 技术再抓一抓。</title><url>/post/not-only-segment/2026-02-15/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>构建 MCP 服务端</title><url>/post/learn-mcp/build-mcp-server/</url><categories><category>人工智能</category><category>大语言模型</category></categories><tags><tag>MCP</tag><tag>摘录</tag><tag>Python</tag><tag>httpx</tag></tags><content type="html"><![CDATA[   学习来源： https://modelcontextprotocol.io/docs/develop/build-server 目标：构建一个“天气查询”的 MCP Server 编程语言：Python 天气接口文档： https://uapis.cn/docs/api-reference/get-misc-weather 前提条件 Python 的开发环境 MCP 主机（我使用的是 Cherry Studio） 注意事项 根据实现的 MCP Server 的类型不同，做日志功能时需要注意：
对于 stdio 类型：不要把日志打印到标准输出，如 在 Python 中不要使用 print()，但可以将输出定向到 sys.stderr 在 JavaScript 中不要使用 console.log() 在 Go 中不要使用 fmt.Println() 类似在其它语言中，向标准输出写入的语法或方法 对于 HTTP-based 类型：标准输出作为日志记录是没有问题 IMPORTANT！！！：Use a logging library that writes to stderr or files.
设置开发环境 我使用 conda 作为虚拟环境工具，并且使用 uv 作为包管理工具。
这里绕了一下，因为我不想在全局安装 uv 工具，不然总是要手动维护 uv 的版本。
1 2 3 4 5 6 7 $ conda create -n learn-mcp $ conda activate learn-mcp (learn-mcp) $ conda install conda-forge::uv (learn-mcp) $ uv init weather Initialized project `weather` at `/your/path/to/weather` (learn-mcp) $ source .venv/bin/activate (weather) (learn-mcp) $ uv add &amp;#34;mcp[cli]&amp;#34; httpx uv add &amp;ldquo;mcp[cli]&amp;rdquo; httpx 时，一定要保证你的 Python 版本大于 3.10。
编码 第一步，必然是先实例化一个 MCP 实例：
1 2 3 from …  ]]></content></entry><entry><title>MCP：服务器和客户端</title><url>/post/learn-mcp/server-and-client/</url><categories><category>人工智能</category><category>大语言模型</category></categories><tags><tag>MCP</tag><tag>摘录</tag></tags><content type="html">  本文继续做官方文档的学习和摘录，在服务器和客户端这一块，理解有效，有些翻译甚至有些勉强。
学习来源：
https://modelcontextprotocol.io/docs/learn/server-concepts https://modelcontextprotocol.io/docs/learn/client-concepts 服务端 MCP servers are programs that expose specific capabilities to AI applications through standardized protocol interfaces.
重点：对外提供特殊能力。
服务端关键的特性：
工具（Tools）：LLM 可调用的功能（由模型控制） 资源（Resources）：只读访问的数据源（由应用控制） 提示词（Prompts）：预设的指令模板（由用户控制） 工具 Tools enable AI models to perform actions. Each tool defines a specific operation with typed inputs and outputs. The model requests tool execution based on context.
有定义输入和输出的功能，可以认为是工具。MCP 约定的与工具相关的操作有：
方法 目的 返回 tools/list 发现可用的工具 模式固定的工具列表 tools/call 执行特定工具 工具的执行结果 资源 Resources provide structured access to information that the AI application can retrieve and provide to models as context.
两点：
结构化的信息 构成模型的上下文 应用程序可以直接访问资源并决定如何使用资源，使用方式可以是：
选择部分相关内容 向量化后检索 一次性全部交给模型 资源支持两种发现模式：
直接资源：特定数据的固定 URI，如 calendar://events/2024 资源模板：动态 URI，如 travel://activities/{city}/{category} 资源模板包含的元信息，如：
标题 描述 MIME MCP 约定的与资源相关的操作有：
方法 目的 返回 resources/list 查询可用的直接资源 资源数组 resources/templates/list resources/templates/list 资源数组 resources/read 获取资源内容 带元数据的资源内容 resources/subscribe 监控资源变化 确认消息 提示词 Prompts provide reusable templates. They allow MCP server authors to provide parameterized prompts for a domain, or showcase how to best use the MCP server.
可利用的模板。
MCP 约定的与提示词相关的操作有：
方法 目的 返回 prompts/list 查询可用的提示词 提示词数组 prompts/get 获取提示词内容 带传参的提示词 客户端 MCP clients are instantiated by host applications to communicate with particular MCP servers.
MCP 客户端由主机应用程序实例化，用于与特定 MCP 服务器通信。
The host is the application users interact with, while clients are the protocol-level components that enable server connections.
客户端是实现服务器连接的协议级组件。
客户端还可以为服务器提供若干功能：
探询（Elicitation）：在交互中获取用户特定信息，供服务器收集、使用 根目录（Roots）：允许客户端指定服务器应关注的目录，通过协调机制传达预期范围 采样（Sampling）：服务器通过客户端请求 LLM 完成，从而实现代理式工作流程   </content></entry><entry><title>我现在干着外包的活，时不时会投几个简历，外包仍不是长久之计。</title><url>/post/not-only-segment/2026-02-02/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>MCP：基础概念</title><url>/post/learn-mcp/basic-mcp/</url><categories><category>人工智能</category><category>大语言模型</category></categories><tags><tag>MCP</tag><tag>摘录</tag></tags><content type="html">  做项目要用到 MCP，所以对官方的文档进行学习及摘录，不然做出的东西一知半解，不深入。
学习来源： https://modelcontextprotocol.io 什么是 MCP MCP (Model Context Protocol) is an open-source standard for connecting AI applications to external systems.
MCP Server 是连接 AI 应用与外部系统的开源标准。
通过 MCP，AI 应用可以连接：
数据源（本地文件、数据库） 工具（Shell 命令、搜索引擎） 工作流（文中举例是“特殊提示词”，我理解应该是“具体任务”） MCP can have a range of benefits.
Developers: MCP reduces development time and complexity when building, or integrating with, an AI application or agent. AI applications or agents: MCP provides access to an ecosystem of data sources, tools and apps which will enhance capabilities and improve the end-user experience. End-users: MCP results in more capable AI applications or agents which can access your data and take actions on your behalf when necessary. 为开发者降低开发成本、复杂性 赋能 AI 应用或智能体 终端用户受益，更好地使用 AI 应用或智能体 MCP 提供了一套“连接”的标准，无疑是规范了开发者的开发逻辑，成本和复杂性必然是会降低的。同时，终端用户使用了赋予更多功能的 AI 应用或智能体，自然是提高了生产效率。
MCP 规范 JSON-RPC 消息格式、有状态连接
MCP 为 AI 应用提供了一套标准化的方式：
与语言模型共享上下文信息 向 AI 系统展示工具和功能 构建可组合的集成和工作流 …  </content></entry><entry><title>今天第一次在外包公司加班，项目有点赶，基本掌握了 MCP Server 的开发，还需要对 @mcp.resource 和 @mcp.prompt 进行了解。</title><url>/post/not-only-segment/2026-01-24/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>自然语言处理介绍</title><url>/post/natural-language-processing-fundamentals/chapter-01-introduction-to-natural-language-processing/</url><categories><category>人工智能</category><category>自然语言处理</category></categories><tags><tag>技术笔记</tag><tag>NLP</tag><tag>《自然语言处理基础》</tag></tags><content type="html">  目标：
能够介绍“什么是 NLP” 学习 NLP 的历史 NLP 与文本分析的区别 实现特定处理工作 NLP 工程的不同阶段 NLP 自然语言处理（NLP）是一个与多个学科交叉的领域，它脱胎于人工智能、语言学、形式语言及编译器等学科。
多学科：
人工智能（Artificial Intelligence）：NLP 的核心母体学科，为其提供算法与算力基础 语言学（Linguistics）：提供人类语言的语法、语义、语用规则体系 形式语言（Formal Languages）：研究抽象符号系统的语法规则 编译器（Compilers）：负责将高级语言转换为机器语言 Previously, a traditional rule-based system was used for computations.
此前，计算任务采用的是传统的基于规则的系统。
Today, computations on natural language are being done using machine learning and deep learning techniques.
如今，自然语言相关的计算任务正通过机器学习与深度学习技术来完成。
基于机器学习的自然语言处理的主要工作开始于 1980 年。
Vs. 文本分析 Text analytics is the method of extracting meaningful insights and answering questions from text data.
文本分析是从文本数据中提取有价值的洞察并解答相关问题的方法。
文本分析：从文本中提取价值。
NLP 的处理对象除了文本，还可以是语音，NLP 大体可分成 Natural Language Understanding (NLU) and Natural Language Generation (NLG) 两个核心子任务。
核心子任务：
NLU：让计算机理解语言的过程； NLG：让计算机表达出人类理解的内容的过程； NLP 步骤 Tokenization PoS Tagging（词性标注） Tokenization（分词）：将一个完整句子拆解为其组成基本单位（token）的过程。
n-grams（n 元语法）：基于滑动窗口思想，将文本序列（字符 / 单词）切分为连续的 n 个元素 …  </content></entry><entry><title>看章泽天的播客，对话刘嘉玲，就让时间来稀释一切吧，经历多了自然就放下了。</title><url>/post/not-only-segment/2026-01-15/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>在知乎刷到不少王石的话题，特意去看了《王石采访段永平》，看到了英雄迟暮、思维延展，受益了。“长期主义”、“热爱一件事”</title><url>/post/not-only-segment/2026-01-08/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>《三国史话》书摘及延伸（3）</title><url>/post/stories-of-the-three-kingdoms/p3/</url><categories><category>课外阅读</category></categories><tags><tag>读书</tag><tag>书摘</tag></tags><content type="html">  多看书，看些感兴趣的书，也别管它有没有用。
今天在看的书是《三国史话》。
所以诸葛亮死后，蜀汉还有二十九年的命运。这二十九年之中，前十二年，总统国事的是蒋琬；中七年是费祎；后十年是姜维。
蒋琬、费祎、姜维。
孙吴为什么要建都南京呢？长江下游的都会，本来是在苏州，而后来迁徙到扬州的。
关于这一个问题，孙权在袭取关羽时，曾和吕蒙研究过，到底取徐州与取荆州，孰为有利？吕蒙说：徐州，北方并无重兵驻守，取之不难，然其地为“骁骑所骋”，即七八万人，并不易守，还是全据长江的有利。
吕蒙认为，徐州易取同时也难守，取荆州更稳当些。
真正的恤民，司马氏自然也说不上，然而他当时剥削扰害的程度，大约人民还可忍受。所以在大乱之后，人民只求活命，别无奢望之时，也就勉强相安了。
当时百姓也是“两害取其轻”的簇拥者。
当两个文明程度不同的社会接触以后，较高的社会文明，总会输入文明程度较低的社会中去。
读完了《三国史话》，因为是上上辈人的著作，读起来比较费劲，有些地方看得快，意思都没看明白，但又不想再看一遍。
文中很多都是作者的猜测，作者的写作思路是：先把已有、流行于世的一些事件说一遍，然后抛出“应不实”，最后没个证据。
历史书，也没办法，人都不在了，实在不好去求证了。
  </content></entry><entry><title>开工的第二天，持续学习的动力小了一些，也没怎么看书，晚上回去一定要看点技术书。</title><url>/post/not-only-segment/2026-01-05/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>Git Commit 修改作者信息</title><url>/post/git-commit-reset-author/</url><categories><category>生产力工具</category><category>Git</category></categories><tags><tag>Git</tag><tag>解决问题</tag></tags><content type="html"><![CDATA[  起因 现在公司上班，用的是我个人电脑，所以 git 信息是我个人的。
新建项目，推送分支持时，导致线上仓库的 commit 的作者信息是我个人的。
原因就是，项目级别的作者信息 user.name 和 user.email 没设置，git 自动使用了全局的作者信息。
改 毕竟是公司的项目，怎么可以用到个人的信息，改！👊🐼
第一步：设置项目级的作者信息
1 2 $ git config user.name &#34;公司用户名&#34; $ git config user.email &#34;公司邮箱&#34; 第二步：修改 commit 作者信息（但不改 commit 消息）
1 $ git commit --amend --reset-author --no-edit ❗❗❗上述命令只能修改最近一次 commit 的作者信息。
第三步：推送至远程仓库
1 $ git push --force-with-lease origin &lt;分支名&gt; 延伸 &ndash;force-with-lease 选项
先检查远程分支内容，若存在本地未有分支，则拒绝推送。相对 -f（强制推送），更安全。
  ]]></content></entry><entry><title>这话说的挺触动的，35 岁其实也不算大，但目前的行情还是有点“你不能是 35”的气味。</title><url>/post/not-only-segment/2025-12-31_2/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>人，随着年龄的增长，为什么会越来越没有心气，原因有三：一、经历过；二、无力感；三、重复一和二。</title><url>/post/not-only-segment/2025-12-31/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>12 年左右的网络，文青林立，这个人设很受大家簇拥，而现在，形式变了，花样多了，但本质依旧是在找存在感，每一代人的存在感都不一样</title><url>/post/not-only-segment/2025-12-30/</url><categories><category>句否</category></categories><tags><tag>一句话</tag><tag>一张图</tag></tags><content type="html">  
  </content></entry><entry><title>《三国史话》书摘及延伸（2）</title><url>/post/stories-of-the-three-kingdoms/p2/</url><categories><category>课外阅读</category></categories><tags><tag>读书</tag><tag>书摘</tag></tags><content type="html">  多看书，看些感兴趣的书，也别管它有没有用。
今天在看的书是《三国史话》。
三国的纷争，起于汉献帝初平元年东方州郡的起兵讨伐董卓。其时为公元190年。直到晋武帝太康元年，把东吴灭掉，天下才算统一。其时为公元280年。分裂扰乱的局面，共历九十一年。
从“十八路诸侯讨卓”至“三家归晋”，共历时 91 年。
何进的死，虽然京城里经过一番扰乱，恰好把积年盘踞的宦官除掉了，倒像患外症的施行了手术一般。
&amp;amp;ldquo;何进之死&amp;amp;rdquo;，加速了宦官集团的覆灭。
他又使吕布把汉朝皇帝和官员的坟，都掘开了，把坟中所藏珍宝取去。
这 &amp;amp;hellip;
袁术使孙坚攻刘表，虽然战胜，围困襄阳，然孙坚的用兵太觉轻率，因单马独出，被刘表的军士射杀了。
诸葛亮隆中之对，有一句话说：“今曹操已拥百万之众，挟天子以令诸侯，此诚不可与争锋。”
然则说三国史事，一定要把蜀汉看作正统，魏、吴看作僭窃，也不过是一种陈旧的见解罢了。
作者把视角拉平了，三个都一样，正不正统都是一种说辞。
董承本来是牛辅的余孽，哪里是什么公忠体国的人？他叫曹操进京，也不过是想借曹操的力量，排除异己罢了，哪里会真和曹操一心？
当时的文人、达官显贵，只知赏景作乐，不关心民间疾苦，把这不长庄稼的盐碱地称为“许田积雪”。
刘备是个有领袖欲的人，他是不甘心坐第二把交椅的。所以当他和曹操联合破灭吕布之后，他很可以依附曹操，做一个资深望重的大员了。他却不肯甘心，又和董承勾结，反叛曹操。
刘备的起起浮浮。
孙坚有四个儿子：大的唤作孙策，第二个就是孙权，第三个唤作孙翊，第四个唤作孙匡。
孙翊的性质，最和孙策相像。孙策临死时，张昭[2]等都逆料他要把后事托付给孙翊，他却把印绶佩在孙权身上，对他说：“举江东之众，决机于两阵之间，与天下争衡，卿不如我。举贤任能，各尽其心，以保江东，我不如卿。”
刘表的性质，究竟是个文人。他只会坐观成败，图收渔人之利，而不会身临前敌，去攻城夺地。此等人物，在天下扰乱时亦足以保境息民，偷一时之安，到天下将定时，就没有立足之地了。
天下大乱时，可保一方平安。天下待定时，已为他人鱼肉，没有抵抗之力。
建安十三年（208年），周瑜率军与刘备联合，于赤壁之战中大败曹操，由此奠定了“三分天下”的基础；又率军大破曹仁，拜偏将军领南郡太守。建安十五年（210年）病逝于巴丘，年仅36岁。
36 岁就挂了，确实是英年早逝，放到现代，这种 …  </content></entry><entry><title>《三国史话》书摘及延伸（1）</title><url>/post/stories-of-the-three-kingdoms/p1/</url><categories><category>课外阅读</category></categories><tags><tag>读书</tag><tag>书摘</tag></tags><content type="html">  多看书，看些感兴趣的书，也别管它有没有用。
今天在看的书是《三国史话》。
吕思勉（1884年—1957年），字诚之，江苏常州人，现代著名历史学家，与陈垣、陈寅恪、钱穆并称“史学四大家”。
吕思勉，本书作者。
有些成绩低劣的，真“不知汉祖唐宗，是哪一朝皇帝”。然而问及三国史事，却很少荒谬绝伦的。
看来在那个年代，民国，三国仍是老百姓心中的主流 IP。
我们在社会上，遇见一个人、一件事，明明是好的，却误把恶意猜测他，就会觉得处处可疑。明明是坏的，却误当他好的，也会觉得他诚实可靠。历史上的事情，又何尝不是如此？
好嘛，楔子的都内容，都讲述些社会现象、人生道理，继续往下读 😀
我们现在研究历史，倒还不重在知道的、记得的事情的多少，而尤重在矫正从前观点的误谬。矫正从前观点的误谬，自然是就人所熟悉的事情，加以讲论，要容易明白些，有兴味些。
作者的观点应该是希望读者多了解些正确的观点，对于历史，我们应该“矫正从前观点的误谬”。
人谋之不藏：谋划不周 / 用人谋而思虑不周全 / 人为筹划有所欠缺。
宦字的意思，本来并非指阉割。而宦官二字，亦本非指阉割的人所做的官。
在古代，必须用兵器伤害人的身体，使之成为不能恢复的创伤，然后可以谓之刑。
《周礼》有天、地、春、夏、秋、冬六官，后世就摹仿之而设吏、户、礼、兵、刑、工六部。
这观点？就对上了个数字。
古代有所谓五刑，都是伤害人的肉体的，便是墨、劓（yì）、剕（fèi）、宫、大辟。墨是在脸上刺字；劓是割去鼻子；剕亦作膑，是截去足趾；宫，男子是阉割，女子是把她关闭起来；大辟是杀头，这是伤害人的生命的，和墨、劓、剕、宫又有不同，所以又称为大刑。
五刑。
宫刑，当隋文帝时业已废除。自此以后，做内监的人，都是自行阉割的。汉时虽还有宫刑，然据《后汉书·宦者列传》序里说，当时的宦者，亦以自行阉割进身的为多。
“十三经”：由汉朝的五经逐渐发展而来，最终形成于南宋的十三部儒家经典，分别是《诗经》、《尚书》、《周礼》、《仪礼》、《礼记》、《易经》、《左传》、《公羊传》、《榖梁传》、《论语》、《尔雅》、《孝经》、《孟子》。
宦官是后汉的乱源，这是个个人都知道的了，却不知道后汉还有一个祸源，那便是所谓外戚。
宦官与外戚。
宦官到此，算一网打尽，然而西凉将董卓，亦因应何进之召，适于此时入京。西凉的兵是强的，董卓又是个粗暴的人，敢于妄作妄为。
张陵是第一位天师了。 …  </content></entry><entry><title>《庙堂与市井》书摘及延伸（2）</title><url>/post/the-court-and-the-marketplace/p2/</url><categories><category>课外阅读</category></categories><tags><tag>读书</tag><tag>书摘</tag></tags><content type="html">  看书随手摘、内容检索延伸
现在在看的书是《庙堂与市井》。
“畏耎”指胆怯软弱，“还走”指返身而逃跑，加起来就是在战斗中临阵后退的意思。
畏耎还（xuán）走。
办案程序是“诊、丈、问”。“诊”是指验看现场痕迹，“丈”是指丈量痕迹尺寸，“问”是审问案情。
“孟尝君”是田文的谥号，他生前一般被人们称为“薛公”。
嫪毐本是文信侯吕不韦的舍人，被吕不韦献给秦王嬴政的生母帝太后。
被六国人称为“虎狼之师”的秦军，大致可以分为三类：京师军、郡县地方军和边防军。
除了秦汉二十级军功爵中最高等的彻侯、关内侯之外，其他爵位都采取降级继承原则。从三级簪袅到九级五大夫的继承人只能得到比父辈降两级的爵位，从十级左庶长到十八级大庶长的继承人一律降为八级公乘爵位。
天下未乱蜀先乱，天下已治蜀未治。
为什么？
楚国作为南方最强诸侯，跟其他六个北方诸侯有很多地域矛盾，文化差异也最大。楚人的反秦情绪高居六国榜首。
“非刘氏上所不置而王者，若无功上所不置而侯者，天下共击诛之。”
  </content></entry><entry><title>Snakemake 中 script 指令无法使用 input 指令中的值</title><url>/post/snakemake/script-directive-pitfall/</url><categories><category>后端技术</category><category>Snakemake</category></categories><tags><tag>Snakemake</tag></tags><content type="html"><![CDATA[  如题。
示例 写个 demo 示例一下。
我的 Snakefile 内容如下：
1 2 3 4 5 6 7 rule read_and_write: input: &#34;inputs/abc.log&#34; output: &#34;outputs/abcde.log&#34; script: &#34;scripts/read_file.py -f {input} {output}&#34; 运行上面的脚本，会报：
1 2 3 ... The name &#39;input&#39; is unknown in this context. Please make sure that you defined that variable. Also note that braces not used for variable access have to be escaped by repeating them, i.e. {{print $1}} ... 显示 input 不在上下文中。
问题 看了官方的文档：
https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#snakefiles-external-scripts 才知道，人家就没打算在字符串传递 input 指令的值，而是希望开发在编写的脚本使用以下方式（python）：
1 2 3 4 5 6 from snakemake.script import snakemake def do_something(data_path, out_path, threads, myparam): # python code do_something(snakemake.input[0], snakemake.output[0], snakemake.threads, snakemake.config[&#34;myparam&#34;]) 处理 所以，老老实实地用 shell 指令吧。
我个不人推荐在自定义脚本中过多的集成 snakemake 的代码，因为有时，我们希望不依赖 snakemake 环境也能正常执行。
调整后如下：
1 2 3 4 5 6 7 rule read_and_write: input: &#34;inputs/abc.log&#34; output: &#34;outputs/abcde.log&#34; shell: &#34;python scripts/read_file.py -f {input} {output}&#34;   ]]></content></entry><entry><title>《庙堂与市井》书摘及延伸（1）</title><url>/post/the-court-and-the-marketplace/p1/</url><categories><category>课外阅读</category></categories><tags><tag>读书</tag><tag>书摘</tag></tags><content type="html">  看书随手摘、内容检索延伸
现在在看的书是《庙堂与市井》。
秦国县廷设有九曹：少内、尉曹、吏曹、户曹、仓曹、库曹、司空曹、狱曹、厩。
少内：掌管财政收支、官府钱财与物资出纳的曹署，核心负责县级财政统筹与钱物保管支取（管钱） 尉曹：主管地方军务、治安巡逻、徭役征发及地方武装管理的曹署，是县级军政与治安核心机构（管兵） 吏曹：负责官吏任免、考核、铨选与人事档案管理的曹署，执掌县级官员与吏员的人事权责（管人） 户曹：主管户籍登记、人口统计、赋税征收及婚嫁分户等民政事务的曹署，核心关联民生与赋税根基（管民） 仓曹：掌管官仓储备、粮食收纳、分发（军需 / 吏禄 / 赈灾）及粮仓管理的曹署，专司粮食相关仓储事务（管粮） 库曹：主管官府器械、兵器、车马用具及各类物资仓库的曹署，与少内分工，侧重非钱财类物资仓储（管物） 司空曹：负责工程营建（城郭 / 道路 / 水利）、刑徒监管与工程徭役调配的曹署，执掌县级公共工程与刑徒劳作（管工） 狱曹：主管司法审判、案件侦办、狱政管理及律令执行的曹署，是县级核心司法机构（管法） 厩：主管官府车马饲养、调教、修缮及厩苑管理的机构（虽称厩而非曹，属同级职掌），专司官府车马相关事务（管车马） 挂冠而去：这个成语，有说话。把官帽摘下来，挂在官署的柱子 / 墙上，然后离开，多表示归隐。
放在现代，就是辞职。
有点形象的，如你离职，把工牌一摘，放在工位上，转身离开。
秦吏常见的勤杂人员有仆、养、走等类型，他们各有各的职责，也有人身兼数职。
“仆”是指仆人，全面照顾主人的日常起居。“养”是指负责做饭的杂役。“走”是负责跑腿的杂役，帮助主人传递文书或者物品。
我如果穿越到秦朝，说不定就是个“走”。
“守官”的字面意思是留守在官署的官吏，与之相对应的概念是“离官”，即依然在职但因外出、病休等原因不在官署的官吏。
自古以来，老百姓怕狗官暴虐害民，最高统治者怕官吏欺上瞒下。
官府之所以那么重视亲属是否“同居”，是因为秦律实行“同居连坐”原则，非同居的亲属依法享有不受连坐的权利。
“不同居不连坐”，还是合理的。
商君变法时在秦国推行“分异令”。分异令曰：“民有二男以上不分异者，倍其赋。”
分异就是分家，家里有两个儿子不分家的，收双倍的赋税。
有个方案是把土地分为上田、中田、下田，受上田者耕百亩，受中田者耕两百亩，受下田者耕三百亩。家家户户轮流耕作不同质量的田，三年为一个 …  </content></entry><entry><title>使用 Excel 做线性回归分析</title><url>/post/do-data-analysis-and-linear-regression-with-excel/</url><categories><category>数据分析</category><category>机器学习</category></categories><tags><tag>Excel</tag><tag>数据分析</tag><tag>线性回归</tag><tag>解决问题</tag></tags><content type="html">  起因是我在刷短视频的时候，看到了一个关于 Excel 比赛的视频，那些选手真是把 Excel 玩出了花。所以也想着，以后的工作中，尽可能使用 Excel 完成一些简单的数据分析工作。
这不今天就有那么一个任务。
背景 对接了一个文件上传的服务，需要测试文件上传速率。因为这个文件上传接口对文件大小有限制，即不能上传大文件，所以我想着能不能在小文件上多采几个样，通过预测的方法把大文件的上传给估算出来。
收集数据 数据的方法很简单，也很笨。
用 dd 命令生成 1M 到 20M 的文件，对每个文件执行 5 次上传操作。
然后，复制到 Excel 中，最终于得到的结果如下：
绘制散点图 选择 A 列和 I 列，插入散点图：
得到下图：
添加线性回归线 选中一个散点，右键，选择 Add Trendline...
在 Trendline Options 中选择如下：
linear 表示线性回归 Display Equation on chart 显示公式 Display R-squared value on chart 显示 R 方 得到：
再加一点点样式，最终结果如下：
小结 以后，有什么数据图 📊 📈 📉 都优先使用 Excel 画一下，做个验证。
  </content></entry><entry><title>图解负载均衡策略</title><url>/post/illustrated-load-balancing-strategies/</url><categories><category>后端技术</category><category>基础原理</category></categories><tags><tag>负载均衡</tag></tags><content type="html">  看了一篇微信公众号文章，里面关于“负载均衡策略”的图例还挺好，一图胜千言，所以自己也画了下，加深下理解。
策略 轮询 粘性轮询 加权轮询 哈希 最少连接 最短响应   </content></entry><entry><title>在深圳的过去</title><url>/post/life/in-the-past-of-shenzhen/</url><categories><category>生活感想</category></categories><tags><tag>想法</tag><tag>深圳</tag></tags><content type="html">  现状 我目前人在武汉，成家但没有小孩（备孕中），工作按部就班，生活亦是如此。
近期迷恋上了爬山，计划在未来几个月，爬完武汉所有的山。
工作的通勤，是地铁加步行的方式，所以我有很多独处的时间，这也让我有了思（胡思）考（乱想）。
以前没想的问题，我现在想了，可能以前也想了，但不多。
或者说，相同的事情，现在的想法已经和以前不一样了。
过去 很长一段时间，我的经历发生在深圳，这要从趟上 16 个小时的火车说起。去的那年还没有动车，所以我是从杭州上了到深圳的绿皮，当时应该是穿了江西。
到深圳的那天，是 4 月 13，是大黄接的我，天下着细雨。
大黄是我的大学同学，现在也一直在联系。
我在深圳，工作、生活，干上了 IT。
相同的事情，每天都在发生，不能说一成不变，对我产生触动的事情其实还是挺少的，也可能确实是以前想的太少了。
住处 刚来是和大黄一起住了两月，当时在惠鑫公寓，在白石龙地铁站附近。
后面又去了莲塘，住在了坳下村，认识了深圳的第一个朋友，小姚。合租，房间很小，一个月 750，现在想想，当时这条件也是真差。
之后去了盐田住集体宿舍，4 人间，在天利明园后面，原来就是从那时候和盐田结下不解之缘。
换了工作，去了福田，当时在金地花园，住得时间不长，后面因为二房东建筑违规，又搬了新住处。
新住处，是岗厦北地铁站附近的老破小，1500 还是 1600 吧，当时找房子比较急，有住处就定了。
最后，我回到了盐田，16 年到 22 年，都在盐田，后面所有的故事也都发生在盐田。
事件 在深圳，其实事件就两件，涨个工资和找个对象，其它事件都是围绕这两件展开的。
这次就主要讲讲工资吧，“对象”这事来说，我确实有点 LOW 👋👋👋
从早期的几 k 到第三份工作的 1w+，在 16 年之前，跳槽涨薪的幅度还是挺大的，后面就不行了。
搞 IT 的，工资的高低取决于专业技能，以及公司是否愿意招募。
以前觉得是 IT 是万金油，什么行业都需要，什么行业都能搞一点，所以不担心换业务。现在可能我自己也认为是这样的，但在此之后，我的另一个观点是：切换的成本要大很多，随着年纪会越来越大。
经历了第 3 份工作，我才敢觉得：自己就值 1w+，因为之前的技术有点菜，是第 3 份工作才教会了我什么是开发、怎么做开发。
起步有点晚。
这里，我要感谢 Simon 和 LP。
16 年到 22 年，我一直在同一家公司 …  </content></entry><entry><title>MySQL 联合索引（持续更新）</title><url>/post/mysql-composite-indexes-continuously-updated/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>索引</tag><tag>持续更新</tag></tags><content type="html">  Timeline 2025-12-17 新增联合索引基础知识 基础知识（2025-12-17） 联合索引，又叫多列索引，是一种可以包含多个列的索引技术，使用得当，可以提升过滤和排序执行效率。
最多可包含 16 个字段 。
创建联合索引示例如下：
1 2 3 4 5 6 7 8 9 10 11 12 -- 建表，同时创建联合索引 CREATE TABLE students ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(64) NOT NULL, gender SMALLINT DEFAULT 0, grade VARCHAR(16) NOT NULL, -- 此处 INDEX idx_name_grade (name, grade) ); -- 表建完后，新建索引 CREATE INDEX idx_name_grade ON students (name, grade); 新建唯一联合索引，则加上 UNIQUE 关键字，如：
UNIQUE INDEX idx_name_grade (name, grade) CREATE UNIQUE INDEX idx_name_grade ON students (name, grade) 重点：
应用最左匹配原则：对 (name)、(name, grade) 有效，但对 (grade, name) 无效 主流数据库优化器会对条件进行重排，所以条件顺序不影响命中索引 联合索引 (name, grade) 和 (grade, name) 不同 索引副作用：对 INSERT、UPDATE、DELETE 操作有额外开销 应业务要求的过滤逻辑创建联合索引，若业务场景下，单个字段的查询更多，则创建单个索引   </content></entry><entry><title>在 Python 镜像的基础上换 apt 源（阿里云）</title><url>/post/change-apt-source-in-dockerfile-with-python-image/</url><categories><category>后端技术</category><category>Docker</category></categories><tags><tag>工作</tag><tag>解决问题</tag><tag>Docker</tag><tag>Dockerfile</tag><tag>Python</tag><tag>apt 源</tag></tags><content type="html"><![CDATA[  介绍如何在 Dockerfile 中对基础镜像进行换源，加快软件的安装。
Python 的基础系统 官方 Python 的基础系统分成两类：
Debian：标准标签，如 3.12、3.12-slim Alpine Linux：Alpine 标签，如 3.12-alpine 本文方法适用于第 1 类。
Docker 指令 将以下指令信息复制到 Dockerfile 中，放置到 apt-get update 之前：
1 2 3 4 5 6 7 RUN rm -rf /etc/apt/sources.list* \ &amp;&amp; ls -l /etc/apt/ | grep -v sources || true RUN echo &#34;deb http://mirrors.aliyun.com/debian/ bookworm main contrib non-free non-free-firmware&#34; &gt; /etc/apt/sources.list \ &amp;&amp; echo &#34;deb http://mirrors.aliyun.com/debian/ bookworm-updates main contrib non-free non-free-firmware&#34; &gt;&gt; /etc/apt/sources.list \ &amp;&amp; echo &#34;deb http://mirrors.aliyun.com/debian-security/ bookworm-security main contrib non-free non-free-firmware&#34; &gt;&gt; /etc/apt/sources.list \ &amp;&amp; echo &#34;deb http://mirrors.aliyun.com/debian/ bookworm-backports main contrib non-free non-free-firmware&#34; &gt;&gt; /etc/apt/sources.list 第 1 个 RUN 指令：删除默认的源信息 第 2 个 RUN 指令：将阿里云的源写入到 sources.list 文件   ]]></content></entry><entry><title>3 种使用密钥文件连接 SSH 服务的场景</title><url>/post/three-ways-to-connect-ssh-server-with-the-key-file/</url><categories><category>生产力工具</category><category>SSH</category></categories><tags><tag>工作</tag><tag>解决问题</tag></tags><content type="html"><![CDATA[  SSH 服务除了可以通过用户名和密码登录之外，还可以使用密钥文件进行登录。
本文列举 3 种我使用密钥文件的场景。假设我的密钥的放在：
1 ./.ssh/xxx.pem 终端命令 ssh 在终端的场景下，直接使用 -i 参数，指定密钥文件即可。
1 $ ssh -i ~/.ssh/xxx.pem username@host VS Code 远程连接 VS Code 的 SSH 连接要使用到 Remote-SSH 插件，如果要使用密钥文件，有两个入口可以进行配置。
第一种：通过 VS Code。
第二种：直接编辑 ~/.ssh/config 文件。
在 ~/.ssh/config 文件中加入以下内容：
1 2 3 4 5 Host &lt;connection name&gt; # 自己定义一个连接名称 HostName &lt;ip or domain&gt; # 用 IP 或者域名 User &lt;username&gt; # 用户名 Port &lt;port&gt; # 端口，默认 22 IdentityFile ~/.ssh/xxx.pem # 密钥文件地址 修改完后，重启下 VS Code，即可以选择新增的连接。
FileZilla 连接 一张图解释。
小结 列举了 3 种使用 SSH 密钥的场景：
命令行 VS Code FileZilla 留个痕迹。
  ]]></content></entry><entry><title>自制力的重要性</title><url>/post/life/small-thought/</url><categories><category>生活感想</category></categories><tags><tag>想法</tag></tags><content type="html">  自制力，又叫自我控制能力，我觉得，这个能力对人很重要。
我不是一个自制力强的人，但是也见过更差的。这一类人往往很难向上突破，因为他们的大部分时间、精力，都被浪费到其它无关紧要的事情上了。
比如坐班期间，注意力会被手机吸引。“拿起手机，看个消息，回个消息，放下手机，又拿起手机”，放下拿起的间隔可以不超过 3 秒。
我自己在这方面也有很多问题要解决、困难要克服。有时候，我计划要做一件事情，中间我又会分心去干其它事情，导致我前面的事情被拖延或完成不了。
所以，我想我应该要成为一个“串行动物”，因为我无法在同一时间去处理两件复杂且困难的事情。
为了成为“串行动物”，在日常的点滴中，要留意、培养我的自制力。
  </content></entry><entry><title>详解：如何将一个大的结构化（CSV）数据导入到 MySQL</title><url>/post/how-to-load-big-csv-file-into-mysql/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>工作</tag><tag>解决问题</tag><tag>Shell</tag></tags><content type="html">  实际需求 昨天领了一个任务，把一个大文件数据导入到 MySQL，文件以 CSV 格式给出，内容是收集的 600 多万条的文献信息。
接到时，我觉得很简单，实现思路是：
（前置）部署一个 MySQL 的服务 根据 CSV 的表头信息，创建一个表 将大文件拆成多个小文件，小文件包含表头信息 遍历所有小文件，应用 LOAD DATA INFILE 语句进行导入 为了让整个过程更好追踪，还加入小文件导入日志和汇总主日志的功能。因为是一个即时的任务，并不需要考虑太多后期的扩展，所以采用 Shell 脚本 的方式实现。
但在实现的过程中，还是遇到了一些不少的问题，大概也花了 3 个小时左右。
MySQL 环境 MySQL，我用 Docker 启的，因为考虑到后面要做数据查询服务，所以按 docker-compose 的方式进行编排，内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 version: &amp;amp;#39;3.8&amp;amp;#39; services: demo_db: image: mysql:8.0 container_name: demo_db ports: - 13306:3306 volumes: - demo_mysql_data:/var/lib/mysql - ../data:/var/lib/data - ../scripts:/var/lib/scripts networks: - demo_network environment: - MYSQL_ROOT_PASSWORD=demo_20251209 - MYSQL_DATABASE=demo - TZ=Asia/Shanghai volumes: demo_mysql_data: networks: demo_network: driver: bridge docker-compose 目前还不包含应用的部分。
创建 MySQL 表 CSV 文件的表头很多，将近 90 个，所以不太可能逐一映射到数据库的字段。在这种情况下，大语言模型就派上用场了。
我比较常用的工具是豆包。
首先，我把文件前两行的内容给到豆包，它帮我说明了表头信息及对应的内容解释。
然后，又给豆包提了个要求，生成 Create 语句，内容如下：
1 2 …  </content></entry><entry><title>一些关于找工作的想法</title><url>/post/life/some-thoughts-on-job-hunting/</url><categories><category>生活感想</category></categories><tags><tag>工作</tag><tag>想法</tag></tags><content type="html">  失业 月初的时候，出于某些原因，总经理跟我说：“XX，招你进来是看在 JY 的面子上，现在 JY 要走了，公司也没有留你的必要了。”
我说：“好，没问题，正常给赔偿就行。”
得到这个结果时，其实我心里是有预期的，因为从 8 月份之后，我的工作内容不管是有意、还是无意，都在一点点地减少。也正是有预期，所以我心里是 80% 的 喜、20% 的忧。 喜的点就非常多，比如：
终于从那些不着调、不落地的事务中抽身了 再也不用看周围的人演戏了 我自己也不用演戏了 真的是受够了 有钱拿 忧的点有且只有一个“又要开始找工作了”。
同事 陆续的几天，同事们基本都已经知道我和 JY 要走了，对，干到月底就走。部分不太知情的人，会感觉到不可思议或震撼，他们可能会想“这变化也太突然、太大 了吧”。公司本身也就没几个人，前面这 10 个月，各种骚操作，导致 9 个离职或被离职。对于离职这个事情，大家可能都有点习以为常了，但我和 JY 算是公司 初创时的成员，而且和大家相处也能玩到一块去，所以也都纷纷关心起我们后续的打算。当然，他们也为自己的“不稳定”而担忧。
“公司太不稳定了”。
IT 部的同事，我走了之后，就剩 3 个人了，其中还一个是 1 个月前入职的。反正，IT 部门各角色的人员，从我加入后，就从来没有配齐过，都是脑袋一热、事 情一赶，就招个进来。“哎呀，这大模型 RAG 应用没人懂啊，要招个大模型工程师啊”，4 月就透露出大 BOSS 想搞智能体，6 月才开始搞，7 月就交作业，这能 不急？总之，就是没有规划。
项目 公司的项目不算多，且都处于研发的状态，有明确的用户群体，但没具体到客户，也就是都在联系。说是有合作关系，你要是说没有吧，那也不能那么说。但你要是 说有，那也仅限于交流，还没有发生经济上的往来。
公司那些项目上的破事，很多，而且很多都不方便说。算了，就把它们烂在肚子里吧，下个月初，这些也就和我没关系了。
赔偿 赔偿的具体事宜是人事负责，中间也发生了些分歧，好在结果是满意的。要吐糟的一点是“总经理说，你干到月底，赔偿按 n+1 给你”，然后说这个月的工资就是那 个 1。
哎。
我就说：“这个算 1 的话，我直接这个月不干就得了，那不是更利我。”
最终结果：干完、结完这个月，再给 n+1。
欣然接受。
面试 最头疼的事，还得是面试。截止目前，我应该已经投了不下百份简历，收到的 …  </content></entry><entry><title>Go 泛型函数 - 解构类型参数</title><url>/post/old/go/deconstructing-type-in-go-with-a-example/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>类型推断</tag><tag>泛型函数</tag><tag>翻译</tag></tags><content type="html">  原文地址： https://go.dev/blog/deconstructing-type-parameters 译者评论
本文通过 slices.Clone 泛型函数介绍了 Go 是如何使用类型推断完成参数类型的解构。简单来说，如果第一个类型参数是一个复合类型，则可以通过第二、第三或更多的类型参数约束复杂类型中的类型参数，而类型推断则可以通过第一个参数推断出后续类型参数的实际类型。另外本文还说明为消除歧义而引入 ~ 符号，即用于指定类型的底层类型。
slices 包函数签名 slices.Clone 函数非常简单，该函数可以克隆任意类型元素的 slice，函数签名如下：
1 2 3 func Clone[S ~[]E, E any](s S) S { return append(s[:0:0], s...) } slices.Clone 函数可以正常运行，因为向一个空容量的 slice 添加元素会在底层分配一个新的数组。我们看到，函数体内容要比函数签要短，为什么会这样？在这篇文章中，我们会解释如此设计函数签名的原因。
简单 Clone 实现 首先，我们在 slices 包之外写一个简单的泛型 Clone1 函数。我们希望函数接收一个任意元素类型的 slice，并返回一个 slice。
1 2 3 func Clone1[E any](s []E) []E { // body omitted } Clone1 泛型函数只有一个类型参数 E，且函数参数是一个类型为 E 的 slice s，并返回一个相同类型的 slice。对于了解 Go 泛型的开发者来说，函数签名直接了当，很好理解。
然而，这里隐含着一个问题。尽管 slice 命名类型在 Go 中不常见，但开发者偶尔也会使用到。
1 2 3 4 5 6 7 // MySlice 是一个包含特殊方法的 string slice type MySlice []string // String 返回 slice 拼接的结果 func (s MySlice) String() string { return strings.Join(s, &amp;amp;#34;+&amp;amp;#34;) } 现在我们想要实现一个 MySlice 拷贝再打印出里面的内容，只不过其中字符串是经过排序的。
1 2 3 4 5 func PrintSorted(ms …  </content></entry><entry><title>如何高效地使用 useRef、useMemo 和 useCallback</title><url>/post/old/react/react-hooks-useref-usememo-usecallback/</url><categories><category>前端技术</category><category>React</category></categories><tags><tag>React Hooks</tag><tag>TypeScript</tag><tag>翻译</tag></tags><content type="html">  这是一篇关于 React Hooks 的技术文章翻译，原文地址： https://dev.to/michael_osas/understanding-react-hooks-how-to-use-useref-usememo-and-usecallback-for-more-efficient-code-3ceh ，翻译不当之处请指正。
译者评价
文章主要介绍了 useRef、useMemo 和 useCallback 3 个 React Hook，读者可以通过此文了解 3 种 Hook 的使用方式、场景，但文章也存在一些缺点：
内容重复严重，如 useRef 的作用在文章前中后段中均有描述 useCallback 的示例举例不当，容易造成读者的困惑 文章的内容只适合 3 个 React Hook 的基础泛读，因为示例足够简单，所以读者读起来并不会太大的压力。
正文开始
在不编写和使用类组件的情况下，React Hooks 是允许开发者在函数组件中管理 state（组件状态）和其它 React 特性的一组方法。React Hooks 改变了开发者编写 React 组件的方式，同时也加强了组件的可复用性和可维护性。本文详细地讨论了 React 3 个内置 Hook，分别为 useRef、useMemo 和 useCallback。通过内置的 Hooks，我们可以很容易地在不同组件中复用相同的、带状态的逻辑，这也使得代码更具可维护性和易读性。
React Hooks 是一组可以在函数组件中管理组件状态、执行特定动作和访问上下方的钩子函数，包括 useState、useEffect、useRef、useMemo 和 useCallback 等。
useRef 提供了存储可变值的方法，该引用值会在组件 render 期间持续存在。useRef 通常用于访问或修改 DOM 元素的属性值，比如输入框的值（value）、容器的滚动位置（offsetLeft、offsetTop）。与 useState 不同的是，更新 useRef 的值并不会触发组件的重新渲染，相应地，可以直接通过 useRef 返回引用对象的属性值直接进行访问或修改。
useMemo 可以缓存函数的返回值，当且仅当依赖改变时，才会重新计算函数的返回值。useMemo 非常适合于计算密集的组件编写，比如组件的渲染依 …  </content></entry><entry><title>Go slog 标准包功能详细指南</title><url>/post/old/go/go-slog-package-translate/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Go 1.21</tag><tag>log/slog</tag><tag>翻译</tag></tags><content type="html"><![CDATA[  在学习 log/slog 标准包的过程中，我搜索到一篇全面讲解 log/slog 标准包的文章，感受良多，故将其翻译成中文并分享到微信公众号。
原文地址： https://betterstack.com/community/guides/logging/logging-in-go/ 正文开始
结构化日志记录是指以明确定义的格式（通常为 JSON）来产生日志记录，为程序日志提供了一定程度的可组织性和一致性，使其更易于处理。此类日志记录由 key/value 对组成，key/value 对通常包含所记录日志的相关上下文信息，例如日志记录的严重性、时间戳、源代码位置、相关标识或任何其它相关元信息。
Go 1.21 引入的 log/slog 标准包旨在提供高性能的结构化、日志级别记录的功能，本文将会聚焦于 log/slog 标准包，深入研究 Go 语言中的结构化日志记录。
在开始之前，我们会先验证下已有 log 包并指出它的局限，然后再详细介绍新的 log/slog 包中的所有重要内容。
log 标准包 在讨论结构化日志包前，我们先验证下 log 标准包，该包提供以一种简单的方式将日志消息输出到终端、文件或者任意只要实现 io.Writer 接口的类型。下面是 Go 中最基本输出日志消息的方式：
1 2 3 4 5 6 7 package main import &amp;#34;log&amp;#34; func main() { log.Println(&amp;#34;Hello from Go application!&amp;#34;) } 输出：
1 2023/03/08 11:43:09 Hello from Go application! 终端输出中包含了日志消息以及消息产生的时间戳。Println() 方法是预先配置的全局 Logger 可用方法的其中一个，它将消息输出到标准错误。全局 Logger 可用的方法如下：
1 2 3 4 5 6 7 8 log.Print() log.Printf() log.Fatal() log.Fatalf() log.Fatalln() log.Panic() log.Panicf() log.Panicln() Fatal 族和 Panic 族方法的不同之处在于：前者会在日志记录之后调用 os.Exit(1) 而后者则会调用 panic()。
通过 …  ]]></content></entry><entry><title>如何使用 Python 复制文件</title><url>/post/old/python/how-to-copy-a-file-with-python/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>翻译</tag><tag>I/O</tag><tag>Python</tag></tags><content type="html"><![CDATA[   原文 How to Copy a File With Python Python 的 shutil 模块提供了 4 种复制文件的方法，根据你的实际情况选择合适的方法。或许，本文的内容可能帮助到你。
在每天的软件开发过程中，通过程序复制文件是一项平常的工作任务。我们将学习 Python shutil 模块提供的 4 种方法来完成文件复制，包括：
shutil.copy shutil.copyfile shutil.copy2 shutil.copyfileobj shutil 模块是 Python 标准库的一部分，提供了许多高级别的文件操作方法。该模块提供了多种复制文件的方法，取决于你是否需要复制文件的元信息或权限。
本文的内容会覆盖上述所有方法，并在最后给出各方法特点的总结。
使用 shutil.copy 复制文件 shutil.copy() 方法可以复制一个不带元信息的源到目标文件或目录并返回新创建后的路径，方法声明如下：
1 shutil.copy(src, dst, *, follow_symlinks=True) 其中，src 可以是一个类路径（path-like）的对象或一个字符串。
该方法有以下特点：
保留了文件的权限信息； dst 参数可以是一个目录； 不会复制元信息； 参数不可以是 File 对象； shutil.copy 示例 1 2 3 4 5 6 7 8 9 import shutil # 复制 example.txt 并生成新文件 example_copy.txt shutil.copy(&#39;example.txt&#39;, &#39;example_copy.txt&#39;) # 复制 example.txt 到 test/ 目录下 shutil.copy(&#39;example.txt&#39;, &#39;test/&#39;) 使用 shutil.copyfile 复制文件 shutil.copyfile() 方法同样可以复制一个不带元信息的源到目标文件，方法声明如下：
1 shutil.copyfile(src, dst, *, follow_symlinks=True) 其中，src 可以是一个类路径（path-like）的对象或一个字符串。
该方法有以下特点：
不保留文件的权限信息； dst 参数不可以是目录； 不会复制元信息； 参数不可以是 File 对象； shutil.copyfile 示例 1 2 3 4 5 import shutil # 复制 source.txt 并生成新文件 destination.txt shutil.copyfile(&#39;source.txt&#39;, &#39;destination.txt&#39;) 使用 shutil.copy2 shutil.copy2() 有别于 shutil.copy()，该方法会保留文件的元信息，方法声明如下：
1 shutil.copy2(src, dst, *, follow_symlinks=True) 该方法有以下特点：
保留文件的权限信息； dst 参数可以是目录； 可以复制元信息； 参数不可以是 File 对象； shutil.copy2 示例 1 2 3 4 5 6 7 8 9 import shutil # 复制 example.txt 并生成新文件 example_copy.txt shutil.copy2(&#39;example.txt&#39;, &#39;example_copy.txt&#39;) # 复制 example.txt 到 test/ 目录下 shutil.copy2(&#39;example.txt&#39;, &#39;test/&#39;) 使用 shutil.copyfileobj 如果你需要使用 File 对象进行传参，那么你可以使用 shutil.copyfileobj() 方法。该方法会将源文件的内容复制到目标文件，同时使用 length 参数来控制复制内容的大小，方法声明如下：
1 shutil.copyfileobj(fsrc, fdst[, length]) 该方法有以下特点：
不保留文件的权限信息； dst 参数不可以是目录； 不会复制元信息； 参数可以是 File 对象； shutil.copyfileobj 示例 1 2 3 4 5 6 7 import shutil source_file = open(&#39;example.txt&#39;, &#39;rb&#39;) dest_file = open(&#39;example_copy.txt&#39;, &#39;wb&#39;) shutil.copyfileobj(source_file, dest_file) 如何选择合适的复制文件的方法 本文中我们学习了 4 种由 Python shutil 标准包提供的复制文件的方法，选择合适的方法取决于特定的使用场景，如：
是否需要复制文件权限或元信息； 是否需要复制到目录； 传参是否是 File 对象； 下表示总结了各方法的特点：
方法 保留文件权限 目标可以是目录 复制元信息 shutil.copy Y Y N shutil.copyfile N N N shutil.copy2 Y Y Y shutil.copyfileobj N N N   ]]></content></entry><entry><title>递归版本的归并排序 Go & Python 实现</title><url>/post/old/sorts/r_merge-sort/</url><categories><category>算法</category><category>实现</category></categories><tags><tag>排序算法</tag><tag>归并排序</tag><tag>递归</tag><tag>Go</tag><tag>Python</tag></tags><content type="html"><![CDATA[  递归版本的归并排序。
Go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /** * 递归版本的归并排序 */ package main import &#34;fmt&#34; func rMerge(left []int, right []int) []int { ret := make([]int, 0, len(left)+len(right)) i := 0 j := 0 for i &lt; len(left) &amp;&amp; j &lt; len(right) { if left[i] &lt; right[j] { ret = append(ret, left[i]) i++ } else { ret = append(ret, right[j]) j++ } } if i &lt; len(left) { for _, v := range left[i:] { ret = append(ret, v) } } if j &lt; len(right) { for _, v := range right[j:] { ret = append(ret, v) } } return ret } func rMergeSort(s []int) []int { if len(s) &lt;= 1 { return s } mid := len(s) / 2 left := rMergeSort(s[:mid]) right := rMergeSort(s[mid:]) return rMerge(left, right) } func main() { s1 := []int{9, 8, 6, 6, 5, 4, 3, 2, 1} fmt.Println(rMergeSort(s1)) s2 := []int{3, 1, 4, 4, 6, 5, 8} fmt.Println(rMergeSort(s2)) } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &#34;&#34;&#34; 递归版本的归并排序 &#34;&#34;&#34; from typing import List def r_merge(left: List[int], right: List[int]) -&gt; List[int]: ret = [] i = 0 j = 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: ret.append(left[i]) i += 1 else: ret.append(right[j]) j += 1 if i &lt; len(left): ret = ret + left[i:] if j &lt; len(right): ret = ret + right[j:] return ret def r_merge_sort(arr: List[int]) -&gt; List[int]: if len(arr) &lt;= 1: return arr mid = len(arr) // 2 left = r_merge_sort(arr[:mid]) right = r_merge_sort(arr[mid:]) return r_merge(left, right) if __name__ == &#39;__main__&#39;: arr1 = [9, 8, 6, 6, 5, 4, 3, 2, 1] print(r_merge_sort(arr1)) arr2 = [3, 1, 4, 4, 6, 5, 8] print(r_merge_sort(arr2))   ]]></content></entry><entry><title>PAT 乙级 1046</title><url>/post/old/pat-basic-level/1046/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/26 &#34;&#34;&#34; PAT 乙级 1046 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: n = int(input()) a = 0 b = 0 for i in range(n): tokens = list(map(int, input().split(&#39; &#39;))) if tokens[1] == tokens[3]: continue total = tokens[0] + tokens[2] if tokens[1] == total: b += 1 continue if tokens[3] == total: a += 1 continue print(a, b)   ]]></content></entry><entry><title>Linux history 命令</title><url>/post/old/linux-commands/history/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>jobs</tag></tags><content type="html"><![CDATA[  history 命令可用于浏览历史执行过的命令，该命令在 Bourne Shell 中不可用，但 Bash 和 Korn 则支持该特性。在 Bash 和 Korn 中，每一次命令的执行都被视为一次事件，并且配有相应的事件号（Event Number）。在需要的情况下，可以通过事件号将执行过的命令再次执行。
不带选项的 history 会在终端输出所有执行过的历史命令。
选项 -d 如果要删除一个历史执行命令，可在-d 选项后面可以接一个命令关联的事件号，如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 $ history 518 echo 222 519 echo 333 520 echo 444 521 echo 555 522 history 5 $ history -d 520 $ history 5 519 echo 333 520 echo 555 521 history 5 522 history -d 520 523 history 5 -c 移除所有历史命令。
1 $ history -c -w 将历史执行命令记录写入到 .bash_history 文件。
1 $ history -w 环境变量 与 history 相关的环境变量包括：
HISTSIZE：历史执行命令列表的数量 HISTFILESIZE：保存到 .bash_history 的历史执行命令数 HISTTIMEFORMAT：显示命令时的时间格式字符串 HISTCONTROL：记录控制变量 1 2 3 4 $ echo $HISTSIZE 500 $ echo $HISTFILESIZE 500 示例 限制显示的命令数
1 2 3 4 5 6 $ history 5 505 cd - 506 ls 507 expr 1 + 2 508 echo &#39;hello world&#39; 509 history 5 通过事件号执行命令
1 2 3 $ !508 echo &#39;hello world&#39; hello world 通过事件号预览命令 :p
1 2 $ !507:p expr 1 + 2 查看并执行最近一条执行过的命令
1 2 3 $ !! expr 1 + 2 3 查看并执行最近第 n 条执行过的命令
1 2 3 4 5 6 7 8 9 $ history 5 523 history 5 524 echo HISTSIZE 525 echo $HISTSIZE 526 echo $HISTFILESIZE 527 history 5 $ !-3 echo $HISTSIZE 500 执行指定开头的历史命令
1 2 3 $ !exp expr 1 + 2 3 运行一条命令，但不对其进行记录
1 $ echo &#34;hello world&#34;; history -d $(history 1) 在命令前输出执行的时间
1 2 3 $ HISTTIMEFORMAT=&#34;%c &#34; $ history 1 537 Sat Mar 25 22:12:14 2023 history 1 对于重复连续执行的命令只记录一次
1 2 3 4 5 6 7 8 9 10 11 12 13 $ HISTCONTROL=&#34;ignoredups&#34; $ pwd /Users/a2htray/workspace/a2htray.github.io $ pwd /Users/a2htray/workspace/a2htray.github.io $ pwd /Users/a2htray/workspace/a2htray.github.io $ history 5 537 Sat Mar 25 22:12:14 2023 history 1 538 Sat Mar 25 22:14:16 2023 echo $HISTCONTROL 539 Sat Mar 25 22:16:42 2023 HISTCONTROL=&#34;ignoredups&#34; 540 Sat Mar 25 22:16:49 2023 pwd 541 Sat Mar 25 22:16:54 2023 history 5 参考 history command in Linux with Examples How to Use the Linux history Command Bash History Command Examples In Linux   ]]></content></entry><entry><title>Linux Shell：文件测试比较操作符</title><url>/post/old/linux-shell/file-test-operators/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>Test Operators</tag></tags><content type="html"><![CDATA[  在 Shell 中，我们经常需要与文件打交道，所以了解文件测试操作符十分有必要。本文罗列了文件测试操作符并逐一给出示例，其中测试表达式的形式以 [[]] 给出。
文件测试操作符 文件测试操作符如下表：
操作符 描述 示例 -b file 测试给定文件是否是块设备 [[ -b $file ]] -c file 测试给定文件是否是字符文件 [[ -c $file ]] -d file 测试给定文件是否是目录 [[ -d $file ]] -f file 测试给定文件是否是文件 [[ -f $file ]] -g file 测试给定文件是否设置了 SGID 比特位 [[ -g $file ]] -k file 测试给定文件是否设置了黏滞位 [[ -k $file ]] -p file 测试给定文件是否是一个命名管道 [[ -p $file ]] -u file 测试给定文件是否设置了 SUID 比特位 [[ -u $file ]] -r file 测试给定文件是否可读 [[ -r $file ]] -w file 测试给定文件是否可写 [[ -w $file ]] -x file 测试给定文件是否可执行 [[ -x $file ]] -s file 测试给定文件的大小是否大于 0 [[ -s $file ]] -L file 测试给定文件是否是一个链接文件 [[ -L $file ]] 示例 -b 测试给定文件是否是块设备
1 2 3 4 $ block_file=my_block_file $ mknod $block_file b 1 2 $ [[ -b $block_file ]] &amp;&amp; echo &#34;$block_file is a block special file&#34; my_block_file is a block special file -c 测试给定文件是否是字符文件
1 2 3 4 $ character_file=my_character_file $ mknod $character_file c 1 2 $ [[ -c $character_file ]] &amp;&amp; echo &#34;$character_file is a character special file&#34; my_character_file is a character special file -d 测试给定文件是否是目录
1 2 $ [[ -d /etc ]] &amp;&amp; echo &#34;/etc is a directory&#34; /etc is a directory -f 测试给定文件是否是文件
1 2 $ [[ -f /etc/passwd ]] &amp;&amp; echo &#34;/etc/passwd is a file&#34; /etc/passwd is a file -g 测试给定文件是否设置了 SGID 比特位
1 2 3 4 $ mkdir SGID_test $ chmod g+s SGID_test $ [[ -g ./SGID_test ]] &amp;&amp; echo &#34;./SGID_test has been set SGID bit&#34; ./SGID_test has been set SGID bit -k 测试给定文件是否设置了黏滞位
1 2 3 4 $ mkdir sticky_file $ chmod +t sticky_file $ [[ -k ./sticky_file ]] &amp;&amp; echo &#34;./sticky_file has been set sticky bit&#34; ./sticky_file has been set sticky bit -p 测试给定文件是否是一个命名管道
1 2 3 $ mknod named_pipe p $ [[ -p ./named_pipe ]] &amp;&amp; echo &#34;./named_pipe is a named pipe&#34; ./named_pipe is a named pipe -u 测试给定文件是否设置了 SUID 比特位
1 2 3 4 $ touch SUID_test $ chmod u+s SUID_test $ [[ -u ./SUID_test ]] &amp;&amp; echo &#34;./SUID_test has been set SUID bit&#34; ./SUID_test has been set SUID bit -r 测试给定文件是否可读
1 2 3 4 $ touch readable_file $ chmod u+r readable_file $ [[ -r ./readable_file ]] &amp;&amp; echo &#34;./readable_file is a readable file&#34; ./readable_file is a readable file -w 测试给定文件是否可写
1 2 3 4 $ touch writable_file $ chmod u+w writable_file $ [[ -w ./writable_file ]] &amp;&amp; echo &#34;./writable_file is a writable file&#34; ./writable_file is a writable file -x 测试给定文件是否可执行
1 2 3 4 $ touch executable_file $ chmod u+x executable_file $ [[ -x ./executable_file ]] &amp;&amp; echo &#34;./executable_file ia an executable file&#34; ./executable_file ia an executable file -s 测试给定文件的大小是否大于 0
1 2 3 $ echo &#34;content&#34; &gt; test_file $ [[ -s ./test_file ]] &amp;&amp; echo &#34;the size of ./test_file is larger than 0&#34; the size of ./test_file is larger than 0 -L 测试给定文件是否是一个链接文件
1 2 3 4 $ touch origin_file $ ln -s origin_file linked_file $ [[ -L ./linked_file ]] &amp;&amp; echo &#34;./linked_file is a linked file&#34; ./linked_file is a linked file 参考 Unix / Linux - Shell File Test Operators Example mknod SUID、SGID 详解   ]]></content></entry><entry><title>PAT 乙级 1044</title><url>/post/old/pat-basic-level/1044/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1044 &#34;&#34;&#34; mars_digits = [ &#39;tret&#39;, &#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;may&#39;, &#39;jun&#39;, &#39;jly&#39;, &#39;aug&#39;, &#39;sep&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;, ] mars_carries = [ &#39;tam&#39;, &#39;hel&#39;, &#39;maa&#39;, &#39;huh&#39;, &#39;tou&#39;, &#39;kes&#39;, &#39;hei&#39;, &#39;elo&#39;, &#39;syy&#39;, &#39;lok&#39;, &#39;mer&#39;, &#39;jou&#39;, ] def is_earth(s: str): return s.isdigit() def is_mars(s: str): return not is_earth(s) def to_earth(s: str): tokens = s.split(&#39; &#39;) if len(tokens) == 1: if tokens[0] in mars_digits: return mars_digits.index(tokens[0]) if tokens[0] in mars_carries: return (mars_carries.index(tokens[0]) + 1) * 13 else: return (mars_carries.index(tokens[0]) + 1) * 13 + mars_digits.index(tokens[1]) def to_mars(s: str): num = int(s) if num &lt; 13: return mars_digits[num] if num % 13 == 0: return f&#39;{mars_carries[num // 13 - 1]}&#39; else: return f&#39;{mars_carries[num // 13 - 1]} {mars_digits[num % 13]}&#39; if __name__ == &#39;__main__&#39;: n = int(input()) lines = [] for _ in range(n): line = input() lines.append(line) for line in lines: if is_earth(line): print(to_mars(line)) else: print(to_earth(line))   ]]></content></entry><entry><title>PAT 乙级 1043</title><url>/post/old/pat-basic-level/1043/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1043 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: line = input() nums = [0] * 6 chars = [&#39;P&#39;, &#39;A&#39;, &#39;T&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39;] for c in line: if c == &#39;P&#39;: nums[0] += 1 if c == &#39;A&#39;: nums[1] += 1 if c == &#39;T&#39;: nums[2] += 1 if c == &#39;e&#39;: nums[3] += 1 if c == &#39;s&#39;: nums[4] += 1 if c == &#39;t&#39;: nums[5] += 1 total = sum(nums) while total &gt; 0: for i in range(6): if nums[i] != 0: print(chars[i], end=&#39;&#39;) nums[i] -= 1 total -= 1 print(&#39;&#39;)   ]]></content></entry><entry><title>PAT 乙级 1042</title><url>/post/old/pat-basic-level/1042/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1042 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: line = input() stat = [0] * 26 for c in line: if ord(&#39;a&#39;) &lt;= ord(c) &lt;= ord(&#39;z&#39;): stat[ord(c) - ord(&#39;a&#39;)] += 1 if ord(&#39;A&#39;) &lt;= ord(c) &lt;= ord(&#39;Z&#39;): stat[ord(c) - ord(&#39;A&#39;)] += 1 max_num = max(stat) print(chr(ord(&#39;a&#39;) + stat.index(max_num)), max_num)   ]]></content></entry><entry><title>PAT 乙级 1041</title><url>/post/old/pat-basic-level/1041/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1041 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: n = int(input()) student_dict = {} for _ in range(n): tokens = input().split(&#39; &#39;) student_dict[tokens[1]] = [tokens[0], tokens[2]] _ = input() nums = input().split(&#39; &#39;) for num in nums: print(&#39; &#39;.join(student_dict[num]))   ]]></content></entry><entry><title>PAT 乙级 1040</title><url>/post/old/pat-basic-level/1040/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1039 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: line = input() num_t = 0 num_at = 0 num_pat = 0 for i in range(len(line) - 1, -1, -1): if line[i] == &#39;T&#39;: num_t += 1 if num_t != 0 and line[i] == &#39;A&#39;: num_at += num_t if num_at != 0 and line[i] == &#39;P&#39;: num_pat += num_at print(num_pat % 1000000007)   ]]></content></entry><entry><title>PAT 乙级 1039</title><url>/post/old/pat-basic-level/1039/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/25 &#34;&#34;&#34; PAT 乙级 1039 &#34;&#34;&#34; def color_stat(s): stat = {} for c in s: if c not in stat: stat[c] = 0 stat[c] = stat[c] + 1 return stat if __name__ == &#39;__main__&#39;: line1 = input() line2 = input() stat1 = color_stat(line1) stat2 = color_stat(line2) absent = 0 for color, num in stat2.items(): if color in stat1: if stat1[color] &gt;= num: stat1[color] -= num else: absent += num - stat1[color] else: absent += num if absent == 0: print(&#39;Yes&#39;, sum(stat1.values())) else: print(&#39;No&#39;, absent)   ]]></content></entry><entry><title>Someone could be eavesdropping on you right now (man-in-the-middle attack)!</title><url>/post/old/git/someone-could-be-eavesdropping-on-you-right-now/</url><categories><category>生产力工具</category><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html">  今天在 git pull 时报了如下的错：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx. Please contact your system administrator. Add correct host key in /Users/a2htray/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/a2htray/.ssh/known_hosts:2 Host key for github.com has changed and you have requested strict checking. Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 导致无法拉取远程仓库的代码。
通过网上的教程，只要删除 /Users/a2htray/.ssh/known_hosts 即可。
1 $ rm -f /Users/a2htray/.ssh/known_hosts   </content></entry><entry><title>PAT 乙级 1038</title><url>/post/old/pat-basic-level/1038/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/13 &#34;&#34;&#34; PAT 乙级 1038 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: n = int(input()) scores = {} for score in input().split(&#39; &#39;): if score not in scores: scores[score] = 0 scores[score] += 1 counts = [] for score in input().split(&#39; &#39;)[1:]: if score in scores: counts.append(scores[score]) else: counts.append(&#39;0&#39;) print(&#39; &#39;.join(map(str, counts)))   ]]></content></entry><entry><title>PAT 乙级 1037</title><url>/post/old/pat-basic-level/1037/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/13 &#34;&#34;&#34; PAT 乙级 1037 &#34;&#34;&#34; def get_gsk(s): return list(map(int, s.split(&#39;.&#39;))) if __name__ == &#39;__main__&#39;: gsk1, gsk2 = map(get_gsk, input().split(&#39; &#39;)) price1 = gsk1[0] * 17 * 29 + gsk1[1] * 29 + gsk1[2] price2 = gsk2[0] * 17 * 29 + gsk2[1] * 29 + gsk2[2] if price2 &gt;= price1: flag = &#39;&#39; diff = price2 - price1 else: flag = &#39;-&#39; diff = price1 - price2 print(f&#39;{flag}{diff // 29 // 17}.{diff // 29 % 17}.{diff % 29}&#39;)   ]]></content></entry><entry><title>PAT 乙级 1036</title><url>/post/old/pat-basic-level/1036/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/13 &#34;&#34;&#34; PAT 乙级 1036 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: tokens = input().split(&#39; &#39;) n = int(tokens[0]) c = tokens[1] row_num = str(1.0 * n / 2) if &#39;.&#39; in row_num: num, fraction = row_num.split(&#39;.&#39;) if 5 &lt;= int(fraction[0]) &lt;= 9: num = int(num) + 1 else: num = int(num) else: num = int(row_num) num = int(num) for i in range(num): if i == 0 or i == num - 1: print(&#39;&#39;.join([c] * n)) continue print(&#39;&#39;.join([c] + [&#39; &#39;] * (n - 2) + [c]))   ]]></content></entry><entry><title>PAT 乙级 1033</title><url>/post/old/pat-basic-level/1033/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/13 &#34;&#34;&#34; PAT 乙级 1033 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: bad_keys = input() shift_bad = &#39;+&#39; in bad_keys for v in input(): if v in bad_keys or v.upper() in bad_keys: continue if shift_bad and ord(&#39;A&#39;) &lt;= ord(v) &lt;= ord(&#39;Z&#39;): continue print(v, end=&#39;&#39;)   ]]></content></entry><entry><title>Bash：单括号与双括号的区别</title><url>/post/old/linux-shell/single-and-double-brackets/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>Test Operators</tag><tag>翻译</tag></tags><content type="html"><![CDATA[   原文：Differences Between Single and Double Brackets in Bash 概述 当我们在 Bash 中做变量比较时，通常可以交换地使用单括号 [] 和双括号 [[]]。比如，我们可以使用表达式 [ 3 -eq 3 ] 或 [[ 3 -eq 3 ]] 来比较 3 是否等于 3。两个表达式都会执行成功，那两者的区别是什么呢？
在本文中，我们会讨论单括号和双括号之间的一些区别。
主要区别 在本节中，我们会讨论单括号和双括号之间的主要区别。
单括号 在 Unix 和 Linux 中，[ 是用于执行表达式的内置命令，我们可以使用 type 命令进行验证：
1 2 $ type [ [ is a shell builtin [ 是 test 内置命令的替代，两者可以交换使用：
1 2 3 4 $ [ 3 -eq 3 ] &amp;amp;&amp;amp; echo &amp;#34;Numbers are equal&amp;#34; Numbers are equal $ test 3 -eq 3 &amp;amp;&amp;amp; echo &amp;#34;Numbers are equal&amp;#34; Numbers are equal [ 和 test 的唯一区别在于：使用 [ 时，需要以 ] 结尾，并且括号前后需要包含空格。
双括号 [[]] 是由 Korn Shell 第一次引入，其增强了 [] 在脚本中做比较、测试的功能，我们可以认为它是 [] 的增强版。
在 Bash 和 zsh 中，我们可以使用 [[]] 的方式，但脚本可能不向后兼容 POSIX。
[[ 是 shell 的一个关键字，让我们再次使用 type 命令进行验证：
1 2 $ type [[ [[ is a shell keyword 其它区别 在本节中，我们会讨论单括号和双括号之间的其它区别。
比较操作符 在 [[]] 中可以使用比较操作符，如 &amp;gt;、&amp;lt; 等，如下：
1 2 $ [[ 1 &amp;lt; 2 ]] &amp;amp;&amp;amp; echo &amp;#34;1 is less than 2&amp;#34; 1 is less than 2 上述命令中，我们使用 &amp;lt; 符号来检查 1 是否小于 2，命令是可以运行。但如果使用 [] 时，命令会报错：
1 2 $ [ 1 &amp;lt; 2 ] &amp;amp;&amp;amp; …  ]]></content></entry><entry><title>PAT 乙级 1031</title><url>/post/old/pat-basic-level/1031/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/12 &#34;&#34;&#34; PAT 乙级 1031 &#34;&#34;&#34; weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] m = [&#39;1&#39;, &#39;0&#39;, &#39;X&#39;, &#39;9&#39;, &#39;8&#39;, &#39;7&#39;, &#39;6&#39;, &#39;5&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;] def weight_sum(digits): total = 0 for i, digit in enumerate(digits): total += digit * weights[i] return total if __name__ == &#39;__main__&#39;: n = int(input()) not_passed = [] for _ in range(n): line = input() if len(line) != 18: not_passed.append(line) continue all_digit = True for c in line[:17]: if not c.isdigit(): all_digit = False if not all_digit: not_passed.append(line) continue ws = weight_sum(list(map(int, line[:17]))) z = ws % 11 if m[z] != line[17]: not_passed.append(line) if len(not_passed) == 0: print(&#39;All passed&#39;) else: for item in not_passed: print(item)   ]]></content></entry><entry><title>PAT 乙级 1029</title><url>/post/old/pat-basic-level/1029/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/12 &#34;&#34;&#34; PAT 乙级 1029 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: statement1 = input() statement2 = input() got_dict = {} statement1 = statement1.upper() statement2 = statement2.upper() for c in statement1: if c not in got_dict: if c not in statement2: got_dict[c] = True print(c, end=&#39;&#39;)   ]]></content></entry><entry><title>Linux jobs 命令</title><url>/post/old/linux-commands/jobs/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>jobs</tag><tag>fg</tag><tag>bg</tag></tags><content type="html"><![CDATA[  jobs 命令主要用于显示系统中的任务列表及运行状态。在 Linux 中，每一个 job 都有一个唯一 ID，系统管理员通过任务 ID 对任务进行管理，可使其在前后或后台运行。通常任务和进程是等价的，只在于说侧重不同。即任务之于用户，相应地，进程之于系统。
语法及选项 jobs 命令的语法如下：
1 jobs [-lnprs] -l：在标准信息显示的基础上添加任务 ID 信息 -n：只显示与上一次显示状态不同的任务 -p：只显示任务 ID -r：显示运行中的任务 -s：显示暂停中的任务 以 sleep 命令为例：
1 2 3 4 5 6 7 8 $ sleep 100 &amp; [1] 803 $ jobs [1]+ Running sleep 100 &amp; $ jobs -l [1]+ 803 Running sleep 100 &amp; $ jobs -lr [1]+ 803 Running sleep 100 &amp; fg 和 bg fg（foreground）可以将一个任务转置前台运行，相反地，bg（background）则可以将一个任务转置后台运行。两个命令的语法分别如下：
1 2 fg [JOB_SPEC] bg [JOB_SPEC] JOB_SPEC 可以是以下形式：
%n：n 是任务 ID %abc：以 abc 开头命令启动的任务 %?abc：以包含 abc 命令启动的任务 %：特指上一个任务 首先，编写一个 shell 脚本，实现的是每隔离 1s 打印一次 hello world。然后，后台执行该脚本并使用 fg 和 bg 进行管理。最后，使用 ctrl+c 结束任务的执行。
1 2 3 4 5 6 7 8 # file: abc.sh #!/bin/bash while : do sleep 1 echo &#34;hello world&#34; done 步骤一：后台运行 abc.sh
1 2 3 4 $ ./abc.sh &amp; [1] 508 $ jobs [1]+ Running ./abc.sh &gt; abc.log &amp; 步骤二：fg 命令使其在前台运行
1 2 $ fg %1 ./abc.sh &gt; abc.log 步骤三：Ctrl+Z 暂停运行
1 ^Z 步骤四：bg 命令使其在后台运行
1 2 $ bg %1 [1]+ ./abc.sh &gt; abc.log &amp; 步骤五：Ctrl+C 结束运行
1 2 3 4 $ fg %1 ./abc.sh &gt; abc.log ^C $ jobs   ]]></content></entry><entry><title>PAT 乙级 1026</title><url>/post/old/pat-basic-level/1026/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/9 &#34;&#34;&#34; PAT 乙级 1026 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: start_clock, end_clock = map(int, input().split(&#39; &#39;)) duration = 1.0 * (end_clock - start_clock) / 100 h = int(duration // 3600) m = int(duration % 3600 // 60) s = str(duration % 3600 % 60) tokens = s.split(&#39;.&#39;) add = 1 if int(tokens[1][0]) &gt;= 5 else 0 s = int(tokens[0]) + add print(&#39;%02d:%02d:%02d&#39; % (h, m, s))   ]]></content></entry><entry><title>Go flag 自定义选项类型</title><url>/post/old/go-packages/flag-user-defined-flag-type/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>go</tag><tag>flags</tag></tags><content type="html"><![CDATA[  flag 包定义了一系列函数，可用于定义命令行参数，支持的参数类型如下：
string：flag.StringVar 函数 bool：flag.BoolVar 函数 time.Duration: flag.DurationVar 函数 int: flag.IntVar 函数 uint: flag.UintVar 函数 float64: flag.Float64Var 函数 int64: flag.Int64Var 函数 uint64: flag.Uint64Var 函数 各函数声明见下图：
直接调用上述函数的话，会给默认的 CommandLine 定义一个命令行选项，内部则是调用了 FlagSet.Var 函数，如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // StringVar defines a string flag with specified name, default value, and usage string. // The argument p points to a string variable in which to store the value of the flag. func StringVar(p *string, name string, value string, usage string) { CommandLine.Var(newStringValue(value, p), name, usage) } // Var defines a flag with the specified name and usage string. The type and // value of the flag are represented by the first argument, of type Value, which // typically holds a user-defined implementation of Value. For instance, the // caller could create a flag that turns a comma-separated string into a slice // of strings by giving the slice the methods of Value; in particular, Set would // decompose the comma-separated string into the slice. func (f *FlagSet) Var(value Value, name string, usage string) { // ... } FlagSet.Var 函数的第一个参数类型为 Value，所以自定义选项类型需要从 Value 接口入手。
代码 Value 接口的声明如下（★ ★ ★ ★ ★）：
1 2 3 4 type Value interface { String() string Set(string) error } 自定义的选项类型要实现 Value 接口，完整代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // user_defined_flag_type.go package main import ( &#34;errors&#34; &#34;flag&#34; &#34;fmt&#34; &#34;strconv&#34; &#34;strings&#34; ) // Gender 性别 type Gender int const ( // genderMale 男性 genderMale Gender = iota // genderFemale 女性 genderFemale ) var ( // ErrUserParse 无法解析用户信息 ErrUserParse = errors.New(&#34;parse user error&#34;) ) // User 自定义选项结构 // 支持以命令行选项的方式实例化，使用 : 作为分隔，选项值形如：`xiaoming:18:0` type User struct { Name string age int gender Gender } func (u *User) String() string { return &#34;user&#34; } // Set 解析传递来的字符串，实例化 User 结构 func (u *User) Set(s string) error { tokens := strings.Split(s, &#34;:&#34;) if len(tokens) != 3 { return ErrUserParse } u.Name = tokens[0] v, err := strconv.ParseInt(tokens[1], 0, strconv.IntSize) if err != nil { return err } u.age = int(v) v, err = strconv.ParseInt(tokens[2], 0, strconv.IntSize) if err != nil { return err } gender := Gender(v) if !(gender == genderMale || gender == genderFemale) { return ErrUserParse } u.gender = gender return nil } func main() { var user = User{} flag.Var(&amp;user, &#34;user&#34;, &#34;user information&#34;) flag.Parse() fmt.Printf(&#34;name: %s\n&#34;, user.Name) fmt.Printf(&#34;age: %d\n&#34;, user.age) fmt.Printf(&#34;gender: %d\n&#34;, user.gender) } 运行 正常解析
1 2 3 4 $ go run user_defined_flag_type.go --user=xiaoming:18:0 name: xiaoming age: 18 gender: 0 user 解析失败：信息不足
1 2 $ go run user_defined_flag_type.go --user=xiaoming:18 invalid value &#34;xiaoming:18&#34; for flag -user: parse user error user 解析失败：性别不符
1 2 $ go run user_defined_flag_type.go --user=xiaoming:18:2 invalid value &#34;xiaoming:18:2&#34; for flag -user: parse user error 小结 如果要实现自定义的选项类型，则该选项需要实现 flag.Value 接口，关键在于 Set(s string) error 如何实现字符串的解析并将信息转换成类型实例信息。 代码 。
  ]]></content></entry><entry><title>Go flag 支持选项简写</title><url>/post/old/go-packages/flag-shorthand/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Go</tag><tag>flags</tag></tags><content type="html"><![CDATA[  在命令行工具的开发过程中，我们常常需要设置一个同时支持短名称和长名称的选项，如 -d 等价于 --debug、-p 等价于 --password。在使用 Go flag 包的情况下，该需求的实现相当简单，只需要定义两个不同的 flag 指向同一个变量即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // flag_shorthand.go package main import ( &#34;flag&#34; &#34;fmt&#34; ) func main() { var debug bool var password string debugUsage := &#34;run in debug mode&#34; passwordUsage := &#34;type password&#34; flag.BoolVar(&amp;debug, &#34;d&#34;, false, debugUsage) flag.BoolVar(&amp;debug, &#34;debug&#34;, false, debugUsage) flag.StringVar(&amp;password, &#34;p&#34;, &#34;&#34;, passwordUsage) flag.StringVar(&amp;password, &#34;password&#34;, &#34;&#34;, passwordUsage) flag.Parse() fmt.Printf(&#34;debug: %v\n&#34;, debug) fmt.Printf(&#34;password: %s\n&#34;, password) } 运行 不带任何参数
debug 和 password 都使用默认值，分别为 false 和 &quot;&quot;。
1 2 3 $ go run flag_shorthand.go debug: false password: 使用短名称
1 2 3 $ go run flag_shorthand.go -d -p 12345 debug: true password: 12345 使用长名称
1 2 3 $ go run flag_shorthand.go --debug --password=12345 debug: true password: 12345 小结 学习并掌握了长短名称选项的使用方式， 代码 。
  ]]></content></entry><entry><title>PAT 乙级 1024</title><url>/post/old/pat-basic-level/1024/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/8 &#34;&#34;&#34; PAT 乙级 1024 &#34;&#34;&#34; from typing import List class SciNumber: def __init__(self, s: str): self.sign = &#39;-&#39; if s[0] == &#39;-&#39; else &#39;&#39; nums, exp = s[1:].split(&#39;E&#39;) self.nums = [v for v in nums] self.left_move = exp[0] == &#39;-&#39; self.exp = int(exp[1:]) # print(self.sign, self.nums, self.left_move, self.exp) def to_number(self) -&gt; List[str]: if self.left_move: ret = [&#39;0&#39;] * self.exp + self.nums del ret[ret.index(&#39;.&#39;)] return ret[0:1] + [&#39;.&#39;] + ret[1:] else: n = len(self.nums[2:]) if self.exp &gt;= n: ret = self.nums + [&#39;0&#39;] * (self.exp - n) del ret[1] else: ret = self.nums for i in range(1, 1 + self.exp): ret[i], ret[i + 1] = ret[i + 1], ret[i] if ret[0] == &#39;0&#39;: ret = ret[1:] return ret if __name__ == &#39;__main__&#39;: sci_number = SciNumber(input()) print(sci_number.sign + &#39;&#39;.join(sci_number.to_number()))   ]]></content></entry><entry><title>PAT 乙级 1023</title><url>/post/old/pat-basic-level/1023/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/8 &#34;&#34;&#34; PAT 乙级 1023 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: digits = [] for i, digit in enumerate(map(int, input().split(&#39; &#39;))): digits += [i] * digit digits.sort() if digits[0] != 0: print(&#39;&#39;.join(map(str, digits))) exit(0) for i, v in enumerate(digits): if v != 0: digits[0], digits[i] = digits[i], digits[0] break print(&#39;&#39;.join(map(str, digits)))   ]]></content></entry><entry><title>PAT 乙级 1021</title><url>/post/old/pat-basic-level/1021/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/7 &#34;&#34;&#34; PAT 乙级 1021 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: counts = [0] * 10 for s in input(): counts[int(s)] += 1 for i, count in enumerate(counts): if count != 0: print(&#39;%d:%d&#39; % (i, count))   ]]></content></entry><entry><title>PAT 乙级 1020</title><url>/post/old/pat-basic-level/1020/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/6 &#34;&#34;&#34; PAT 乙级 1020 &#34;&#34;&#34; from functools import cmp_to_key class MoonCake: def __init__(self, num, total_price): self.num = num self.total_price = total_price self.unit_price = 1.0 * self.total_price / self.num def cmp(mooncake1, mooncake2): return -1 if mooncake1.unit_price &gt; mooncake2.unit_price else 1 if __name__ == &#39;__main__&#39;: n_class, max_requirement = map(int, input().split(&#39; &#39;)) mooncakes = [] for item in zip(map(float, input().split(&#39; &#39;)), map(float, input().split(&#39; &#39;))): if item[0] == 0 or item[1] == 0: continue mooncakes.append(MoonCake(item[0], item[1])) mooncakes = sorted(mooncakes, key=cmp_to_key(cmp)) sale_price = 0.0 for i in range(n_class): if max_requirement &gt;= mooncakes[i].num: sale_price += mooncakes[i].total_price max_requirement = max_requirement - mooncakes[i].num else: sale_price += max_requirement * mooncakes[i].unit_price max_requirement = 0 break print(&#39;%.2f&#39; % sale_price)   ]]></content></entry><entry><title>PAT 乙级 1019</title><url>/post/old/pat-basic-level/1019/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/6 &#34;&#34;&#34; PAT 乙级 1019 &#34;&#34;&#34; def get_sorted_nums(num_str): dn = 4 - len(num_str) for _ in range(dn): num_str = &#39;0&#39; + num_str nums = list(map(int, num_str)) nums.sort() return 1 * nums[0] + 10 * nums[1] + 100 * nums[2] + 1000 * nums[3], \ 1 * nums[3] + 10 * nums[2] + 100 * nums[1] + 1000 * nums[0] num_str = input() num1, num2 = get_sorted_nums(num_str) if num1 == num2: print(f&#39;{num1:04d} - {num2:04d} = 0000&#39;) exit(0) while num1 - num2 != 6174: diff = num1 - num2 print(f&#39;{num1:04d} - {num2:04d} = {diff:04d}&#39;) num1, num2 = get_sorted_nums(str(diff)) diff = num1 - num2 print(f&#39;{num1:04d} - {num2:04d} = {diff:04d}&#39;)   ]]></content></entry><entry><title>PAT 乙级 1018</title><url>/post/old/pat-basic-level/1018/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/6 &#34;&#34;&#34; PAT 乙级 1018 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: n = int(input()) first = [0, 0, 0] second = [0, 0, 0] first_win = 0 second_win = 0 alphabet = [&#39;B&#39;, &#39;C&#39;, &#39;J&#39;] for _ in range(n): p1, p2 = input().split() if p1 == &#39;C&#39; and p2 == &#39;J&#39;: first[1] += 1 first_win += 1 elif p1 == &#39;C&#39; and p2 == &#39;B&#39;: second[0] += 1 second_win += 1 elif p1 == &#39;B&#39; and p2 == &#39;J&#39;: second[2] += 1 second_win += 1 elif p1 == &#39;B&#39; and p2 == &#39;C&#39;: first[0] += 1 first_win += 1 elif p1 == &#39;J&#39; and p2 == &#39;B&#39;: first[2] += 1 first_win += 1 elif p1 == &#39;J&#39; and p2 == &#39;C&#39;: second[1] += 1 second_win += 1 print(first_win, n - first_win - second_win, second_win) print(second_win, n - first_win - second_win, first_win) print(alphabet[first.index(max(first))], alphabet[second.index(max(second))])   ]]></content></entry><entry><title>PAT 乙级 1022</title><url>/post/old/pat-basic-level/1022/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/8 &#34;&#34;&#34; PAT 乙级 1022 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: num1, num2, base = map(int, input().split(&#39; &#39;)) total = num1 + num2 if total == 0: print(0) exit(0) res = [] while total &gt;= 1: res = [total % base] + res total = total // base if res[0] == 0: res = res[1:] print(&#39;&#39;.join(map(str, res)))   ]]></content></entry><entry><title>PAT 乙级 1013</title><url>/post/old/pat-basic-level/1013/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/3 &#34;&#34;&#34; PAT 乙级 1013 &#34;&#34;&#34; import math def is_prime(num): for i in range(2, int(math.sqrt(num)) + 1): if num % i == 0: return False return True if __name__ == &#39;__main__&#39;: nums_str = input().split(&#39; &#39;) m, n = int(nums_str[0]), int(nums_str[1]) prime_nums = [0] * n i = 0 num = 2 while i != n: if is_prime(num): prime_nums[i] = num i += 1 num += 1 output_nums = prime_nums[m - 1:n] for i in range(0, len(output_nums), 10): print(&#39; &#39;.join([str(v) for v in output_nums[i:i + 10]]))   ]]></content></entry><entry><title>PAT 乙级 1009</title><url>/post/old/pat-basic-level/1009/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/3 &#34;&#34;&#34; PAT 乙级 1009 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: statement = input().split(&#39; &#39;) statement.reverse() print(&#39; &#39;.join(statement))   ]]></content></entry><entry><title>PAT 乙级 1007</title><url>/post/old/pat-basic-level/1007/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/3 &#34;&#34;&#34; PAT 乙级 1007 &#34;&#34;&#34; import math def is_prime(n): prime = True for i in range(3, int(math.sqrt(n)) + 1): if n % i == 0: prime = False break return prime if __name__ == &#39;__main__&#39;: nums = [n for n in range(3, int(input()) + 1)] nums = [n for n in nums if n % 2 != 0] nums = list(filter(is_prime, nums)) if len(nums) &lt;= 1: print(0) exit(0) count = 0 i = 0 j = 1 while j != len(nums): if nums[j] - nums[i] == 2: count += 1 i += 1 j += 1 print(count)   ]]></content></entry><entry><title>PAT 乙级 1006</title><url>/post/old/pat-basic-level/1006/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/3 &#34;&#34;&#34; PAT 乙级 1006 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: chars = [*input()] chars.reverse() tail = [] for i in range(1, int(chars[0]) + 1): tail.append(str(i)) bs_list = [[], []] for i, char in enumerate(chars[1:]): if i == 0: bs_list[0] = [&#39;S&#39;] * int(char) else: bs_list[1] = [&#39;B&#39;] * int(char) print(&#39;&#39;.join(bs_list[1] + bs_list[0] + tail))   ]]></content></entry><entry><title>PAT 乙级 1005</title><url>/post/old/pat-basic-level/1005/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/2 &#34;&#34;&#34; PAT 乙级 1005 &#34;&#34;&#34; def compute_sequence(num): sequence = [] while num != 1: if num % 2 == 0: num = num // 2 else: num = (num * 3 + 1) // 2 sequence.append(num) return sequence if __name__ == &#39;__main__&#39;: sequences = [] n = int(input()) nums = [int(num) for num in input().split(&#39; &#39;)] i = 0 while i &lt; n: sequence = compute_sequence(nums[i]) sequences.append(sequence[:-1]) i += 1 key_nums = [] for i, num in enumerate(nums): is_key = True for j, sequence in enumerate(sequences): if i == j: continue if num in sequence: is_key = False break if is_key: key_nums.append(num) key_nums.sort(reverse=True) print(&#39; &#39;.join([str(num) for num in key_nums]))   ]]></content></entry><entry><title>PAT 乙级 1004</title><url>/post/old/pat-basic-level/1004/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/1 &#34;&#34;&#34; PAT 乙级 1004 &#34;&#34;&#34; def get_score(student): return student[2] if __name__ == &#39;__main__&#39;: n = int(input()) students = [] while n != 0: tokens = input().split(&#39; &#39;) students.append((tokens[0], tokens[1], int(tokens[2]))) n -= 1 students.sort(key=get_score) print(students[len(students) - 1][0], students[len(students) - 1][1]) print(students[0][0], students[0][1])   ]]></content></entry><entry><title>PAT 乙级 1017</title><url>/post/old/pat-basic-level/1017/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/5 &#34;&#34;&#34; PAT 乙级 1017 &#34;&#34;&#34; if __name__ == &#39;__main__&#39;: a, b = map(int, input().split(&#39; &#39;)) print(a // b, a % b)   ]]></content></entry><entry><title>PAT 乙级 1016</title><url>/post/old/pat-basic-level/1016/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/5 &#34;&#34;&#34; PAT 乙级 1016 &#34;&#34;&#34; def count(string, char): c = 0 for v in string: if v == char: c += 1 return c def pad(char, num): if num == 0: return &#39;0&#39; ret = &#39;&#39; while num != 0: ret += char num -= 1 return ret if __name__ == &#39;__main__&#39;: strings = input().split(&#39; &#39;) a_count = count(strings[0], strings[1]) b_count = count(strings[2], strings[3]) print(int(pad(strings[1], a_count)) + int(pad(strings[3], b_count)))   ]]></content></entry><entry><title>PAT 乙级 1015</title><url>/post/old/pat-basic-level/1015/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/4 &#34;&#34;&#34; PAT 乙级 1015 &#34;&#34;&#34; from functools import cmp_to_key def sort_students(student1, student2): total1 = sum(student1[1:]) total2 = sum(student2[1:]) if total1 != total2: return -1 if total1 &gt; total2 else 1 elif student1[1] != student2[1]: return -1 if student1[1] &gt; student2[1] else 1 else: return -1 if int(student1[0]) &gt; int(student2[1]) else 1 if __name__ == &#39;__main__&#39;: [n, base_score, priority_score] = list(map(int, input().split())) students = [] while n != 0: tokens = input().split() students.append((tokens[0], int(tokens[1]), int(tokens[2]))) n -= 1 student_group = [[], [], [], []] for i, student in enumerate(students): # 德分和才分均低于最低分数线 if student[1] &lt; base_score or student[2] &lt; base_score: continue # 德分和才分均大于等于优化分数线 if student[1] &gt;= priority_score and student[2] &gt;= priority_score: student_group[0].append(student) elif student[1] &gt;= priority_score &gt; student[2]: student_group[1].append(student) elif student[1] &lt; priority_score and student[2] &lt; priority_score: if student[1] &gt;= student[2]: student_group[2].append(student) else: student_group[3].append(student) else: student_group[3].append(student) m = sum([len(g) for g in student_group]) print(m) student_group[0].sort(key=cmp_to_key(sort_students)) student_group[1].sort(key=cmp_to_key(sort_students)) student_group[2].sort(key=cmp_to_key(sort_students)) student_group[3].sort(key=cmp_to_key(sort_students)) students = student_group[0] + student_group[1] + student_group[2] + student_group[3] for student in students: print(&#39;%s %d %d&#39; % (student[0], student[1], student[2]))   ]]></content></entry><entry><title>PAT 乙级 1014</title><url>/post/old/pat-basic-level/1014/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env python # -*- coding: utf-8 -*- # author: a2htray # create date: 2023/3/4 &#34;&#34;&#34; PAT 乙级 1014 &#34;&#34;&#34; week_dict = { &#39;A&#39;: &#39;MON&#39;, &#39;B&#39;: &#39;TUE&#39;, &#39;C&#39;: &#39;WED&#39;, &#39;D&#39;: &#39;THU&#39;, &#39;E&#39;: &#39;FRI&#39;, &#39;F&#39;: &#39;SAT&#39;, &#39;G&#39;: &#39;SUN&#39;, } hour_dict = { &#39;0&#39;: &#39;00&#39;, &#39;1&#39;: &#39;01&#39;, &#39;2&#39;: &#39;02&#39;, &#39;3&#39;: &#39;03&#39;, &#39;4&#39;: &#39;04&#39;, &#39;5&#39;: &#39;05&#39;, &#39;6&#39;: &#39;06&#39;, &#39;7&#39;: &#39;07&#39;, &#39;8&#39;: &#39;08&#39;, &#39;9&#39;: &#39;09&#39;, &#39;A&#39;: &#39;10&#39;, &#39;B&#39;: &#39;11&#39;, &#39;C&#39;: &#39;12&#39;, &#39;D&#39;: &#39;13&#39;, &#39;E&#39;: &#39;14&#39;, &#39;F&#39;: &#39;15&#39;, &#39;G&#39;: &#39;16&#39;, &#39;H&#39;: &#39;17&#39;, &#39;I&#39;: &#39;18&#39;, &#39;J&#39;: &#39;19&#39;, &#39;K&#39;: &#39;20&#39;, &#39;L&#39;: &#39;21&#39;, &#39;M&#39;: &#39;22&#39;, &#39;N&#39;: &#39;23&#39;, } if __name__ == &#39;__main__&#39;: n_line = 4 lines = [] while n_line != 0: lines.append(input()) n_line -= 1 week, hour, second = &#39;&#39;, &#39;&#39;, &#39;&#39; j = 0 for i, char in enumerate(lines[0]): if char == lines[1][i] and char in week_dict.keys(): j = i week = week_dict[char] break for i in range(j+1, len(lines[0])): if lines[0][i] == lines[1][i] and lines[0][i] in hour_dict.keys(): hour = hour_dict[lines[0][i]] break for i, char in enumerate(lines[2]): if char.isalpha() and char == lines[3][i]: second = &#39;%.2d&#39; % i break print(week + &#39; &#39; + hour + &#39;:&#39; + second)   ]]></content></entry><entry><title>PAT 乙级 1002</title><url>/post/old/pat-basic-level/1002/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html"><![CDATA[  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # basic_1002.py chinese_pinyins = [ &#39;ling&#39;, &#39;yi&#39;, &#39;er&#39;, &#39;san&#39;, &#39;si&#39;, &#39;wu&#39;, &#39;liu&#39;, &#39;qi&#39;, &#39;ba&#39;, &#39;jiu&#39;, ] if __name__ == &#39;__main__&#39;: num_chars = input() total = 0 for num_char in num_chars: total += int(num_char) output = [] for num_char in str(total): output.append(chinese_pinyins[int(num_char)]) print(&#39; &#39;.join(output)) 运行 1 2 3 4 input: 1928374 output: san si   ]]></content></entry><entry><title>PAT 乙级 1001</title><url>/post/old/pat-basic-level/1001/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT Basic Level</tag><tag>PAT</tag></tags><content type="html">  
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # basic_1001.py if __name__ == &amp;#39;__main__&amp;#39;: n = int(input()) step = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = (3 * n + 1) // 2 step += 1 print(step) 运行 1 2 3 4 input: 100 output: 18   </content></entry><entry><title>Redis with Python（五） 哈希表操作</title><url>/post/old/redis-python/redis-python-hash/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Redis</tag><tag>Python</tag></tags><content type="html"><![CDATA[  哈希表（hash）是 Redis 中重要的数据结构，本文通过示例演示如何使用 Python 完成对哈希表的操作，各方法调用分别对应着 Redis 的一个指令：
HSET HGET HINCRBY HINCRBYFLOAT HSTRLEN HVALS HMSET HMGET HSETNX 常规操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 # -*- coding:utf-8 -*- # Date: 2023/2/27 # Created by: a2htray # Description: 哈希表操作 import redis redis_config = { &#39;host&#39;: &#39;redis-testing&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &#39;__main__&#39;: # HSET # 设置哈希表的字段与值 # 返回设置成功的字段个数 print(rs.hset(&#39;person&#39;, &#39;name&#39;, &#39;a2htray&#39;, { &#39;height&#39;: 179, })) # 2 # HGET # 取哈希表中某个字段的值 print(rs.hget(&#39;person&#39;, &#39;name&#39;)) # b&#39;a2htray&#39; # HINCRBY # 对哈希表中某个字段值（整数）进行自增 # 返回字段的新值 rs.hset(&#39;score&#39;, &#39;math&#39;, 100, {&#39;english&#39;: 100}) print(rs.hincrby(&#39;score&#39;, &#39;math&#39;, -40)) # 60 print(rs.hincrby(&#39;score&#39;, &#39;english&#39;, 20)) # 120 # HINCRBYFLOAT # 对哈希表中的某个字段值（浮点数）进行自增 # 返回字段的新值 rs.hset(&#39;person&#39;, &#39;weight&#39;, 73.5) print(rs.hincrbyfloat(&#39;person&#39;, &#39;weight&#39;, 0.5)) # 74.0 # HSTRLEN # 获取哈希表中某个字段值的长度 print(rs.hstrlen(&#39;person&#39;, &#39;name&#39;)) # 7 # HDEL # 删除一个或多个哈希表中的字段 # 返回删除成功的字段个数 print(rs.hdel(&#39;person&#39;, &#39;height&#39;, &#39;weight&#39;)) # 2 print(rs.hgetall(&#39;person&#39;)) # {b&#39;name&#39;: b&#39;a2htray&#39;} # HKEYS # 返回哈希表中的字段列表 print(rs.hkeys(&#39;person&#39;)) # [b&#39;name&#39;] print(rs.hkeys(&#39;notExistPerson&#39;)) # [] # HEXISTS # 判断哈希表中是否存在某个字段 print(rs.hexists(&#39;person&#39;, &#39;name&#39;)) # True print(rs.hexists(&#39;person&#39;, &#39;notExistName&#39;)) # False # HGETALL # 取哈希表所有信息 print(rs.hgetall(&#39;person&#39;)) # {b&#39;name&#39;: b&#39;a2htray&#39;} # HLEN # 取哈希表中字段的个数 print(rs.hlen(&#39;person&#39;)) # 1 # HVALS # 返回哈希表中值列表 print(rs.hvals(&#39;person&#39;)) # [b&#39;a2htray&#39;] # HMSET # 设置一个或多个哈希表的字段和值 # hmset 已作废，应使用 hset print(rs.hmset(&#39;person&#39;, { &#39;height&#39;: 179, &#39;weight&#39;: 73.5, })) # HMGET # 获取哈希表中多个值信息 print(rs.hmget(&#39;person&#39;, *[&#39;name&#39;, &#39;height&#39;, &#39;weight&#39;])) # [b&#39;a2htray&#39;, b&#39;179&#39;, b&#39;73.5&#39;] # HSETNX # 设置哈希表的字段和值，只有当字段不存在时才生效 print(rs.hsetnx(&#39;person&#39;, &#39;location&#39;, &#39;WuHan&#39;)) # 1 小结 简明易用。
  ]]></content></entry><entry><title>哈希表相关</title><url>/post/doc-redis-commands/hash-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与哈希表相关的命令。
HSET：设置哈希表的值 HSET 用于设置散列一个或多个的值，返回设置成功的 field-value 对数。
格式：HSET key field value [field value ...]
1 2 3 4 127.0.0.1:6379&amp;gt; HSET person name a2htray height 179 (integer) 2 127.0.0.1:6379&amp;gt; HSET person weight 73.5 (integer) 1 HGET：取哈希表中相应 field 对应的值 HGET 用于获取哈希表中单个 field 所对应的值，若 key 不存在或 field 不存在，返回 nil。
格式：HGET key field
1 2 3 4 5 6 127.0.0.1:6379&amp;gt; HGET person name &amp;#34;a2htray&amp;#34; 127.0.0.1:6379&amp;gt; HGET otherPerson name (nil) 127.0.0.1:6379&amp;gt; HGET person age (nil) HINCRBY：对哈希表中整数值进行自增 HINCRBY 作用于哈希表可解析为整数的值，并为其加上对应整数的增量，若需要减少，将整数设置为负数即可。
格式：HINCRBY key field increment
1 2 3 4 5 6 127.0.0.1:6379&amp;gt; HSET score math 100 english 100 (integer) 2 127.0.0.1:6379&amp;gt; HINCRBY score math -40 (integer) 60 127.0.0.1:6379&amp;gt; HINCRBY score english 20 (integer) 120 HINCRBYFLOAT：对哈希表中浮点数进行自增 与 HINCRBY 类似，不过 HINCRBYFLOAT 作用于可解析成浮点数的值。
格式：HINCRBYFLOAT key field increment
1 2 3 4 127.0.0.1:6379&amp;gt; HGET person weight &amp;#34;73.5&amp;#34; 127.0.0.1:6379&amp;gt; HINCRBYFLOAT person …  ]]></content></entry><entry><title>Redis with Python（四） 有序集合操作</title><url>/post/old/redis-python/redis-python-zset/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Redis</tag><tag>Python</tag></tags><content type="html"><![CDATA[  zset 有序集合是 set 的补充，zset 中的元素都带有一个用于排序的分数，以下通过代码示例进行说明。
常规操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import random import redis redis_config = { &#39;host&#39;: &#39;redis-testing&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &#39;__main__&#39;: # ZADD # 设置一个或多个带分数的值 # 返回设置成功的个数 # 若值已存在，则更新其分数 print(rs.zadd(&#39;heights&#39;, {&#39;King&#39;: 146, &#39;Jimmy&#39;: 160, &#39;Ann&#39;: 155})) # 3 # 更新分数不计入设置成功的个数 print(rs.zadd(&#39;heights&#39;, {&#39;Jimmy&#39;: 165})) # 0 # ZSCORE # 获取值的分数 print(rs.zscore(&#39;heights&#39;, &#39;King&#39;)) # 146.0 # ZRANGE # 取指定索引区间上的值 print(rs.zrange(&#39;heights&#39;, 1, 2)) # [b&#39;Ann&#39;, b&#39;Jimmy&#39;] # ZRANGEBYSCORE # 取分数符合区间内的元素 print(rs.zrangebyscore(&#39;heights&#39;, 140, 159)) # [b&#39;King&#39;, b&#39;Ann&#39;] # 第 3 个参数指定开始查找的索引 # 第 4 个参数指定返回值的个数 # withscores 为 True 时，返回值要带上分数 print(rs.zrangebyscore(&#39;heights&#39;, 140, 159, 1, 1, withscores=True)) # [(b&#39;Ann&#39;, 155.0)] # ZINCRBY # 增加某个值的分数 # 返回更新后的分数 print(rs.zincrby(&#39;heights&#39;, 5, &#39;Ann&#39;)) # 160.0 # ZCARD # 返回集合中元素的个数 print(rs.zcard(&#39;heights&#39;)) # 3 # ZCOUNT # 返回指定分数区间上值的个数 print(rs.zcount(&#39;heights&#39;, 155, 170)) # 2 # ZREM # 删除一个或多个元素 # 返回删除成功的个数 print(rs.zrem(&#39;heights&#39;, &#39;Jimmy&#39;, &#39;Ann&#39;)) # 2 # ZREMRANGEBYRANK # 删除指定区间上的元素 # 返回成功删除的个数 rs.zadd(&#39;floats&#39;, {&#39;0.1&#39;: 0.1, &#39;0.2&#39;: 0.2, &#39;0.3&#39;: 0.3}) print(rs.zremrangebyrank(&#39;floats&#39;, 0, 1)) # 2 print(rs.zrange(&#39;floats&#39;, 0, rs.zcard(&#39;floats&#39;))) # [b&#39;0.3&#39;] # ZREMRANGEBYSCORE # 删除符合指定分数区间的元素 # 返回成功删除的个数 rand_values = {} s = &#39;abcdefg&#39; for v in range(len(s)): rand_values[s[v]] = random.random() rs.zadd(&#39;rand_values&#39;, rand_values) print(rs.zrange(&#39;rand_values&#39;, 0, len(s), withscores=True)) # [(b&#39;d&#39;, 0.200721567466151), (b&#39;f&#39;, 0.3296169544640849), (b&#39;c&#39;, 0.3677595274693486), (b&#39;b&#39;, 0.512665164306821), (b&#39;g&#39;, 0.5353782879780641), (b&#39;a&#39;, 0.7277933908083912), (b&#39;e&#39;, 0.942418290434278)] print(rs.zremrangebyscore(&#39;rand_values&#39;, 0.3, 0.4)) # 2 print(rs.zcard(&#39;rand_values&#39;)) # 5 # ZRANK # 获取元素在集合中的位置 print(rs.zrank(&#39;rand_values&#39;, &#39;a&#39;)) # 3 # ZREVRANK # 获取元素在降序集合中的位置 print(rs.zrevrank(&#39;rand_values&#39;, &#39;a&#39;)) # 1 代码在： https://github.com/a2htray/code-notebook/blob/main/Redis/app/zset.py 。
小结 在 Pyhon 中用字典作为 zset 的操作值，其中字典的 key 为相应的元素，字典的 value 为对应的分数。常规操作包括：
设置或删除 zset 的值 按索引或分数进行取值 取索引信息   ]]></content></entry><entry><title>Redis with Python（三） 集合操作及运算</title><url>/post/old/redis-python/redis-python-set/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Redis</tag><tag>Python</tag></tags><content type="html"><![CDATA[  set 数据类型对应元素不重复的数据结构，在 Redis 中，set 数据类型是无序的，与之相对的有序集合 zset。本文内容分两部分：
集合操作 集合运算 集合操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import redis redis_config = { &#39;host&#39;: &#39;redis-testing&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &#39;__main__&#39;: # SADD 向集合中添加元素 # 返回添加成功元素的个数 print(rs.sadd(&#39;numbers&#39;, 1, 2, 3, 4, 5)) # 5 # 由于 4, 5 已存在于 numbers 集合，所以只需要添加 6, 7, 8，返回成功添加的个数 3 print(rs.sadd(&#39;numbers&#39;, 4, 5, 6, 7, 8)) # 3 # SREM # 删除集合中的元素，返回成功删除的元素个数 print(rs.srem(&#39;numbers&#39;, *[1, 2, 3])) # 3 print(rs.srem(&#39;numbers&#39;, *[1, 2, 3, 4])) # 1 # SMEMBERS # 获取集合中的所有元素，返回类型对应 Python 中的 set 类型 print(rs.sadd(&#39;alphabet&#39;, *[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])) # 3 print(rs.smembers(&#39;alphabet&#39;)) # {b&#39;b&#39;, b&#39;a&#39;, b&#39;c&#39;} # SCARD # 取集合中元素的个数 print(rs.scard(&#39;alphabet&#39;)) # 3 # SRANDMEMBER # 随机取集合中指定个数的元素 # 随机输出，结果不保证一致 print(rs.srandmember(&#39;alphabet&#39;, 1)) # [b&#39;b&#39;] # 指定个数大于集合元素个数时，返回全部元素 print(rs.srandmember(&#39;alphabet&#39;, 4)) # [b&#39;c&#39;, b&#39;a&#39;, b&#39;b&#39;] # SPOP # 从集合中弹出指定个数的元素 print(rs.spop(&#39;alphabet&#39;, 2)) # [b&#39;b&#39;, b&#39;c&#39;] print(rs.smembers(&#39;alphabet&#39;)) # {b&#39;a&#39;} 代码在： https://github.com/a2htray/code-notebook/blob/main/Redis/app/set_basic.py 。
集合运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import redis redis_config = { &#39;host&#39;: &#39;redis-testing&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &#39;__main__&#39;: rs.sadd(&#39;projectA&#39;, *[&#39;A001&#39;, &#39;A002&#39;, &#39;A003&#39;]) rs.sadd(&#39;projectAB&#39;, *[&#39;A001&#39;, &#39;A002&#39;, &#39;A003&#39;, &#39;B001&#39;, &#39;B002&#39;]) # SDIFF # 取集合的差集 # 若参数为 S1, S2, S3, ...，则返回结果为 S1 - S2 - S3 - ... print(rs.sdiff(&#39;projectA&#39;, &#39;projectAB&#39;)) # set() print(rs.sdiff(&#39;projectAB&#39;, &#39;projectA&#39;)) # {b&#39;B001&#39;, b&#39;B002&#39;} # SINTER # 取集合的交集 print(rs.sinter(&#39;projectA&#39;, &#39;projectAB&#39;)) # {b&#39;A001&#39;, b&#39;A003&#39;, b&#39;A002&#39;} # SUNION # 取集合的并集 rs.sadd(&#39;projectB&#39;, *[&#39;B001&#39;, &#39;B002&#39;]) print(rs.sunion(&#39;projectA&#39;, &#39;projectB&#39;)) # {b&#39;A002&#39;, b&#39;A001&#39;, b&#39;B001&#39;, b&#39;A003&#39;, b&#39;B002&#39;} # SDIFFSTORE # 计算集合的差集并将结果保存至另一键的集合中 # 返回差集中元素的个数 rs.delete(&#39;projectB&#39;) print(rs.sdiffstore(&#39;projectB&#39;, &#39;projectAB&#39;, &#39;projectA&#39;)) # 2 print(rs.smembers(&#39;projectB&#39;)) # {b&#39;B001&#39;, b&#39;B002&#39;} # SINTERSTORE # 计算集合的交集并将结果保存至另一键的集合中 # 返回交集中元素的个数 print(rs.sinterstore(&#39;newProjectB&#39;, &#39;projectAB&#39;, &#39;projectB&#39;)) # 2 print(rs.smembers(&#39;newProjectB&#39;)) # {b&#39;B001&#39;, b&#39;B002&#39;} # SUNIONSTORE # 计算集合的并集并将结果保存至另一键的集合中 # 返回并集中元素的个数 rs.delete(&#39;projectAB&#39;) print(rs.sunionstore(&#39;projectAB&#39;, &#39;projectA&#39;, &#39;projectB&#39;)) # 5 print(rs.smembers(&#39;projectAB&#39;)) # {b&#39;A002&#39;, b&#39;A001&#39;, b&#39;B001&#39;, b&#39;A003&#39;, b&#39;B002&#39;} 代码在： https://github.com/a2htray/code-notebook/blob/main/Redis/app/set_ops.py 。
小结 Redis 中的 set 数据类型保存的是无序的元素集合，Python 调用方式与 Redis 指令高度一致。
  ]]></content></entry><entry><title>Redis with Python（二） 字符串操作</title><url>/post/old/redis-python/redis-python-string/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Redis</tag><tag>Python</tag></tags><content type="html"><![CDATA[  string 是 Redis 中最基础的数据类型，由于它是二进制安全的，所以可以存储图片的二进制信息。本文通过 3 个部分介绍在 Python 下如何操作 Redis 的 string 数据类型：
常规字符串操作 位运算操作 数值操作 常规字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import time import redis redis_config = { &amp;#39;host&amp;#39;: &amp;#39;redis-testing&amp;#39;, &amp;#39;port&amp;#39;: 6379, &amp;#39;db&amp;#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &amp;#39;__main__&amp;#39;: # SET # 设置单个键值对 # 返回是否设置成功 print(rs.set(&amp;#39;name&amp;#39;, &amp;#39;a2htray&amp;#39;)) # True # SETNX # 设置单个键值对，只有当键不存在时有效 print(rs.setnx(&amp;#39;name&amp;#39;, &amp;#39;a2htray2&amp;#39;)) # False print(rs.setnx(&amp;#39;notExistName&amp;#39;, &amp;#39;a2htray&amp;#39;)) # True # SETEX # 设置具有生存时间的键值对，单位为秒 print(rs.setex(&amp;#39;course&amp;#39;, 1, &amp;#39;math&amp;#39;)) # True time.sleep(1.5) # 设置 1.5 秒后访问 print(rs.get(&amp;#39;course&amp;#39;)) # None # PSETEX # 设置具有生存时间的键值对，单位为微秒 # 1000 微秒 = 1 秒 …  ]]></content></entry><entry><title>Redis with Python（一） 列表操作</title><url>/post/old/redis-python/redis-python-list/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Redis</tag><tag>Python</tag></tags><content type="html"><![CDATA[  list 是 Redis 中操作比较频繁的数据结构，本文将结合 Python 对其进行相关操作并按“是否发生阻塞”分成两个部分：
非阻塞指令 阻塞指令 非阻塞操作 Redis 的 list 操作中，非阻塞指令包括：
LPUSH 和 LPUSHX RPUSH 和 RPUSHX LPOP 和 RPOP LLEN LRANGE LREM LINDEX LSET LTRIM LINSERT RPOPLPUSH 以下是各指令的 Python 代码示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import redis redis_config = { &amp;#39;host&amp;#39;: &amp;#39;redis-testing&amp;#39;, &amp;#39;port&amp;#39;: 6379, &amp;#39;db&amp;#39;: 1, } rs = redis.Redis(**redis_config) if __name__ == &amp;#39;__main__&amp;#39;: # LPUSH # 创建 colors，并向左添加两个元素 # 返回添加后列表的长度 print(rs.lpush(&amp;#39;colors&amp;#39;, &amp;#39;green&amp;#39;, &amp;#39;yellow&amp;#39;)) # 2 # LPUSHX # 向 colors 添加新的元素 # 返回添加后列表的长度 print(rs.lpushx(&amp;#39;colors&amp;#39;, &amp;#39;red&amp;#39;)) # 3 # LPUSHX # 向不存在的列表添加元素，不会创建相应列表并返回 0 print(rs.lpushx(&amp;#39;notExistColors&amp;#39;, …  ]]></content></entry><entry><title>命令 jq（二） 特殊字符和构造器</title><url>/post/old/linux-jq-command-02/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>jq</tag></tags><content type="html"><![CDATA[  上一篇文章介绍了 jq 中的过滤器，但单独地使用过滤器无法满足复杂的实际需求，所以 jq 中引入了特殊字符（, 和 |）和构造器来实现定制化的输出。
特殊字符 jq 中有两个特殊字符，, 和 |，分别用于实现：
, 多过滤器处理相同输入 | 类似于 Linux 管道符操作 , , 用于分隔多个过滤器，多个过滤器可同时对输入起作用并作为连续输出，如：
1 2 3 4 5 $ cat example.json | jq &#39;.type, .required&#39; &#34;object&#34; [ &#34;email&#34; ] | | 的工作模式就是依照 Linux 中的管道符的处理方式，前一个过滤器的输出会作为后一个过滤器的输入，如：
1 2 $ cat example.json | jq &#39;.type | .[0:3]&#39; &#34;obj&#34; 上述示例中，.type 作用是获取 JSON 对象的 type 值，之后将该值作为 .[0:3] 的输入，而 type 值为一个字符串，且 .[0:3] 作为于字符串时会实现获取字符子串的效果，所以输出值为 obj。
构造器 构造器可以将输出以某种特定的类型进行展示，包括数组构造器 [] 和对象构造器 {}。
[] 在第 1 个示例中，其输出并没有包含特定的结构，所以可以使用 [] 将其以数组的形式进行展示，如：
1 2 3 4 5 6 7 $ cat example.json | jq &#39;[.type, .required]&#39; [ &#34;object&#34;, [ &#34;email&#34; ] ] {} 与 [] 类似，只不过输出的形式为对象。
1 2 3 4 5 6 7 $ cat example.json | jq &#39;{newKeyOfType: .type, newTypeOfRequired: .required}&#39; { &#34;newKeyOfType&#34;: &#34;object&#34;, &#34;newTypeOfRequired&#34;: [ &#34;email&#34; ] } 小结 特殊字符和构造器是复杂过滤器的基础，包含特殊字符和构造器的表达式也较为难懂，需要一步步拆分开进行分析。
本文使用的文件及命令见： https://github.com/a2htray/code-notebook/tree/main/Shell/jq 。
  ]]></content></entry><entry><title>命令 jq（一）基础过滤器</title><url>/post/old/linux-jq-command-01/</url><categories><category>后端技术</category><category>Shell</category></categories><tags><tag>Linux Shell</tag><tag>jq</tag></tags><content type="html"><![CDATA[  jq 是 Linux 下处理 JSON 文档字符串的命令行工具，可用于过滤并格式化输出特定的内容。其官网的手册详尽地介绍了 jq 的使用方法，内容相当丰富。本文则注重对过滤器的使用，并通过不同的示例加以说明。
Identity . . 是最简单的过滤器，该过滤器接收输入并且不做修改地进行输出。如果需要对 JSON 字符串进行格式化输出， 则可以使用该过滤器。
1 2 3 4 5 6 7 8 9 10 11 $ echo &#39;{&#34;title&#34;: &#34;大数据分析&#34;, &#34;price&#34;: 58}&#39; | jq &#39;.&#39; { &#34;title&#34;: &#34;大数据分析&#34;, &#34;price&#34;: 58 } $ cat unformatted.json | jq &#39;.&#39; { &#34;id&#34;: 1, &#34;name&#34;: &#34;myName&#34;, &#34;position&#34;: &#34;5&#34; } Object Identifier-Index .foo, .foo.bar .foo 可以获取输入中键为 foo 的值，同理，.foo.bar 则是先获取键为 foo 的值并在此基础上获取键为 bar 的值。
1 2 3 4 5 6 $ echo &#39;{&#34;name&#34;: &#34;app-01&#34;, &#34;kind&#34;: &#34;Pod&#34;}&#39; | jq &#39;.name&#39; &#34;app-01&#34; $ echo &#39;{&#34;fields&#34;: {&#34;name&#34;: {&#34;type&#34;: &#34;string&#34;}}}&#39; | jq &#39;.fields.name&#39; { &#34;type&#34;: &#34;string&#34; } Optional Object Identifier-Index .foo? .foo? 与 .foo 作用相同，但当输入不是一个合规的数组或对象时不会报错。
1 2 3 $ echo &#39;{&#34;name&#34;: &#34;a2htray&#34;}&#39; | jq &#39;.name.errorField&#39; jq: error (at &lt;stdin&gt;:1): Cannot index string with string &#34;errorField&#34; $ echo &#39;{&#34;name&#34;: &#34;a2htray&#34;}&#39; | jq &#39;.name.errorField?&#39; # 不会报错 Generic Object Index .[&lt;string&gt;] &lt;string&gt; 表示一个对象的键名，且 .[&lt;string&gt;] 与 .&lt;string&gt; 的效果相同。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ echo &#39;{&#34;fields&#34;: {&#34;name&#34;: {&#34;type&#34;: &#34;string&#34;}}}&#39; | jq &#39;.[&#34;fields&#34;]&#39; { &#34;name&#34;: { &#34;type&#34;: &#34;string&#34; } } $ echo &#39;{&#34;fields&#34;: {&#34;name&#34;: {&#34;type&#34;: &#34;string&#34;}}}&#39; | jq &#39;.[&#34;fields&#34;][&#34;name&#34;]&#39; { &#34;type&#34;: &#34;string&#34; } $ echo &#39;{&#34;fields&#34;: {&#34;name&#34;: {&#34;type&#34;: &#34;string&#34;}}}&#39; | jq &#39;.fields.name&#39; { &#34;type&#34;: &#34;string&#34; } $ cat example.json | jq &#39;.properties[&#34;name&#34;, &#34;email&#34;]&#39; { &#34;type&#34;: &#34;string&#34; } { &#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;email&#34; } Array Index .[integer] .[integer] 用于检索数组对象，并且索引值支持负数。
1 2 3 4 $ echo &#39;[1, 2, 3, 4]&#39; | jq &#39;.[0]&#39; 1 $ echo &#39;[1, 2, 3, 4]&#39; | jq &#39;.[-1]&#39; 4 Array/String Index .[integer1:integer2] .[integer1:integer2] 对数组或字符串进行切片操作，返回原数据的子集。
1 2 3 4 5 6 7 $ echo &#39;[1, 2, 3, 4]&#39; | jq &#39;.[0:2]&#39; [ 1, 2 ] $ echo &#39;&#34;1234&#34;&#39; | jq &#39;.[0:2]&#39; &#34;12&#34; Array/Object Value Iterator .[] .[] 返回数组的所有元素或对象的所有的值。
1 2 3 4 5 6 7 8 9 10 11 12 13 $ echo &#39;[1, 2, 3, 4]&#39; | jq &#39;.[]&#39; 1 2 3 4 $ echo &#39;{&#34;numbers&#34;: [1, 2, 3, 4]}&#39; | jq &#39;.numbers[]&#39; 1 2 3 4 $ echo &#39;{&#34;name&#34;: &#34;a2htray&#34;, &#34;like&#34;: 2}&#39; | jq &#39;.[]&#39; &#34;a2htray&#34; 2 Optional Array/Object Value Iterator .[]? .[]? 相对于 .[]，就好像 .foo? 相对于 .foo。
1 2 3 $ echo &#39;{&#34;name&#34;: &#34;a2htray&#34;, &#34;like&#34;: 2}&#39; | jq &#39;.unlike[]&#39; jq: error (at &lt;stdin&gt;:1): Cannot iterate over null (null) $ echo &#39;{&#34;name&#34;: &#34;a2htray&#34;, &#34;like&#34;: 2}&#39; | jq &#39;.unlike[]?&#39; # 不会报错 小结 jq 的过滤器内容不算多，使用的难点在于：面对不同 schema 的 JSON 结构，如何使用和串联过滤器。针对 JS 中的定义的数据类型，jq 都能提供相应的过滤器来获取特定的信息，包括：
object: 按键名取值 array: 索引取值、切片 string: 切片 本文使用的文件及命令见： https://github.com/a2htray/code-notebook/tree/main/Shell/jq 。
  ]]></content></entry><entry><title>基于 Docker 的 Nginx 负载均衡配置</title><url>/post/old/nginx-load-balance-with-docker/</url><categories><category>后端技术</category><category>Nginx</category></categories><tags><tag>Nginx</tag><tag>Docker</tag><tag>Docker Compose</tag><tag>Load Balance</tag></tags><content type="html"><![CDATA[  本文主要介绍如何基于 Docker 生成容器化应用以及配置 Nginx 来实现 Web 服务的负载均衡，包含以下内容：
Go 简易 Web 程序（hello world） 通过 Dockerfile 生成镜像 Nginx 配置 Docker Compose 多容器启动 Go Web 程序 本次配置使用 Go Web 程序作为后端服务，其作用是接收请求并返回“hello-world”，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // main.go package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; ) func main() { logFile, err := os.OpenFile(&amp;#34;/var/log/app.log&amp;#34;, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0777) if err != nil { log.Fatal(err) } defer logFile.Close() http.HandleFunc(&amp;#34;/hello-world&amp;#34;, func(w http.ResponseWriter, r *http.Request) { logFile.WriteString(&amp;#34;request arrived\n&amp;#34;) w.Write([]byte(&amp;#34;hello world\n&amp;#34;)) }) log.Fatal(http.ListenAndServe(&amp;#34;:8000&amp;#34;, nil)) } /var/log/app.log 是程序的日志文件，用于标识服务器端接收到了请求，作为后续分析流量的依据。执行以下命令查看运行结果：
1 2 3 4 5 6 $ go run main.go # 另启一个终端并执行 $ curl localhost:8000/hello-world hello-world $ cat /var/log/app.log request arrived 从结果输出中可以看出，程序正常运行并成功记录请求日志。
Web 服务镜像 Web 服务镜像就是将上一节的 Go Web 服务封装到镜 …  ]]></content></entry><entry><title>从字符串中创建 DataFrame</title><url>/post/old/python-pandas-create-dataframe-from-raw-string/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Pandas</tag><tag>DataFrame</tag><tag>Python</tag></tags><content type="html"><![CDATA[  一般情况下，你们会通过文件（CSV、Excel等） 或 Python 的内置结构（字典）来创建 DataFrame 对象。但有时，数据是字符串的形式，如何将其转换成 DataFrame 对象？
答案：将字符串强制转换成 io.StringIO，再作为 pd.read_csv 的参数。
1 2 3 4 5 6 7 8 9 import pandas as pd from io import StringIO data = &#39;&#39;&#39;人口基本情况,1982年,1990年,2000年,2020年,2021年 0-14岁人口,34156,31670,29024,25277,24721 15-64岁人口,62517,76260,88847,96871,96481 65岁以上人口,4981,6403,8872,19064,20059&#39;&#39;&#39; df = pd.read_csv(StringIO(data), index_col=0)   ]]></content></entry><entry><title>创建 Pandas 的 Series 和 DataFrame</title><url>/post/old/python-pandas-series-dataframe/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Pandas</tag><tag>DataFrame</tag><tag>Series</tag><tag>Python</tag></tags><content type="html"><![CDATA[  Series 和 DataFrame 是 Pandas 中两种重要的数据结构，也是我们操作和分析的主要对象。其中 Series 是一种类似于数组、列表或表格中一列的 一维数据对象，DataFrame 则可以表示表格化的数据对象，可由多个 Series 对象组成。
本文主要摘录 Series 和 DataFrame 两种数据结结构的创建方法以及一些注意事项。
Series 的创建 Pandas 提供 Series 来表示一系列的元素，与常规一维数组只能以整数作为索引不同，Series 的索引类型可以是任一类型，其索引值与值的映射结构类似于 Python 中的字典。
Series 的构造函数 Series 的构造函数的声明如下：
1 2 3 4 5 6 7 8 9 10 def __init__( self, data=None, index=None, dtype: Dtype | None = None, name=None, copy: bool = False, fastpath: bool = False, ): pass 从列表中创建 Series 1 2 names = [&#39;Jimmy&#39;, &#39;Andy&#39;, &#39;Tony&#39;, &#39;John&#39;] names_series = pd.Series(names) pd.Series 的第 1 个参数名为 data，即上述调用过程等价于 names_series = pd.Series(data=names)。因为列表中没有相应的值可以作为 Series 的 index 值，所以 Pandas 会以 0 起始为每 1 个元素进行索引。如果指定了 index 参数值，可以修改 Series 中的索引值。
1 names_series = pd.Series(names, index=[&#39;ST0001&#39;, &#39;ST0002&#39;, &#39;ST0003&#39;, &#39;ST0004&#39;]) 此时可以通过 names_series['ST0002'] 访问 'Andy' 元素。
从字典中创建 Series 1 2 3 4 5 6 sales = { &#39;January&#39;: 1000, &#39;February&#39;: 900, &#39;March&#39;: 1200, } sales_series = pd.Series(sales) Python 中的字典是 key-value 结构，所以字典值作为 data 参数值时，其 key 值会作为 Series 的 index 值。此时可以通过 sales['January'] 访问到 1000 元素。
从 np.ndarray 中创建 Series 从 np.ndarray 中创建 Series 与从列表中创建 Series 类似：
1 2 x_axis_values = np.arange(0, 7) axis_series = pd.Series(x_axis_values, index=[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;, &#39;Sunday&#39;]) 从标量中创建 Series 1 scaled_series = pd.Series(7, index=[&#39;01&#39;, &#39;02&#39;, &#39;03&#39;]) 此时 scaled_series 中一共有 3 个元素，各元素的 index 分别为 &lsquo;01&rsquo;、&lsquo;02&rsquo; 和 &lsquo;03&rsquo;。标量作为 data 参数值时，Pandas 会按 index 参数 值的长度进行扩展。如果没有指定 index 值时，索引值则为 0 且长度为 1。
DataFrame 的创建 Pandas 提供 DataFrame 结构可用于表示表格化的数据。
DataFrame 的构造函数 1 2 3 4 5 6 7 8 9 def __init__( self, data=None, index: Axes | None = None, columns: Axes | None = None, dtype: Dtype | None = None, copy: bool | None = None, ): pass 相较于 Series 的构造函数，DataFrame 的构造函数可以指定列名（columns）。因为 DataFrame 可以视为一个或多个 Series 的集合，同样的， columns 值可以视为每一个 Series 的 name 参数的传值。
从字典（列表为元素）中创建 DataFrame 1 2 3 4 5 6 7 8 scores = { &#39;Jimmy&#39;: [89, 88, 93], &#39;Andy&#39;: [78, 90, 99], &#39;Tony&#39;: [83, 85, 87], &#39;John&#39;: [87, 67, 70], } df = pd.DataFrame(data=scores) scores 的 key 值会作为 DataFrame 的列名。
指定 index、columns 值 index 参数用于设置 DataFrame 每行的索引值，columns 参数用于设置列名。
1 2 3 4 5 6 df = pd.DataFrame([ [89, 88, 93], [78, 90, 99], [83, 85, 87], [87, 67, 70], ], index=[&#39;Jimmy&#39;, &#39;Andy&#39;, &#39;Tony&#39;, &#39;John&#39;], columns=[&#39;Math&#39;, &#39;English&#39;, &#39;Chinese&#39;]) 上述中，df 是一个 4 行 3 列的表格化对象。如果 data 参数值是一个字典，则 columns 参数还可以起到过滤的作用。
  ]]></content></entry><entry><title>Two Steps to Build an Academic Website with Hugo and Wowchemy</title><url>/post/old/go-hugo-wowchemy-academic-website/</url><categories><category>生产力工具</category><category>Hugo</category></categories><tags><tag>Academic Website</tag><tag>Hugo</tag><tag>Wowchemy</tag></tags><content type="html"><![CDATA[  Four days ago, I got a requirement to build an academic website for yunzila~ . This reminds me of my previous blog experience. Since my blog is built with Hugo, I started to find an academic theme which is designed for Hugo. Here is a link to Hugo themes , and then I find the Academic theme developed by gcushen which meets my needs.
After reading the documents, I try to use the latest version of Wowchemy Academic theme but bad things always come. Yes, I get into trouble when I configure the Wowchemy 5.7. the Wowchemy 5+ is too difficult for newbies. So I make a decision to use Wowchemy 4.6.3. This post records my process of configuring an academic website with Hugo and Wowchemy 4.6.3.
Install Hugo Extended Why use Hugo extended? Because the theme has used Sass or SCSS to stylize. You can get a specific version of the source code from the GitHub by following command:
1 2 3 $ git clone -b v0.104.1 git@github.com:gohugoio/hugo.git $ cd hugo $ CGO_ENABLED=1 go install --tags extended It is noted that the latest hugo is developed with Go 1.18, make sure that the Go 1.18+ is installed in your system. During the execution of CGO_ENABLED=1 go install --tags extended, you may encounter some problems such as package is missing. Here are some details of issues I experienced.
1 2 3 4 5 6 go: github.com/alecthomas/chroma/v2@v2.3.0 requires github.com/alecthomas/repr@v0.1.0: missing go.sum entry; to add it: go mod download github.com/alecthomas/repr ./../go/pkg/mod/github.com/cpuguy83/go-md2man/v2@v2.0.2/md2man/md2man.go:4:2: missing go.sum entry needed to verify package github.com/russross/blackfriday/v2 (imported by github.com/cpuguy83/go-md2man/v2/md2man) is provided by exactly one module; to add: go get github.com/cpuguy83/go-md2man/v2/md2man@v2.0.2 For above issues, we need to run commands as follows:
1 2 $ go mod download github.com/alecthomas/repr@v0.1.0 $ go get github.com/cpuguy83/go-md2man/v2/md2man@v2.0.2 Now, we need to run CGO_ENABLED=1 go install --tags extended again to build a binary executable file which will be stored to $GOPATH/bin/.
To test whether the hugo is installed:
1 2 $ hugo version hugo v0.104.1-8958b8741f552c8024af5194330fbf031544a826+extended darwin/amd64 BuildDate=2022-09-26T17:05:45Z Install Wowchemy Academic Theme At present, the theme is kept in this repository . For the 4.6.3 version, I suggest you to download the source code from the release page v4.6.3 .
If your website directory name is academic-site, you can execute the following commands to install the theme.
1 2 3 4 5 $ cd academic-site $ mkdir themes/academic # decompress the zip into the folder `themes/academic` $cp -rf themes/academic/exampleSite/* ./ At last, you should to modify the theme code in themes/academic/layouts/publication/single.html at line 14.
1 {{ if (.Params.publication_types) and (ne (index .Params.publication_types 0) &#34;0&#34;) }} changed to
1 {{ if and (.Params.publication_types) (ne (index .Params.publication_types 0) &#34;0&#34;) }} You can run hugo server to get a glance the website.
Write at Last I will try to learn the structure of the theme code, and get the ability to do some modifications to make the theme more customizable.
  ]]></content></entry><entry><title>Write Mumultiple Dataframes to Worksheets</title><url>/post/old/python-pandas-write-mumultiple-dataframes-to-worksheets/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Pandas</tag><tag>xls</tag></tags><content type="html"><![CDATA[  In normal work, I usually use Pandas as my excel read/write utility.
Here is an example for how to write multiple dataframes to worksheets. We need to use pd.ExcelWriter method.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import pandas as pd writer = pd.ExcelWriter(&#39;./multiple-dataframes-in-a-single-xls.xls&#39;) df1 = pd.DataFrame(columns=[ &#39;Book&#39;, &#39;Author&#39;, ], data=[ (&#39;Pride and Prejudice&#39;, &#39;Jane Austen&#39;), (&#39;Healing Her Heart&#39;, &#39;Laura Scott&#39;), ]) df2 = pd.DataFrame(columns=[ &#39;Website&#39;, &#39;Scale&#39;, ], data=[ (&#39;Alibaba&#39;, &#39;Larger&#39;), (&#39;Google&#39;, &#39;Larger&#39;), ]) df1.to_excel(writer, sheet_name=&#39;Book&#39;, index=False) df2.to_excel(writer, sheet_name=&#39;Website&#39;, index=False) writer.save() If you get into trouble that the script raises an Error ModuleNotFoundError: No module named 'xlwt', you need to run pip install xlwt to install the xlwt package. It is important to note that the xlwt package is no longer maintained, and the xlwt engine will been removed in a furture version of pandas.
At last, don&rsquo;t forget to use writer.save method to flush the buffers into the output file.
  ]]></content></entry><entry><title>Go Slice 的使用</title><url>/post/old/go-slice-usage/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>slice</tag><tag>翻译</tag></tags><content type="html"><![CDATA[  原文： Slices/arrays explained: create, index, slice, iterate 概述 slice 是 Go 中的一种数据结构，描述了底层实现 array 的部分信息，并不会真实地存储任何数据。
修改 slice 中的元素，实际上就是修改底层实现 array 中的元素，引用相同 array 的 slice 也会相应被修改； 1 2 3 4 5 6 7 8 9 func changeSliceElement() { s := []int{1, 2, 3} s1 := s s2 := s s[0] = 0 fmt.Println(s1) fmt.Println(s2) } 1 2 [0 2 3] [0 2 3] slice 会进行扩容和缩容； 1 2 3 4 5 6 7 8 9 func growSlice() { s := []int{0, 1, 2, 3} fmt.Printf(&amp;#34;slice 的长度为 %d，容量为 %d\n&amp;#34;, len(s), cap(s)) for i := 5; i &amp;lt; 10; i++ { s = append(s, i) fmt.Printf(&amp;#34;append %d 次，slice 的长度为 %d，容量为 %d\n&amp;#34;, i-4, len(s), cap(s)) } } 1 2 3 4 5 6 slice 的长度为 4，容量为 4 append 1 次，slice 的长度为 5，容量为 8 append 2 次，slice 的长度为 6，容量为 8 append 3 次，slice 的长度为 7，容量为 8 append 4 次，slice 的长度为 8，容量为 8 append 5 次，slice 的长度为 9，容量为 16 在第 5 次 append 后，slice 进行了扩容（以 2 为倍数）。
不同于 C 中的 realloc 方法，Go 中的 slice 没有直接的缩容方法，参考【1】中的给出了间接的方法示例。
1 2 3 4 5 6 7 func shrinkSlice() { s := []int{0, 1, 2, 3} fmt.Printf(&amp;#34;slice 的长度为 %d，容量为 %d\n&amp;#34;, len(s), cap(s)) s1 := …  ]]></content></entry><entry><title>Go Slice Roadmap</title><url>/post/old/go-slice-basic/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>slice</tag></tags><content type="html">  Roadmap for Go Slice.
  </content></entry><entry><title>扩展 Django forms.Field - 支持 default 属性</title><url>/post/old/python-django-parameter-validation-default/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Django</tag><tag>参数验证</tag><tag>Python</tag></tags><content type="html"><![CDATA[  django.forms 包提供了 HTML 表单验证的功能，在没有使用 DRF 的情况下，无法合理地处理 API 传参的验证，其中传参验证中就缺少了参数默认值的设置。
层次结构 django.forms 包提供的 Field 类如下：
1 2 3 4 5 6 7 8 9 10 __all__ = ( &#39;Field&#39;, &#39;CharField&#39;, &#39;IntegerField&#39;, &#39;DateField&#39;, &#39;TimeField&#39;, &#39;DateTimeField&#39;, &#39;DurationField&#39;, &#39;RegexField&#39;, &#39;EmailField&#39;, &#39;FileField&#39;, &#39;ImageField&#39;, &#39;URLField&#39;, &#39;BooleanField&#39;, &#39;NullBooleanField&#39;, &#39;ChoiceField&#39;, &#39;MultipleChoiceField&#39;, &#39;ComboField&#39;, &#39;MultiValueField&#39;, &#39;FloatField&#39;, &#39;DecimalField&#39;, &#39;SplitDateTimeField&#39;, &#39;GenericIPAddressField&#39;, &#39;FilePathField&#39;, &#39;JSONField&#39;, &#39;SlugField&#39;, &#39;TypedChoiceField&#39;, &#39;TypedMultipleChoiceField&#39;, &#39;UUIDField&#39;, ) 继承关系如下图：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Field: 字段基类 - InlineForeignKeyField: 关联模型的主键字段 - CharField: 字符串字段 - RegexField: 正则字符串字段 - UrlField: URL 字段 - SlugField: 是否允许 unicode 字符串 - GenericIPAdressField: IP 字段 - EmailField: 邮箱字段 - UUIDField: UUID 字段 - JSONField: JSON 字符串 - IntegerField: 整数字段 - FloatField: 浮点数字段 - DecimalField: 十进制小数字段 - BaseTemporalField: 表示时间 - DatelField: 日期字段 - TimeField: 时间字段 - DateTimeField: （日期、时间）字段 - DurationField: 时间段字段 - FileField: 文件字段 - ImageField: 图片字段 - BooleanField: 布尔字段 - NullBooleanField: 布尔字段（可为 null） - ChoiceField: 可选项字段 - ModelChoiceField: 模型选项字段（QuerySet） - ModelMultipleChoiceField: 模型选项字段（QuerySet，可多个） - TypedChoiceField: 可选项字段（强制类型） - MultipleChoiceField: 可选项字段（多选） - TypedMultipleChoiceField: 可选项字段（多选，强制类型） - FilePathField: 文件路径字段 - ComboField: 组合字段，同时使用多个字段验证器 - MultiValueField: 聚合多个字段的逻辑 - SplitDateTimeField: 多个时间值字段 基类 Field 的构造函数的声明如下：
1 2 3 def __init__(self, *, required=True, widget=None, label=None, initial=None, help_text=&#39;&#39;, error_messages=None, show_hidden_initial=False, validators=(), localize=False, disabled=False, label_suffix=None): initial 参数 其中有一个 initial 参数，可以用来表示 Form 渲染出的 HTML 代码中的显示值，但并不会给字段赋值，如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.http import HttpRequest, JsonResponse from django import forms class ExampleForm(forms.Form): name = forms.CharField(required=False, initial=&#39;a2htray&#39;) def django_forms_field_initial(request: HttpRequest): form = ExampleForm(request.GET) if form.is_valid(): data = form.cleaned_data print(&#39;data&#39;, data) print(form) else: print(form.errors) return JsonResponse({}) return JsonResponse({}) 请求该接口打印的信息如下：
1 2 data {&#39;name&#39;: &#39;&#39;} &lt;tr&gt;&lt;th&gt;&lt;label for=&#34;id_name&#34;&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=&#34;text&#34; name=&#34;name&#34; id=&#34;id_name&#34;&gt;&lt;/td&gt;&lt;/tr&gt; 可见，django 提供的 Field 类没有提供类似于默认值的功能。比如，当用户不能给出默认的 name 值时进行赋值。
自定义 default 参数 封装一个需要提供默认值功能的字段类，这里以 TypedChoiceField 为例，其中 TypedChoiceField._coerce 方法本身也提供了一定的验证功能，看源码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TypedChoiceField(ChoiceField): # ... def _coerce(self, value): if value == self.empty_value or value in self.empty_values: return self.empty_value # 需要的修改地方 try: value = self.coerce(value) except (ValueError, TypeError, ValidationError): raise ValidationError( self.error_messages[&#39;invalid_choice&#39;], code=&#39;invalid_choice&#39;, params={&#39;value&#39;: value}, ) return value def clean(self, value): value = super().clean(value) return self._coerce(value) 当传值解析为指定的 empty_value 或在 empty_values 中时，返回指定的默认值，其余不变。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyTypeChoiceField(forms.TypedChoiceField): def __init__(self, *, default=None, **kwargs): self.default = default super().__init__(**kwargs) def _coerce(self, value): if value == self.empty_value or value in self.empty_values: return self.default else: try: value = self.coerce(value) except (ValueError, TypeError, ValidationError): raise ValidationError( self.error_messages[&#39;invalid_choice&#39;], code=&#39;invalid_choice&#39;, params={&#39;value&#39;: value}, ) return value 那么在使用 MyTypedChoiceField 时可以指定 default 参数，如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 GENDER_CHOICES = ( (0, &#39;Male&#39;), (1, &#39;Female&#39;), ) class Payload(forms.Form): gender = MyTypeChoiceField(coerce=lambda p: int(p), choices=GENDER_CHOICES, required=False, default=0) def get_payload_validate(request: HttpRequest): payload = Payload(request.GET) if not payload.is_valid(): return JsonResponse({ &#39;errors&#39;: payload.errors, }) payload = payload.cleaned_data return JsonResponse(payload) 不带任何参数值请求该接口时的返回如下：
1 2 3 { &#34;gender&#34;: 0 } 不同的 Field 子类也可进行类似的继承再修改。
  ]]></content></entry><entry><title>Go 的错误处理</title><url>/post/old/go-error-handling/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>翻译</tag></tags><content type="html">  原文： Error handling and Go 介绍 如果你写过 Go 的代码，就一定遇到过 Go 的内置类型 error。一个 error 类型的值可用于指明程序的某种不正常的状态，比如，当打开文件失败时，os.Open 函数会返回一个非 nil 的 error 值。
1 func Open(name string) (file *File, err error) 下面代码演示了：使用 os.Open 打开一个文件失败时，用 log.Fatal 来打印错误信息和停止程序运行。
1 2 3 4 5 f, err := os.Open(&amp;amp;#34;filename.ext&amp;amp;#34;) if err != nil { log.Fatal(err) } // do something with the open *File f 只要知道上述一点关于 error 的内容，在 Go 中就可以做很多事，但在这篇文章中，我们会进一步地讨论 error 类型以及 Go 处理错误的最佳实践。
error 类型 error 类型是一种接口类型，error 值可以是任意被字符串所能表示的值，下方是接口的定义：
1 2 3 type error interface { Error() string } 与其它内置类型一样，error 类型也是提前定义，并且全局有效的。
使用的最多的 error 实现是 errors 包中的未导出类型 errorString：
1 2 3 4 5 6 7 8 // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 你可以使用 errors.New 函数构建一个 error 值，该函数会把一个字符串转换成一个 errorString，返回值是一个 error 类型。
1 2 3 4 // New returns an error that formats as the given text. func New(text string) error { return &amp;amp;amp;errorString{text} } 下面是使用 …  </content></entry><entry><title>Python PAT 甲级 1003</title><url>/post/old/python-pat-1004/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT</tag></tags><content type="html"><![CDATA[  PAT 甲级 1003 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # -*- coding:utf-8 -*- if __name__ == &#39;__main__&#39;: # n 树中节点个数 # m 非叶子节点个数 n, m = list(map(int, input().strip().split(&#39; &#39;))) # 二维数组 # 元素的下标表示节点的 ID # 第 1 个元素不使用 tree = [[] for _ in range(n+1)] while m != 0: tokens = list(map(int, input().split(&#39; &#39;))) _id = tokens[0] children = tokens[2:] tree[_id] = children m = m - 1 # 记录每一层叶子节点的数量 counts = [0 for _ in range(n+1)] # 记录最大深度 max_depth = 0 def dfs(i, depth): global max_depth, counts, tree if len(tree[i]) == 0: # 节点 i 为叶子节点 counts[depth] = counts[depth] + 1 max_depth = max(depth, max_depth) return for j in tree[i]: dfs(j, depth + 1) dfs(1, 0) print(&#39; &#39;.join([str(count) for count in counts[:max_depth+1]])) 测试点 4 没过，应该是没有理解 The input ends with N being 0. That case must NOT be processed. 的原因，因为不知道要输出什么。
  ]]></content></entry><entry><title>Python PAT 甲级 1003</title><url>/post/old/python-pat-1003/</url><categories><category>算法</category><category>PAT</category></categories><tags><tag>PAT</tag></tags><content type="html"><![CDATA[  PAT 甲级 1003 。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 # -*- coding:utf-8 -*- import sys MAX_INT = sys.maxsize if __name__ == &#39;__main__&#39;: # m 城市个数 # n 路径条数 # start 起始城市下标 # end 结束城市下标 m, n, start, end = map(int, input().strip().split(&#39; &#39;)) # nums_of_teams 各城市救援队的数量 nums_of_teams = list(map(int, input().strip().split(&#39; &#39;))) assert m == len(nums_of_teams) # 城市间的路径矩阵 roadmap = [ [MAX_INT for _ in range(m)] for _ in range(m) ] # 根据输入初始化 roadmap while n != 0: i, j, d = map(int, input().strip().split(&#39; &#39;)) roadmap[i][j] = d roadmap[j][i] = d # 对角矩阵表示无向图 n = n - 1 roadmap[start][start] = 0 # 测试点中的起始城市和结束城市可能相同 # 起始城市到其余城市最短路径条数 nums_of_short_paths = [0 for _ in range(m)] # 保存访问记录, 0 表示未访问, 1 表示已访问 visited = [0 for _ in range(m)] # 起始城市到其余城市最短路径 dists = [MAX_INT for _ in range(m)] # 起始城市到其余城市在最短路径的基础上, 各路径上城市救援队个数的和 weights = [0 for _ in range(m)] # 初始状态 nums_of_short_paths[start] = 1 # 起始城市到自己, 表示有 1 条 dists[start] = 0 weights[start] = nums_of_teams[start] for i in range(m): u = -1 min_d = MAX_INT # 在剩余未访问的城市中, 找到距离起始城市最近的城市 for j in range(m): if visited[j] == 0 and dists[j] &lt; min_d: min_d = dists[j] u = j if u == -1: break visited[u] = 1 # 第 1 次找到的必然是起始城市 for k in range(m): # for 循环用于计算： # &gt; 已访问城市到未访问城市的最短路径之和 if visited[k] == 0 and roadmap[u][k] != MAX_INT: # 已访问城市与未访问城市之间必须具有连通性 if dists[u] + roadmap[u][k] &lt; dists[k]: dists[k] = dists[u] + roadmap[u][k] nums_of_short_paths[k] = nums_of_short_paths[u] weights[k] = weights[u] + nums_of_teams[k] elif dists[u] + roadmap[u][k] == dists[k]: nums_of_short_paths[k] = nums_of_short_paths[k] + nums_of_short_paths[u] if nums_of_teams[k] + weights[u] &gt; weights[k]: weights[k] = weights[u] + nums_of_teams[k] print(f&#39;{nums_of_short_paths[end]} {weights[end]}&#39;, end=&#39;&#39;)   ]]></content></entry><entry><title>静态资源的管理-文件复制</title><url>/post/doc-stackoverflow/nodejs-fs-copyfile/</url><categories><category>后端技术</category><category>Nodejs</category></categories><tags><tag>stackoverflow</tag><tag>Node.js</tag></tags><content type="html"><![CDATA[  这是一个简单的 Node.js 的 API 的使用示例：如何基于 Node.js 的完成文件的复制。
问题起源
该问题源起于一个前后端不分离项目的前端静态资源如 JS、CSS 文件的管理。考虑到要对第三方静态资源的修改非常少且需要对其进行版本管理，所以想到使用 npm 对其进行管理。
步骤
实施的步骤如下：
使用 npm install PACKAGE_NAME 下载到本地； 在 package.json 中配置发布脚本； 发布脚本的作用是将 PACKAGE_NAME 中的静态资源复制到指定目录； stack overflow
stack overflow 的问题：在 Node.js 中，如何快速地复制文件。高赞答案提供了两种实现方式：
使用 fs.copyFile； 1 2 3 4 5 6 7 const fs = require(&#39;fs&#39;); // File destination.txt will be created or overwritten by default. fs.copyFile(&#39;source.txt&#39;, &#39;destination.txt&#39;, (err) =&gt; { if (err) throw err; console.log(&#39;source.txt was copied to destination.txt&#39;); }); 流的读取与写入； 1 2 const fs = require(&#39;fs&#39;); fs.createReadStream(&#39;test.log&#39;).pipe(fs.createWriteStream(&#39;newLog.log&#39;)); 在项目中使用
在项目中，则是预先定义一系列的资源文件的源地址与目标地址，通过 fs.copyFile 完成复制操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const fs = require(&#39;fs&#39;) const universalFromPrefix = (path) =&gt; &#39;./node_modules/&#39; + path const universalToPrefix = (path) =&gt; &#39;./static/&#39; + path const resources = { bootstrap: [ { from: universalFromPrefix(&#39;bootstrap/dist/js/bootstrap.min.js&#39;), to: universalToPrefix(&#39;js/bootstrap.min.js&#39;), }, { from: universalFromPrefix(&#39;bootstrap/dist/js/bootstrap.min.js.map&#39;), to: universalToPrefix(&#39;js/bootstrap.min.js.map&#39;), }, { from: universalFromPrefix(&#39;bootstrap/dist/css/bootstrap.min.css&#39;), to: universalToPrefix(&#39;css/bootstrap.min.css&#39;), }, { from: universalFromPrefix(&#39;bootstrap/dist/css/bootstrap.min.css.map&#39;), to: universalToPrefix(&#39;css/bootstrap.min.css.map&#39;), }, ] } for (let resKey in resources) { let resource = resources[resKey] console.log(`copy resource ${resKey}`) for (let i = 0; i &lt; resource.length; i++) { let {from, to} = resource[i] fs.copyFile(from, to, (err) =&gt; { if (err) throw err console.log(`=&gt; copy ${from} to ${to}`) }) } } 好处
包的下载依赖于 npm，无须手动地下载特定的静态资源。
  ]]></content></entry><entry><title>SQL 转义问题</title><url>/post/old/go-sql-escape/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>sqlx</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[  SQL 转义问题是指执行的 SQL 语句中包含了某些特定的字符，如单引号 &#39;、反斜杠 \ 等，导致 SQL 语句不能正常执行。所以，我们应该在拼接 SQL 语句的过程中对特别的传入参数进行转义。
环境信息：
MySQL 8.0.28； Go 1.16.9 windows/amd64 问题发生 创建一个示例表 test，然后执行多条 SQL 语句：
1 2 3 CREATE TABLE IF NOT EXISTS test ( content text ) ENGINE = InnoDB; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( &amp;#34;fmt&amp;#34; _ &amp;#34;github.com/go-sql-driver/mysql&amp;#34; &amp;#34;github.com/jmoiron/sqlx&amp;#34; &amp;#34;log&amp;#34; ) func main() { dsn := &amp;#34;root:password$@tcp(127.0.0.1:3306)/database&amp;#34; db, err := sqlx.Connect(&amp;#34;mysql&amp;#34;, dsn) if err != nil { log.Fatalln(err) } // 元素的第 1 个反斜杠负责 Go 中字符串的转义 contentSet := []string{ &amp;#34;content1&amp;#39;&amp;#34;, &amp;#34;content2\&amp;#34;&amp;#34;, &amp;#34;content3\\&amp;#34;, } for _, content := range contentSet { insertStmt := &amp;#34;INSERT INTO test VALUES (&amp;#39;&amp;#34; + content + &amp;#34;&amp;#39;);&amp;#34; fmt.Println(&amp;#34;insert statement:&amp;#34;, insertStmt) _, err := db.Exec(insertStmt) if err != nil { log.Println(err) } } } 1 2 3 4 5 insert …  ]]></content></entry><entry><title>与 image 概念相关的命令</title><url>/post/old/docker-roadmap-image/</url><categories><category>后端技术</category><category>Docker</category></categories><tags><tag>roadmap</tag><tag>Docker</tag><tag>docker image</tag></tags><content type="html">  Docker 命令快速查询，收集了与 docker image 相关的命令及部分示例。
roadmap   </content></entry><entry><title>channel 的方向</title><url>/post/old/go-channel-direction/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>channel</tag></tags><content type="html"><![CDATA[  在回忆管道方向的语法上时不时地会出错，所以搜罗一些资料以加强自身的记忆。
基础 channel 是 Go 提供同步的、强类型的消息传输功能的一种数据结构，搭配上 goroutine，构建了 Go 的 Communicating Sequential Processes（CSP）并发模型。
channel 和 goroutine 是 Go 的 CSP 并发模型的基石。
定义一个 channel 只需要一个 chan 关键字及 channel 中传输的元素的类型，如：
1 2 3 var c chan int // 或 c := make(chan int) 默认情况下，channel 的双向的，即 channel 的一端可读、另一端可写。因为没有定义 channel 的方向，在编写程序的过程中，很有可以向一个已关闭的 channel 发送信息。比较优的编码实践应该在代码中指定 channel 的方向。
channel 的方向 操作符 &lt;- 用于指定 channel 是方向，表示读或写的操作。由此可知，声明一个 channel 有 3 种方式：
1 2 3 var c chan int // 双向 var c &lt;-chan int // 只能读 var c chan&lt;- int // 只能写 记忆方式：
1 2 &lt;-chan // 从 channel 中来 chan&lt;- // 到 channel 中去 值得注意的是，一开始的 channel 声明可以是双向的，并且可以作为参数的过程中指定 channel 的方法，这样就可以避免在读取 channel 的过程中关闭 channel（因为只有写 channel 的代码才有权限关闭 channel）。
只读的 channel 不能被关闭。
在函数签名中，也应该使用带有方向的 channel 作为参数类型或返回值类型，除非在某一函数中完全使用双向的 channel。
1 2 3 4 5 6 7 8 9 func ReturnReadOnly() &lt;-chan int { c := make(chan int) // ... return c } // 因为 ReturnReadOnly 返回的是只读的 channel，所以 readOnly 是只读的 // 但在 ReturnReadOnly 函数中声明的是一个双向的 channel `c := make(chan int)` readOnly := ReturnReadOnly() 使用带方向的 channel 的好处：
事先声明 channel 的读写性质； 编写的 channel 相关代码语义明显； 参考 Directional Channels in Go   ]]></content></entry><entry><title>Go&MySQL`max_allowed_packet`</title><url>/post/old/go-max-allowed-packet/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>MySQL</tag><tag>Go</tag></tags><content type="html"><![CDATA[  当发送给数据库的语句过大时，会报如下错误：
1 panic: Error 1105: Parameter of prepared statement which is set through mysql_send_long_data() is longer than &#39;max_allowed_packet&#39; bytes 从报错中可知，需要修改 max_allowed_packet 选项的值。
my.cnf 在 my.cnf 配置文件中修改该选项是最直接了当的，修改成合适的值后重启服务即可。
1 2 [mysqld] max_allowed_packet=16M 会话 当打开一个会话时，也可以使用下面的语句设置全局或当前的 max_allowed_packet 值。
1 2 SET GLOBAL max_allowed_packet=1073741824; SET max_allowed_packet=1073741824; 第 1 个在服务重启后失效，第 2 个在会话结束会失效。
go-sql-driver/mysql 更多情况下，还是希望在程序中控制该选项，所以要看下使用的数据库驱动是否支持该选项。很庆幸，go-sql-driver/mysql 是支持的，使用的版本如下：
1 go-sql-driver/mysql@v1.6.0 在使用 gorm 中，返回一个 *gorm.DB 实例，我们都会使用下面的代码：
1 db, err := gorm.Open(mysql.Open(&#34;username:password@tcp(host:port)/database?queryString&#34;), &amp;gorm.Config{}) 下面说一下整行代码的执行顺序：
mysql.Open 简单返回一个实现 gorm.Dialector 接口的实例（只是简单的赋值，并没有作解析）； gorm.Open 会调用 Dialector.Initialize 方法，并且会真正地打开数据库连接； 1 db.ConnPool, err = sql.Open(dialector.DriverName, dialector.DSN) 在 sql.Open 中会调用； 1 connector, err := driverCtx.OpenConnector(dataSourceName) 在 driverCtx.OpenConnector 中会调用 ParseDSN 方法； ParseDSN 完成了对 DSN 的解析，包括 queryString 部分； 即：
1 2 3 4 mysql.Open \ \ gorm.Open -&gt; Dialector.Initialize -&gt; sql.Open -&gt; driverCtx.OpenConnector -&gt; ParseDSN go-sql-driver/mysql 支持的 query 参数包括如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 allowAllFiles allowCleartextPasswords allowNativePasswords allowOldPasswords checkConnLiveness clientFoundRows collation columnsWithAlias compress # 这个是没有实现的 interpolateParams loc multiStatements parseTime readTimeout rejectReadOnly serverPubKey strict timeout tls writeTimeout maxAllowedPacket 参考 max_allowed_packet in mySQLmax_allowed_packet in mySQL   ]]></content></entry><entry><title>IDE 代码显示无引用 no usages found</title><url>/post/old/ide-no-usages-found/</url><categories><category>生产力工具</category><category>JetBrains</category></categories><tags><tag>JetBrains</tag></tags><content type="html">  IntelliJ IDEA 代码显示灰色，表示无任何引用，实际上是有引用。出现这种问题，非常不易于 DEBUG。
解决方法：File -&amp;gt; Invalidate Caches &amp;hellip;
勾选：
Clear file system cache and Local History Ask before downloading new shared indexes   </content></entry><entry><title>Go Map</title><url>/post/old/go-map-detail/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>map</tag></tags><content type="html">  Go 中 map 是键值对的关联容器（Associative Container），可以存储不同类型的键值对，其中键的类型需要满足可比较（==）特性。
基本操作 map 的基本操作如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 构造 m := make(map[key]value) // or m := map[key]value{} // 插入 m[k] = v // 查找 v = m[k] // 删除 delete(m, k) // 遍历 for k, v := range m // 长度 len(m) 简单实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type element struct { k int64 v string } type map []element func (m map) Lookup(k int64) string { for _, e := range m { if e.k == k { return e.v } } return &amp;amp;#34;&amp;amp;#34; } 上述实现的 map 如果数据规模过大，查找元素的速率会变得很慢。由此，一个加快查找的思想是将多个元素划分到一个子集，即一个桶（bucket），根据 key 值查找到 bucket 的时间复杂度要到 O(1)，从而提前过滤了无关的数据。但为了避免同一个 bucket 存储过多数据，所以要找一个使类似 key 值达到均匀分布的哈希函数。一个好的哈希函数的标准应该是与 key 值的分布无关的，这样才能使用元素各均匀的分布。
哈希函数 哈希函数的必须满足以下条件：
对于唯一确定的值，函数的输出也应该是唯一确定的，不存在同一值有两个不同的输出； 函数的输出值应该服从均匀分布； 计算速度快； Go Map Go 的 map 结构如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // hmap Go map 的头 type hmap struct { // key-value 的个数 count int flags uint8 // B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B …  </content></entry><entry><title>Slice 什么时候报 out of range</title><url>/post/old/go-slice-out-of-range/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>slice</tag><tag>stackoverflow</tag><tag>面试经</tag></tags><content type="html"><![CDATA[  面试的时候问到了一个关于 go Slice 的问题，即为什么在 a[i:] 中 i 的取值可以是 a 的长度。平时开发中也是这么用的，但没太深入的了解，所以在这篇文章中对其进行一些探讨。
slice 删除元素 Go 标准内置包没有提供太多操作 slice 的方法，所以如果要删除 slice 的元素通常都能找到以下的实现。
1 2 3 func remove(slice []int, s int) []int { return append(slice[:s], slice[s+1:]...) } 这里就引发出一个疑问：当要删除最后一个元素时，s+1 不就等于 slice 的长度了，但程序为什么没有报 index out of range 错误。
两种表达式的官方解释 官方对于 a[i] 和 a[low:high]有不同的定义，分别为索引表达式 和 slice 表示式，所以两者并非一个东西。
a[i] 表达式
下标的取值范围在 $0 \le i \lt len(a)$，如果超出了会报 out of range 运行时错误。
a[low:high] 表示式
对于数组或字符串，下标的取值范围在 $0 \le low \le high \le len(a)$，即下标可以取到数组的长度或字符串的长度。对于 slice 来说，下标的取值上限是 slice 的容量，显然 slice 的容量会大于等于其长度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( &amp;#34;fmt&amp;#34; ) func main() { ints := make([]int, 0) for i := 0; i &amp;lt; 3; i++ { ints = append(ints, i) } fmt.Printf(&amp;#34;length: %d, capacity: %d\n&amp;#34;, len(ints), cap(ints)) fmt.Println(ints[3:4]) } 1 2 length: 3, capacity: 4 [0] ints 的容量为 4，所以 ints[3:4] 符合定义。另外，扩容操作只有在使用 append 方法后才会执行，正常初始化的 slice 的长度与容量相同，如下：
1 2 3 4 5 6 7 8 …  ]]></content></entry><entry><title>MySQL 修改列的注释信息</title><url>/post/doc-stackoverflow/mysql-modify-table-column-comment/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>stackoverflow</tag><tag>MySQL</tag></tags><content type="html">  小小的修改列的注释信息也能引发一些思考。
正确的修改方式要带上原来列的定义，如：
1 ALTER TABLE `user` CHANGE `id` `id` INT( 11 ) COMMENT &amp;#39;id of user&amp;#39;; 高票答案的几个回复：
Note that altering a comment will cause a full resconstruction of the table. So you may choose to live without it on very big table.
修改列注释会重构表 （对于大表慎用）
That is not (or no longer) true, as long as the column definition matches the existing definition exactly. Comments can be added without causing table reconstruction.
如果和之前的列定义一致，修改列注释不会重构表
Alter MySQL table to add comments on columns   </content></entry><entry><title>go module 使用本地开发的包</title><url>/post/doc-stackoverflow/go-use-local-module-in-development/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>stackoverflow</tag><tag>go module</tag></tags><content type="html"><![CDATA[  在 go.mod 文件中新增 replace 信息，内容如下：
1 2 3 4 module github.com/userName/mainModule require &#34;github.com/userName/otherModule&#34; v0.0.0 replace &#34;github.com/userName/otherModule&#34; v0.0.0 =&gt; &#34;本地包路径&#34; Accessing local packages within a go module (go 1.11)   ]]></content></entry><entry><title>Windows 下移动文件的坑</title><url>/post/old/go-file-rename-pit/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>file</tag><tag>I/O</tag><tag>Stackoverflow</tag></tags><content type="html"><![CDATA[  在 Windows 下，Go 的 os 标准库提供的 Rename 方法不能跨磁盘移动文件。下面通过问题重现，提供两种解决方案。
问题重现 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &#34;fmt&#34; &#34;os&#34; ) func main() { err := os.Rename(&#34;D:\\black.txt&#34;, &#34;E:\\black-new.txt&#34;) if err != nil { fmt.Println(err) } } 执行上面的代码后报错。
1 rename D:\black.txt E:\black-new.txt: The system cannot move the file to a different disk drive. 从源码中可知，Windows 平台有专门实现的 file_windows.go ：
1 2 3 4 5 6 7 8 // file_windows.go func rename(oldname, newname string) error { e := windows.Rename(fixLongPath(oldname), fixLongPath(newname)) if e != nil { return &amp;LinkError{&#34;rename&#34;, oldname, newname, e} } return nil } 1 2 3 4 5 6 7 8 9 10 11 12 // syscall_windows.go func Rename(oldpath, newpath string) error { from, err := syscall.UTF16PtrFromString(oldpath) if err != nil { return err } to, err := syscall.UTF16PtrFromString(newpath) if err != nil { return err } return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING) } 1 2 3 4 5 6 7 8 // zsyscall_windows.go func MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) { r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(flags)) if r1 == 0 { err = errnoErr(e1) } return } 可见，最终移的动操作是通过系统调用完成的，其中 Rename 方法调用了两次 syscall.UTF16PtrFromString 方法，返回了两个 *uint16 类型的值，再使用 MoveFileEx 方法完成移动。
syscall 查看 zsyscall_windows.go 提供的方法，还有一个 MoveFile 可以尝试，所以就有了以下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &#34;fmt&#34; &#34;syscall&#34; ) func main() { oldpath := &#34;D:\\black.txt&#34; newpath := &#34;E:\\black-new.txt&#34; from, _ := syscall.UTF16PtrFromString(oldpath) to, _ := syscall.UTF16PtrFromString(newpath) fmt.Println(*from, *to) err := syscall.MoveFile(from, to) if err != nil { panic(err) } } 1 68 69 移动操作是成功完成的。
stackoverflow 同时在 stackoverflow 上，也有开发者提供了移动实现。该实现的过程是借助一个中间文件，比如要移动文件到 E 盘，则先在 E 盘创建一个目标文件（os.Create），再把源文件的内容写入到目标文件（os.Copy），最后删除源文件（os.Remove），代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( &#34;fmt&#34; &#34;io&#34; &#34;os&#34; ) func MoveFile(sourcePath, destPath string) error { inputFile, err := os.Open(sourcePath) if err != nil { return fmt.Errorf(&#34;Couldn&#39;t open source file: %s&#34;, err) } outputFile, err := os.Create(destPath) if err != nil { inputFile.Close() return fmt.Errorf(&#34;Couldn&#39;t open dest file: %s&#34;, err) } defer outputFile.Close() _, err = io.Copy(outputFile, inputFile) inputFile.Close() if err != nil { return fmt.Errorf(&#34;Writing to output file failed: %s&#34;, err) } // The copy was successful, so now delete the original file err = os.Remove(sourcePath) if err != nil { return fmt.Errorf(&#34;Failed removing original file: %s&#34;, err) } return nil } 跨平台支持 如果希望应用能够在多个平台上正常运行，可以创建 file.go 和 file_windows.go，分别为不同平台要编译的源代码，也可以创建一个方法，在方法中对平台进行判断。
1 2 3 4 5 6 7 8 9 func MoveFile(src string, dst string) error { if runtime.GOOS == &#34;windows&#34; { from, _ := syscall.UTF16PtrFromString(src) to, _ := syscall.UTF16PtrFromString(dst) return syscall.MoveFile(from, to) } else { return os.Rename(src, dst) } } 参考 stackoverflow: Move a file to a different drive with Go   ]]></content></entry><entry><title>URL 下载网络文件</title><url>/post/old/go-download-network-file/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>HTTP</tag><tag>I/O</tag></tags><content type="html"><![CDATA[  从网络上下载文件是开发过程中常用的需求，常规流程是：（1）发送请求；（2）接收响应并读取响应体内容；（3）保存到本地文件。本文包含的两个例子分别来自于参考 [1] 和参考 [2]，在此基础上做了少量的修改。
例 1 普通下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( &#34;fmt&#34; &#34;io&#34; &#34;net/http&#34; &#34;os&#34; ) func main() { fileUrl := &#34;https://golangcode.com/logo.svg&#34; filename := &#34;logo.svg&#34; resp, err := http.Get(fileUrl) if err != nil { panic(err) } defer resp.Body.Close() out, err := os.Create(filename) if err != nil { panic(err) } _, err = io.Copy(out, resp.Body) if err != nil { panic(err) } fmt.Println(&#34;Downloaded: &#34; + fileUrl) } 例 1 中使用了 io.Copy 方法将响应体内容复制到目标文件。io.Copy 是带缓冲的复制，可以避免在内存中堆积大量的数据，类似的方法还有 io.CopyBuffer。
1 2 3 4 5 6 7 8 9 func Copy(dst Writer, src Reader) (written int64, err error) { return copyBuffer(dst, src, nil) } func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) { if buf != nil &amp;&amp; len(buf) == 0 { panic(&#34;empty buffer in CopyBuffer&#34;) } return copyBuffer(dst, src, buf) } 例 2 带进度的下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( &#34;fmt&#34; &#34;github.com/dustin/go-humanize&#34; &#34;io&#34; &#34;net/http&#34; &#34;os&#34; &#34;strings&#34; ) type Progress struct { total uint64 } func (p *Progress) Write(bs []byte) (n int, err error) { n = len(bs) p.total += uint64(n) p.Show() return n, nil } func (p Progress) Show() { fmt.Printf(&#34;\r%s&#34;, strings.Repeat(&#34; &#34;, 35)) fmt.Printf(&#34;\rDownloading... %s complete&#34;, humanize.Bytes(p.total)) } func main() { fileUrl := &#34;https://golangcode.com/logo.svg&#34; filename := &#34;logo.svg&#34; resp, err := http.Get(fileUrl) if err != nil { panic(err) } defer resp.Body.Close() out, err := os.Create(filename) if err != nil { panic(err) } defer out.Close() if _, err = io.Copy(out, io.TeeReader(resp.Body, &amp;Progress{})); err != nil { panic(err) } } 与例 1 的不同之处在于 io.Copy 的第 2 参数换成了一个 io.teeReader 的对象。下面是 io.teeReader 的定义：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 type teeReader struct { r Reader w Writer } func (t *teeReader) Read(p []byte) (n int, err error) { n, err = t.r.Read(p) if n &gt; 0 { if n, err := t.w.Write(p[:n]); err != nil { return n, err } } return } teeReader 实现了 Reader 接口，而在 Read 方法中保留了原先读取数据的操作，新增了一个写数据的操作。Progress 实现了 Writer 接口，正好可以作为 teeReader 的 w 字段的值，所以在执行 Read 的过程中会调用 Progress.Write 方法，从而可以知道已经读取数据的大小。最后用 Progress.Show 方法将 total 字段的值输出到终端。
参考 GolangCode: Download a File (from a URL) GolangCode: Download Large Files with Progress Reports   ]]></content></entry><entry><title>Redis 的 list 和 stream：异步记录请求信息</title><url>/post/old/go-redis-request-log-dumper/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag><tag>logging</tag><tag>Gin</tag><tag>Go</tag></tags><content type="html">  在 Web 开发中，常常需要对请求信息进行记录，形成日志以便于后期评估应用的性能。请求信息通常包含客户端地址、请求的 URL、请求时间及请求执行时间。在程序中，可以以同步或异步的方式完成这一需求。同步方式是指请求信息写入日志文件后才返回数据给客户端，异步方式则是在返回数据之前以新线程或进程完成对请求信息的记录。开源的日志包有：
Zap ：出自 Uber 团队，以高性能著称； Zerolog ：以易用性著称，支持 7 种日志级别； Logrus ：兼容标准日志包格式，也是本人常用的日志包； apex/log ：受 Logrus 启发，简化操作后的 Logrus； Log15 ：日志可读性强； 5 个日志包的详细介绍可以看 《5 种结构化 Go 日志包对比分析》 这篇文章。
在 Go 开发中，一个非常简单的办法就是启用一个 goroutine 将请求信息发送到目的地，目的地可以是（1）一个日志文件；（2）一个 channel 或其它的应用（如 Redis）。在第 2 种方法中，还需要另一个拉取日志信息的服务，这类方法的优势是可以提高主体应用的性能，缺点是增加了系统的复杂度。本文的重点落在两个方面，分别为：
解析请求，将信息发送到 Redis 服务器； 读取 Redis 服务器中的请求信息，持久化到日志文件； 所以在本次实现中，包含两个组件（app 组件和 micro-dumper 组件）分别完成上述两项功能。
app 首先需要一个 Record 类型来描述请求信息，其结构如下：
1 2 3 4 5 6 7 8 // Record Represent a set of a Request passing from the client type Record struct { RemoteAddr string URL string AccessTime int64 TimeExecuted int64 BodyBytesSent int64 } 在 Redis 端，我们也需要两种数据结构，分别为 Stream 和 List。Stream 可以用来保存请求的信息，而 List 则是用保存 Stream 中请求信息的 ID。
当前 Redis 不支持以位置索引的方式访问 Stream 中的信息。 Stackoverflow 接着定义两种数据类型的键名：
1 2 const …  </content></entry><entry><title>Go 的反射包 reflect</title><url>/post/old/go-set-value-via-reflect-package/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>reflect</tag><tag>反射</tag></tags><content type="html"><![CDATA[  首先贴上 Go 开发团队对 reflect 包的描述：
Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.
A call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type.
从描述中，我们得到以下几点：
reflect 包实现了运行时的反射机制，允许程序操作任意类型的对象； TypeOf 可以得到一个 interface{} 的具体类型，ValueOf 可以得到一个 interface{} 的具体值； 重要类型 reflect 包中定义了几种重要的、常用的类型，分别为：
Kind； Value； SliceHeader； StringHeader； Method； StructField； Kind Kind 类型用于修饰类型 Type，用于表示 Type 的种类，底层是用一个无符号整数表示：
1 type Kind uint; 其中修饰了的基础数据类型包括Bool、Int、Int32、Float32、Float64 等，引用数据类型包括Slice、Map、Chan、Interface、Func 等。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var v1 int = 1 var v2 float32 = 1.0 v3 …  ]]></content></entry><entry><title>MySQL 设置存储引擎的 3 种方法</title><url>/post/old/mysql-set-storage-engine/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>存储引擎</tag></tags><content type="html">  在 MySQL 5.5 之前，默认存储引擎为 MyISAM，之后版本的默认存储引擎为 InnoDB。
选择一个合适的存储引擎至关重要。
存储引擎 根据是否支持事务，MySQL 的存储引擎可以分为：
事务型； 非事务型； 表 1 为 MySQL 支持的所有存储引擎以及各存储引擎的基本介绍。
表 1 不同的存储引擎
存储引擎 支持事务 特点 适用场景 InnoDB 是 1. 支持行锁、灾难恢复、多版本并发控制；
2. 支持外键、字段约束； 1. 适用于绝大部分场景； MyISAM 否 1. 读写速度快；
2. 支持表锁；
3. 支持 B 树索引、聚簇索引、全文搜索索引；
4. 支持地理数据及其索引；
5. 不支持哈希索引、外键、多版本并发控制；
6. 存储限制为 256TB； 1. 读写频繁的应用；
2. 数据仓库； Memory 否 1. 内存数据库；
2. 相较于 MyISAM，读写速度更快；
3. 支持表锁；
4. 非持久化数据；
5. 不支持多版本并发控制； 1. 快存快取 CSV 否 1. 通用格式，易于集成；
2. 不支持索引；
3. 不支持分区；
4. 表的所有字段都要设置 not null / Merge 否 1. 底层使用 MyISAM 存储引擎；
1. 数据仓库
Archive 否 1. 插入数据后，数据会被压缩； 1. 存储历史数据； Federated 否 1. 集群式管理 MySQL 实例；
1. 分布式环境； Blackhole 否 1. 可以向表插入数据，但查询只会返回空结果；
2. 支持所有的索引类型；
3. 不支持分区； / Example 否 啥也不是存储引擎 / 设置方法 以 InnoDB 为例，可通过以下 3 种方法设置表的存储引擎：
my.cnf 配置项； SET STORAGE_ENGINE； 创建表时； my.cnf 配置项 在 my.cnf 文件或其它引入的配置中，修改 [mysqld] 中的 default-storage-engine 的值，如：
1 2 [mysqld] default-storage-engine = InnoDB SET STORAGE_ENGINE 在执行脚本文件前，先通过 SET 设置使用的存储引擎：
1 SET STORAGE_ENGINE = InnoDB; 创建表时 在创建数据库表时，指定 ENGINE：
1 2 3 CREATE TABLE IF NOT EXISTS test_name ( id int ) ENGINE = InnoDB; 总结 MySQL 支持多种不同的存储引擎，InnoDB 存储引擎适用于绝大多数场景，并且支持事务、多版本并发控制； 可以在 3 个层次上对存储引擎进行修改，即： 服务器层，my.cnf 配置项； 会话层，在当前会话中使用 SET 设置存储引擎； 脚本层，在创建或修改表时声明存储引擎； 参考 MySQL storage engines 官方文档 Alternative Storage Engines   </content></entry><entry><title>MySQL 存储过程</title><url>/post/old/mysql-writing-procedure/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>存储过程</tag></tags><content type="html"><![CDATA[  存储过程是存储在数据库中并且已经提前编译好的 SQL 语句集合，它是应用中数据操作的部分逻辑实现。MySQL 5 版本引入了这一设计，存储过程包含 3 个部分：
名称； 参数列表； SQL 语句； 特性 存储过程包含了诸多特性，主要包括：
性能提升：存储过程是预先编译好、存储好的 SQL 语句集合，没有 SQL 词法/语法解析、编译的过程； 减少网络流量：客户端无须发送大量 SQL 语句到数据库，只需要提供存储过程名称和参数列表即可； 可重用：存储过程的逻辑一般都是常规周期性的逻辑操作，可重复使用； 安全性强：网络上传输的数据不包含具体的操作信息，可以为存储过程设置用户操作权限； 基本语法 在 MySQL 中，创建一个存储过程的语法如下：
1 2 3 4 5 6 7 DELIMITER &amp;amp;&amp;amp; CREATE PROCEDURE procedure_name [[IN | OUT | INOUT] parameter_name datatype [, parameter datatype]) ] BEGIN -- 定义变量 ... -- 执行逻辑 ... END &amp;amp;&amp;amp; DELIMITER ; 创建存储过程时，可以使用 DELIMITER 指定分隔符，这样就可以在存储过程依然使用冒号 ; 作为语句的分隔符。
IN | OUT | INOUT 为参数的类型，分别表示：
IN：参数只作为输入，存储过程内部不允许对其进行修改； OUT：参数只作为输出，存储过程内部可以对其修改，但没办法访问其初始值； INOUT：同时兼具 IN 和 OUT 类型参数的特性； 在终端执行存储过程的命令如下：
1 CALL procedure_name (参数列表); 使用 CALL 关键字执行存储过程； 如果有参数，需要在括号内指定，使用逗号分隔； 与 PostgreSQL 不同，MySQL 不支持下面语法：
1 CREATE OR REPLACE procedureName; 要想实现相同的效果，需编写如下语句：
1 2 3 4 DROP PROCEDURE IF EXISTS procedureName; ... CREATE PROCEDURE procedure_name ... ... 条件判断：
1 2 3 4 5 6 7 8 9 10 11 12 13 …  ]]></content></entry><entry><title>CSIG 线上面试</title><url>/post/old/interview-csig/</url><categories><category>生活感想</category></categories><tags><tag>面试经</tag><tag>大数除法</tag></tags><content type="html"><![CDATA[  有幸搞了个 CSIG 的线上面试，感觉是“没什么感觉”，一般般吧，没过。
前面介绍什么就不说了，我这边没突出什么工作亮点，然后就直接共享桌面写代码了。题目是编程实现一个由字符串数组表示的大数的除以 9 的计算，后面又追问了小数点后值如何保存，所以索性在线下实现也写了写。
其实，对于这种手撕算法题还是挺反感的，有点类似于“形而上”的学习态度，”结伴编程“多少会是有些紧张，没写出来也很正常。但是换位思考一下，问题确实来源于实际，而且看别人码代码总是能看出一些面试者的风格或问题，多少可以作为出题人考查的标准。所以没对没错吧，自己也确实没有准备过算法题，一般般吧。
自己的实现 回到这个问题，大数是指那些无法用固定长度类型保存的数值，所以需要用可变长的数组来模拟计算和存储结果。下方代码的实现逻辑比较简单，就是按位对数值进行除以 9 取商取模的操作：
计算第 1 位数值除以 9，取商取模； 计算后续的数值，保存到一个新的 []string 作为结果返回； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strconv&amp;#34; ) func div(ns []string, prec int) []string { result := make([]string, 0) // 被除数 dividend, _ := strconv.ParseInt(ns[0], 10, 64) // 模 var remainder int64 if dividend &amp;lt; 9 { remainder = dividend } else { result = append(result, &amp;#34;1&amp;#34;) } for _, v := range ns[1:] { addition, _ := strconv.ParseInt(v, 10, 64) dividend = remainder * 10 + addition result = …  ]]></content></entry><entry><title>MySQL 性能调优</title><url>/post/old/database-performance-tuning/</url><categories><category>后端技术</category><category>MySQL</category></categories><tags><tag>MySQL</tag><tag>性能优化</tag><tag>roadmap</tag></tags><content type="html">  数据库是应用的数据存储中心，请求增多和数据量增大都会对数据库造成严重的影响，导致数据库服务性能偏低。所以归纳了个别优化点，后续有看到新的内容也会追加。
Roadmap 资源 MySQL 配置检查工具 tuning-primer MySQL 配置检查工具 MySQLTuner 配置项优化 MySQL Performance Tuning Settings   </content></entry><entry><title>卡方检验 - 检验特征对是否相关</title><url>/post/old/python-chi-square-test/</url><categories><category>数据分析</category><category>机器学习</category></categories><tags><tag>Chi-Square</tag><tag>scipy</tag><tag>NumPy</tag><tag>Pandas</tag><tag>Python</tag></tags><content type="html"><![CDATA[  在本文开头，贴一段百科对卡方检验基本原理的介绍：
卡方检验就是统计样本的实际观测值与理论推断值之间的偏离程度，实际观测值与理论推断值之间的偏离程度就决定卡方值的大小，如果卡方值越大，二者偏差程度越大；反之，二者偏差越小；若两个值完全相等时，卡方值就为 0，表明理论值完全符合。
由此可见，卡方检验刻画的是一种偏离程度。那么在相关性计算中也可以利用卡方检验计算出显著性来判断两个特征是否相关。
卡方检验 卡方检验的步骤如下：
定义 H0 和 H1 假设； 根据领域知识定义显著性水平 $\alpha$，一般取 0.05，表示有 5% 的容错； 计算卡方值； 计算显著性水平，小于 $\alpha$ 则拒绝 H0 接受 H1； 离散型特征对 离散型特征对是指特征为离散值的两维向量，如 帕尔默企鹅数据集 中的特征对（species，island）。下面演示特征列（species，island）是否存在相关性。
提出假设：
H0：特征 species 和特征 island 不相关（独立）； H1：特征 species 和特征 island 相关； 频次统计 首先，根据出现的特征值对进行频次统计：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import numpy as np import pandas as pd # 读取数据集 # 特征 species，island 并不包含缺失值 df = pd.read_csv(&amp;#39;./dataset/penguins_size.csv&amp;#39;, na_values=[&amp;#39;NA&amp;#39;, &amp;#39;.&amp;#39;]) # 得到 species 和 island 所有的取值 # speices 值为行名，island 为列名 index = df[&amp;#39;species&amp;#39;].unique() columns = df[&amp;#39;island&amp;#39;].unique() # 初始化一个频次矩阵 count_matrix = np.zeros((index.shape[0], columns.shape[0])) # 遍历所有的 species 值 for i, species in enumerate(index): # …  ]]></content></entry><entry><title>帕尔默企鹅数据集测试</title><url>/post/old/python-palmer-archipelago-penguin-testing/</url><categories><category>数据分析</category><category>机器学习</category></categories><tags><tag>Matplotlib</tag><tag>sklearn</tag><tag>Python</tag><tag>可视化</tag><tag>Data Mining</tag><tag>机器学习</tag><tag>统计学</tag></tags><content type="html"><![CDATA[  今天导师在群里分享了一个链接 23 个优秀的机器学习训练公共数据集 ，看了一下，决定对帕尔默企鹅数据集（Palmer Archipelago (Antarctica) penguin data）做一些分析。
数据集介绍 数据集是在 Kaggle 下载的，包含两个文件：
penguins_lter.csv：原始数据文件； penguins_size.csv：特征约简后的数据文件； 本次分析使用的是简化后的数据集 penguins_size.csv。数据集共 344 个样本，特征信息如下表：
特征 数据类型 说明 species 离散值 标签信息，值为 Adelie|Chinstrap|Gentoo 之一 island 离散值 岛屿，值为 Torgersen|Biscoe|Dream 之一 culmen_length_mm 连续值 喙的长度（mm） culmen_depth_mm 连续值 喙的高度（mm） flipper_length_mm 连续值 脚蹼长度（mm） body_mass_g 连续值 体重（克） sex 离散值 性别，值为 MALE| FEMALE 之一 数据集包含缺失数据，用 NA 表示特征值缺失，其中第 337 样本的 sex 特征值为“.”，在此也认为是缺失值。
使用 pandas 查看数据集的统计信息：
1 2 3 4 import pandas as pd df = pd.read_csv(&amp;#39;./dataset/penguins_size.csv&amp;#39;, na_values=[&amp;#39;NA&amp;#39;, &amp;#39;.&amp;#39;]) print(df.describe()) 1 2 3 4 5 6 7 8 9 culmen_length_mm culmen_depth_mm flipper_length_mm body_mass_g count 342.000000 342.000000 342.000000 342.000000 mean 43.921930 17.151170 200.915205 4201.754386 std 5.459584 1.974793 14.061714 801.954536 min 32.100000 13.100000 172.000000 2700.000000 25% 39.225000 …  ]]></content></entry><entry><title>Go 内置的 RPC 包</title><url>/post/old/go-built-in-rpc-package/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>RPC</tag><tag>jsonrpc</tag></tags><content type="html"><![CDATA[   在网络或 I/O 连接中，可以使用 net/rpc 包实现对一个对象的导出方法的调用，即远程过程调用（Remote Procedure Call，RPC）。通过向 RPC 服务注册一个对象，使其可被远程调用，进而实现一些复杂的业务逻辑。
项目结构 示例项目的结构如下：
1 2 3 4 5 6 7 8 client - client.go - json_client.go models - greeting.go server - json_server.go - server.go 注册服务 一个可被远程调用的方法须满足以下条件：
方法所属结构是公开的； 方法是分开的； 方法的参数类型是分开的； 方法带两个参数，第 2 个参数为指针； 方法返回值为 error 类型； 如下，在 models/greeting.go 中定义了一个服务：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type GreetingArg struct { Name string } type GreetingReply struct { Message string } type Greeting struct {} // SayHello 方法满足上述条件 func (Greeting) SayHello(arg GreetingArg, reply *GreetingReply) error { reply.Message = &amp;#34;hello, &amp;#34; + arg.Name return nil } 现在，在 server/server.go 中编写服务器端代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( &amp;#34;gorpc/models&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/rpc&amp;#34; ) func main() { server := rpc.NewServer() if err := server.Register(&amp;amp;models.Greeting{}); err != nil { log.Fatalln(err) } listener, err := …  ]]></content></entry><entry><title>Go 1.18 特性 - 泛型</title><url>/post/old/go-1.18-release-features/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Go 1.18</tag></tags><content type="html"><![CDATA[  Go 1.18 在 2022 年 3 月 15 日发布，根据团队的 博文 介绍，1.18 版本包含 4 个重要特性：
泛型； fuzzing； 工作空间； 20% 的性能提升； 泛型 泛型是一种无须关心具体操作类型的编码方式，它将逻辑实现与具体类型解耦，体现在程序中的 3 个地方：
函数和类型的类型参数； 用于指定类型的集合； 类型推断，不需要显式指定类型； 本节是官方泛型教程的截取或修改内容，详细请查看 此处 。
不同类型求和函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import &#34;fmt&#34; // sumInts 计算 int slice 的和 func sumInts(values []int) int { var total int for _, value := range values { total += value } return total } // sumFloat32s 计算 float32 slice 的和 func sumFloat32s(values []float32) float32 { var total float32 for _, value := range values { total += value } return total } // sum 计算的 slice 元素可以是 int 类型或 float32 类型 func sum[Element int | float32](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { intValues := []int{1, 2, 3} float32Values := []float32{4, 5, 6} fmt.Println(sumInts(intValues)) fmt.Println(sumFloat32s(float32Values)) // sum(intValues) 等价于 sum[int](intValues) fmt.Println(sum(intValues)) fmt.Println(sum[int](intValues)) // sum(float32Values) 等价于 sum[float32](float32Values) fmt.Println(sum(float32Values)) fmt.Println(sum[float32](float32Values)) } 类型约束 示例 1：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import &#34;fmt&#34; // Number 类型约束，限制 Number 可以是 int 或 float32 type Number interface { int | float32 } // sum 求和 // [Element Number] 限定 Element 需要符合 Number 类型约束 // 即 Element 只能是 int 或 float32 func sum[Element Number](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { intValues := []int{1, 2, 3} float32Values := []float32{4, 5, 6} fmt.Println(sum(intValues)) fmt.Println(sum(float32Values)) } 示例 2：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import &#34;fmt&#34; // Flag 底层类型为 int type Flag int const ( Flag_A Flag = iota Flag_B Flag_C ) // Number 类型约束 // ~ 操作符表示底层类型为 int 的类型也符合 type Number interface { float32 | ~int } func sum[Element Number](values []Element) Element { var total Element for _, value := range values { total += value } return total } func main() { flagValues := []Flag{ Flag_A, Flag_B, Flag_C, } float32Values := []float32{4, 5, 6} fmt.Println(sum(flagValues)) fmt.Println(sum(float32Values)) } 示例 3：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &#34;fmt&#34; &#34;strconv&#34; ) type Flag int func (f Flag) String() string { return strconv.Itoa(int(f)) } const Flag_A Flag = iota // Number 包含了方法的类型约束 // 指定了 Number 类型的底层类型是 int 并实现了 String() string 方法 type Number interface { ~int String() string } func PrintNumber[V Number](number V) { fmt.Println(number.String()) } func main() { PrintNumber(Flag_A) } 示例 4：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import &#34;fmt&#34; type Flag int const ( Flag_A Flag = iota ) // PrintNumber 使用 ~ 操作符，定义类型底层实现 func PrintNumber[Number ~int](value Number) { fmt.Println(value) } func main() { PrintNumber(Flag_A) PrintNumber(1) } 总结 使用泛型可以减少相同逻辑（不同具体类型）的代码量； 使用 ~ 操作符指定底层类型； 类型约束中可以声明方法；   ]]></content></entry><entry><title>集群相关</title><url>/post/doc-redis-commands/cluster-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与服务相关的命令，集群的配置过程可参考 《Redis 集群配置过程》 。
CLUSTER nodes：显示集群主从关系 1 2 3 4 5 6 7 127.0.0.1:6380&gt; CLUSTER nodes ac3f5aaae24bcd142b8303abedc5f57187ebc20e 127.0.0.1:6385@16385 slave 82ac1fe6c0af98d252ea96d4e84e7315eff31f8c 0 1649562125672 2 connected 9242c455757da4ad2f5aa818d75d12cde38231c2 127.0.0.1:6383@16383 slave 9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e 0 1649562126000 3 connected 5cc9ed2602986aeffaf9997f3c38c675092a4810 127.0.0.1:6384@16384 slave 92a1fd50a1c8dc003e905ac828b0db64773d6b66 0 1649562126674 1 connected 9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e 127.0.0.1:6382@16382 master - 0 1649562124670 3 connected 10923-16383 92a1fd50a1c8dc003e905ac828b0db64773d6b66 127.0.0.1:6380@16380 myself,master - 0 1649562122000 1 connected 0-5460 82ac1fe6c0af98d252ea96d4e84e7315eff31f8c 127.0.0.1:6381@16381 master - 0 1649562125000 2 connected 5461-10922 CLUSTER slots：显示哈希槽分配信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 127.0.0.1:6380&gt; CLUSTER slots 1) 1) (integer) 0 2) (integer) 5460 3) 1) &#34;127.0.0.1&#34; 2) (integer) 6380 3) &#34;92a1fd50a1c8dc003e905ac828b0db64773d6b66&#34; 4) 1) &#34;127.0.0.1&#34; 2) (integer) 6384 3) &#34;5cc9ed2602986aeffaf9997f3c38c675092a4810&#34; 2) 1) (integer) 5461 2) (integer) 10922 3) 1) &#34;127.0.0.1&#34; 2) (integer) 6381 3) &#34;82ac1fe6c0af98d252ea96d4e84e7315eff31f8c&#34; 4) 1) &#34;127.0.0.1&#34; 2) (integer) 6385 3) &#34;ac3f5aaae24bcd142b8303abedc5f57187ebc20e&#34; 3) 1) (integer) 10923 2) (integer) 16383 3) 1) &#34;127.0.0.1&#34; 2) (integer) 6382 3) &#34;9a91b1be7a42e1bfe4b03deaa200c0e72fcf9b8e&#34; 4) 1) &#34;127.0.0.1&#34; 2) (integer) 6383 3) &#34;9242c455757da4ad2f5aa818d75d12cde38231c2&#34; CLUSTER keyslot：显示 key 对应的哈希槽 1 2 127.0.0.1:6380&gt; CLUSTER keyslot user:1:name (integer) 12440   ]]></content></entry><entry><title>Protocol Buffer 减少传输数据的大小</title><url>/post/old/protocol-buffer-reduce-data-size/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Go</tag><tag>protobuf</tag></tags><content type="html"><![CDATA[  Protocol Buffer 的介绍与语法已在文章 《Protocol Buffer 语法》 给出，本文则演示了 Protocol Buffer 如何减少了传输数据的大小。
使用 protoc 命令生成 pb 代码文件 首先新建 proto/user.proto 文件来定义数据结构，其内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 syntax = &#34;proto3&#34;; option go_package = &#34;/model&#34;; message User { string name = 1; enum Gender { MALE = 0; FEMALE = 1; }; Gender gender = 2; } 然后，执行如下命令生成源代码文件：
1 protoc --go_out=. proto\user.proto 主程序 main 主程序的作用是比较不同 User 结构序列化后的字节数据的大小。首先，新建 main.go 文件并定义一个 User 结构，如下：
1 2 3 4 type User struct { Name string Gender int32 } 主程序的逻辑如下：
1 2 3 4 5 6 7 8 func main() { user := &amp;User{ Name: &#34;a2htray&#34;, Gender: 1, } data, err = json.Marshal(user) fmt.Println(data, err) } 执行输出如下：
1 [123 34 78 97 109 101 34 58 34 97 50 104 116 114 97 121 34 44 34 71 101 110 100 101 114 34 58 49 125] 29 &lt;nil&gt; 从输出可知，自定义的 User 的值序列化后的字节长度为 29。
接着，使用 Protocol Buffer 生成的 User 结构并使用 proto.Marshal 方法对值进行序列化，代码如下：
1 2 3 4 5 6 7 8 func main() { userPB := &amp;model.User{ Name: &#34;a2htray&#34;, Gender: 1, } data, err = proto.Marshal(userPB) fmt.Println(data, len(data), err) } 执行输出如下：
1 [10 7 97 50 104 116 114 97 121 16 1] 11 &lt;nil&gt; 从输出可知，Protocol Buffer 生成的 User 类型的值序列化后的字节长度为 11。
综上，分别使用 JSON 和 Protocol Buffer 序列化相同的数据信息，使用 Protocol Buffer 得到的字节长度要更小，更有得于在网络中的传输。
完整代码 演示完成后，当前项目的目录结构如下：
1 2 3 4 5 model - user.pb.go # 通过 protoc 命令生成 proto - user.proto # 定义数据结构 main.go main.go 的完整内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( &#34;encoding/json&#34; &#34;fmt&#34; &#34;./model&#34; &#34;google.golang.org/protobuf/proto&#34; ) type User struct { Name string Gender int32 } func main() { user := &amp;User{ Name: &#34;a2htray&#34;, Gender: 1, } data, err := json.Marshal(user) fmt.Println(data, len(data), err) userPB := &amp;model.User{ Name: &#34;a2htray&#34;, Gender: 1, } data, err = proto.Marshal(userPB) fmt.Println(data, len(data), err) } 总结 Protocol Buffer 序列化的数据量更小；   ]]></content></entry><entry><title>Protocol Buffer 语法</title><url>/post/old/protocol-buffer-syntax/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Go</tag><tag>protobuf</tag></tags><content type="html">  Protocol Buffer（Protobuf） 是一种高效的数据结构序列化的机制，同时也是一种结构化数据的存储格式。
序列化与反序列化
序列化：将数据结构或对象转换成二进制串的过程； 反序列化：将序列化后的二进制串转换成数据结构或对象的过程； 语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 /* * 语法 */ /* * 指定 Protobuf 解析使用的版本，可以是 proto3 或 proto2 */ syntax = &amp;amp;#34;proto3&amp;amp;#34;; /* * message 定义中的每一个字段都有一个唯一标识，该标识用于在二进制格式中识别字段 * 字段的标识一旦使用就不要进行修改 * 当标识为 1 到 15 时，使用一个字节进行编码，字节信息中包含字段的标识以及类型 * 当标识为 16 到 2047 时，使用两个字节进行编码 * …  </content></entry><entry><title>Redis 集群配置过程</title><url>/post/old/redis-cluster-deployment/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html">  Redis 集群是基于“主从复制”特性之上的分布式 Redis 版本，可提供高并发、高性能、高可用的数据库服务。Redis 集群突破了单台服务器的内存局限，集群中的每一个节点都可以存储数据，同时维护着 &amp;amp;ldquo;key-node&amp;amp;rdquo; 的映射表。本文记录了 3 主 3 从的 Redis 集群的配置过程，主要内容包括：
Redis 集群的配置过程； 集群相关命令； Go 存取集群数据； 环境信息
1 2 3 4 5 6 $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.2 LTS Release: 20.04 Codename: focal 1 2 $ redis-server -v Redis server v=6.2.6 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=9c9e426e2f96cc51 配置过程 配置文件 3 主使用的端口分别为 6380、6381 和 6382，3 从使用的端口为 6383、6384 和 6385。创建配置文件以及工作目录：
1 2 3 4 5 6 7 8 $ mkdir /etc/redis/cluster $ chown redis.redis /etc/redis/cluster $ cp -a /etc/redis/redis.conf /etc/redis/cluster/redis-6380.conf $ cp -a /etc/redis/redis.conf /etc/redis/cluster/redis-6381.conf $ cp -a /etc/redis/redis.conf /etc/redis/cluster/redis-6382.conf $ cp -a /etc/redis/redis.conf /etc/redis/cluster/redis-6383.conf $ cp -a /etc/redis/redis.conf /etc/redis/cluster/redis-6384.conf $ cp -a /etc/redis/redis.conf …  </content></entry><entry><title>Matplotlib bar 图常规编码</title><url>/post/old/python-matplotlib-bar-tips/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>Matplotlib</tag><tag>bar 图</tag><tag>Python</tag></tags><content type="html"><![CDATA[  每当有快速绘制图表的需求时，第一时间反应到的肯定是 Matplotlib，因为其官方提供了详细的 API 文档及示例。但是每次在编码时，总是时不时地需要查看文档，不利用于可视化快速成型。所以在本文中罗列一些 bar 图的快速实现，方便 Ctrl+C/V。
基本实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import matplotlib.pyplot as plt import numpy as np data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) plt.bar( x, # bar 在 x 轴的位置 data, width=0.6, # bar 的宽度 label=&#39;Sales&#39;, ) plt.xticks( x, # 标签的位置 [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;], ) plt.legend() plt.title(&#39;Products&#39;) bar 设置颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import matplotlib.pyplot as plt import numpy as np colors = [&#39;#009392&#39;, &#39;#39b185&#39;, &#39;#9ccb86&#39;, &#39;#e9e29c&#39;, &#39;#eeb479&#39;, &#39;#e88471&#39;, &#39;#cf5974&#39;] data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) plt.bar( x, data, width=0.6, color=colors, # 单值或者可迭代对象，如果长度与数组不匹配则会从头反复使用色值 ) plt.xticks( x, [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;], ) plt.title(&#39;Sales&#39;) 显示数值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import matplotlib.pyplot as plt import numpy as np colors = [&#39;#009392&#39;, &#39;#39b185&#39;, &#39;#9ccb86&#39;, &#39;#e9e29c&#39;, &#39;#eeb479&#39;, &#39;#e88471&#39;, &#39;#cf5974&#39;] data = [120, 200, 150, 80, 70, 110, 130] x = np.arange(len(data)) bar = plt.bar( x, data, width=0.6, color=colors, ) plt.bar_label( bar, label_type=&#39;edge&#39;, # 标签显示的位置，edge 为默认值；如果是 center 则显示在 bar 中间（垂直水平居中） ) plt.xticks( x, [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;], ) plt.title(&#39;Sales&#39;) 层叠 bar 图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import matplotlib.pyplot as plt import numpy as np data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) bar1 = plt.bar( x, data_man, label=&#39;Man&#39;, color=&#39;#009392&#39;, ) bar2 = plt.bar( x, data_woman, bottom=data_man, label=&#39;Woman&#39;, color=&#39;#cf5974&#39;, ) plt.bar_label( bar1, label_type=&#39;center&#39;, labels=data_man, # 设置显示的值 ) plt.bar_label( bar2, label_type=&#39;center&#39;, labels=data_woman, ) plt.xticks( x, [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;], ) plt.legend() 多条 bar 通过调整 bar 的位置和宽度来实现多条 bar 不重叠显示。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import matplotlib.pyplot as plt import numpy as np data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) width = 0.4 bar1 = plt.bar( x - width/2, # 位置 data_man, width=width, # 宽度 label=&#39;Man&#39;, color=&#39;#eeb479&#39;, ) bar2 = plt.bar( x + width/2, data_woman, width=width, label=&#39;Woman&#39;, color=&#39;#cf5974&#39;, ) plt.bar_label(bar1) plt.bar_label(bar2) plt.legend() 动态 bar 图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import matplotlib.pyplot as plt import numpy as np from matplotlib.animation import FuncAnimation data_man = [120, 200, 150, 80, 70, 110, 130] frames = 10 fig = plt.figure() axes = fig.add_subplot(1,1,1) axes.set_ylim(0, 250) def generate_animate_data(data, n): &#34;&#34;&#34;生成每帧的数据&#34;&#34;&#34; animate_data = [] for v in data: animate_data.append(np.linspace(0, v, n)) return np.array(animate_data) animate_data = generate_animate_data(data_man, frames) def animate(i): plt.bar( [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;], animate_data[:,i], color=&#39;#eeb479&#39;, label=&#39;Man&#39; ) ani = FuncAnimation( fig, animate, frames=frames, # 帧数 interval=300, ) plt.title(&#39;Man&#39;) bar 图案 plt.bar 函数有两个可选参数 facecolor 和 edgecolor 控制。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import matplotlib.pyplot as plt import numpy as np bar_styles = { &#39;man&#39;: { &#39;facecolor&#39;: &#39;#ee8479&#39;, &#39;edgecolor&#39;: &#39;black&#39;, &#39;hatch&#39;: &#39;//&#39;, }, &#39;woman&#39;: { &#39;facecolor&#39;: &#39;#cf5974&#39;, &#39;edgecolor&#39;: &#39;black&#39;, &#39;hatch&#39;: &#39;--&#39;, } } data_man = [120, 200, 150, 80, 70, 110, 130] data_woman = [100, 50, 90, 50, 80, 30, 30] x = np.arange(len(data)) width = 0.4 bar1 = plt.bar( x - width/2, data_man, width=width, label=&#39;Man&#39;, **bar_styles[&#39;man&#39;] ) bar2 = plt.bar( x + width/2, data_woman, width=width, label=&#39;Woman&#39;, **bar_styles[&#39;woman&#39;] ) plt.bar_label(bar1) plt.bar_label(bar2) plt.legend()   ]]></content></entry><entry><title>k-means 基本原理及其实现</title><url>/post/old/data-analysis-kmeans/</url><categories><category>数据分析</category><category>机器学习</category></categories><tags><tag>k-means</tag></tags><content type="html">  k-means 算法是一种无监督的聚类算法，其优点是逻辑简单、易于实现。
基本原理 质心是指一个簇中样本的均值向量，k-means 中的 means 就是从这里来的。当确定 k 个质心后，需要计算样本与 k 个质心的距离，而样本则归属于距离最近的质心所在的簇。随着算法的迭代，质心的位置会发生变化。质心的变化程度也是算法结束的一个条件，迭代前后质心位置变化通常使用 SSE 来刻画。
其中 $n$ 是质心的维数，$c^{(t)}_{ij}$ 表示 $t$ 次迭代中第 $i$ 个质心的第 $j$ 维值。
步骤 确定 k 值、最大迭代数及误差值； 随机选择 k 个样本作为质心； 分别计算样本与质心的距离，将样本划分到 k 个簇； 重新计算 k 个簇的质心，比较前后质心的误差； 若误差小于等于设置的误差值，则算法结束； 若误差大于设置的误差值，则执行步骤 5； 判断是否达到最大迭代数，若未达到则执行步骤 3，否则算法结束； 问题 选择 k-means 算法做聚类分析时，以下几个问题值得注意：
初始质心的选择； k 值的确定； 距离公式的确定； k-means 算法容易局部最优，并且算法的结果在很大程度上取决于初始质心的选择，不同的初始质心可能会得到截然不同的聚类结果。同时，在面对未知类别个数的数据集时，如何确定 k 值也是一件麻烦事。通常做法都在小样本集上尝试不同的 k 值，然后比较聚类的结果并将 k 值定为跑得最好结果的那次 k 值。距离公式的选择则是需要依靠领域知识，因为在不同的领域中，样本的相似度的计算方式会有所不同。
完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import numpy as np import matplotlib.pyplot as plt def distance(x1, x2): &amp;amp;#34;&amp;amp;#34;&amp;amp;#34;欧式距离 …  </content></entry><entry><title>Go 1.16 运行 Revel 项目</title><url>/post/old/go-revel-run-require-packages/</url><categories><category>后端技术</category><category>Go</category></categories><tags><tag>Revel</tag></tags><content type="html"><![CDATA[   Revel 是一个以高效率、高性能著称的 Go Web 框架，提供了路由、参数解析和验证、会话机制、模板机制、缓存和任务管理等诸多常用的 Web 开发功能。同时作为一个全栈的 MVC 框架， Revel 通过模块实现了组件的复用，因此可以大大提高开发者的效率。其高性能则是依托 Go 语言的性能，相信这个不必多说。但相较于其它职责相对单一的 Web 框架（如 Gin、go-restful），Revel 只能说是在保证性能的基础上尽可能地对开发者友好。
问题重现 环境
Go 的版本：go1.16.9 windows/amd64
Revel：v1.0.0
今天在试验 Revel 项目时，运行新建的项目会报错，如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ revel run -a . ERROR 10:46:39 file.go:372: Error seeking=github.com/revel/revel count=1 App Import Path=github.com/revel/revel filesystem path=github.com/revel/revel errors=&#34;[-: no required module provides package github.com/revel/revel; to add it:\n\tgo get github.com/revel/revel]&#34; Downloading related packages ... completed. Revel executing: run a Revel application WARN 10:46:41 harness.go:175: No http.addr specified in the app.conf listening on localhost interface only. This will not allow external access to your application Changed detected, recompiling Parsing packages, (may require download if not cached)...Changed detected, recompiling Completed ERROR 10:46:44 build.go:406: Build errors errors=&#34;C:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\memcached.go:11:2: no required module provides package github.com/bradfitz/gomemcache/memcache; to add it:\n\tgo get github.com/bradfitz/gomemcache/memcache\nC:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\redis.go:10:2: no required module provides package github.com/garyburd/redigo/redis; to add it:\n\tgo get github.com/garyburd/redigo/redis\nC:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\inmemory.go:12:2: no required module provides package github.com/patrickmn/go-cache; to add it:\n\tgo get github.com/patrickmn/go-cache\n&#34; C:\Users\a2htray\go\src\omics-framework\C:\Users\a2htray\go\pkg\mod\github.com\revel\revel@v1.0.0\cache\memcached.go:11 WARN 10:46:44 build.go:420: Could not find in GO path file=C:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\memcached.go:11 ERROR 10:46:44 harness.go:239: Build detected an error error=&#34;Go Compilation Error (in C:\\Users\\a2htray\\go\\pkg\\mod\\github.com\\revel\\revel@v1.0.0\\cache\\memcached.go:11:2): no required module provides package github.com/bradfitz/gomemcache/memcache; to add it:&#34; Error compiling code, to view error details see proxy running on http://:9000 Time to recompile 2.4257731s 新建的 Revel 项目使用 go.mod 对包进行管理，初始的包如下：
1 2 3 4 5 require ( github.com/go-stack/stack v1.8.1 // indirect github.com/revel/modules v1.0.0 github.com/revel/revel v1.0.0 ) 通过错误输出，可知当前项目缺少了 3 个包：
1 2 3 github.com/bradfitz/gomemcache/memcache github.com/garyburd/redigo/redis github.com/patrickmn/go-cache 解决办法 既然是项目缺少包，那就只要把缺失的包 go get 一下即可。
1 2 3 $ go get github.com/bradfitz/gomemcache/memcache $ go get github.com/garyburd/redigo/redis $ go get github.com/patrickmn/go-cache 再次运行：
1 2 3 4 5 6 7 8 9 10 11 12 $ revel run -a . Revel executing: run a Revel application WARN 11:33:47 harness.go:175: No http.addr specified in the app.conf listening on localhost interface only. This will not allow external access to your application Changed detected, recompiling Parsing packages, (may require download if not cached)... Completed Changed detected, recompiling INFO 11:33:54 app run.go:34: Running revel server INFO 11:33:54 app plugin.go:9: Go to /@tests to run the tests. Revel proxy is listening, point your browser to : Revel engine is listening on.. localhost:52469 9000 Time to recompile 7.0696399s 其它 在这个 issue 1528 里，有人说是 Go 版本问题，即在 Go 1.15 中是可以运行的。我想解决上面的问题，就把缺失包补上就可以了，而且也猜应该不是 Go 版本问题，毕竟 Revel 的 cache 实现中也确实使用了这 3 个包。再深入想一想，如果 Revel 项目也是通过 Go Module 管理包的话，revel run 的时候就会自动下载这些包。
  ]]></content></entry><entry><title>Redis 主从复制配置过程</title><url>/post/old/redis-master-slave-replication-deployment/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag><tag>主从复制</tag></tags><content type="html"><![CDATA[  Redis 主从复制可以实现数据库的读写分离，即主节点负责接收写请求、从节点负责接收读请求，是高性能 Redis 服务的基础。所以配置 Redis 主从复制应当作为开发者的技能之一，后文内容包括：
单机配置一主二从的主从复制服务 服务验证； 环境信息
1 2 3 4 5 6 $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.2 LTS Release: 20.04 Codename: focal 1 2 $ redis-server -v Redis server v=6.2.6 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=9c9e426e2f96cc51 配置过程 主节点使用 6379 端口，两个从节点分别使用 6380 和 6381 端口。
Redis 配置文件 复制两份 Redis 配置文件分别为两个从节点的配置文件：
1 2 cp -a /etc/redis/redis.conf /etc/redis/redis-server-6380.conf cp -a /etc/redis/redis.conf /etc/redis/redis-server-6381.conf 修改两个配置文件的内容，修改及新增内容如下：
1 2 3 4 5 6 7 8 # redis-6380.conf # 修改项 port 6380 pidfile /run/redis/redis-server-6380.pid logfile /var/log/redis/redis-server-6380.log dbfilename dump-6380.rdb # 新增项 slaveof 127.0.0.1 6379 1 2 3 4 5 6 7 8 # redis-6381.conf # 修改项 port 6381 pidfile /run/redis/redis-server-6381.pid logfile /var/log/redis/redis-server-6381.log dbfilename dump-6381.rdb # 新增项 slaveof 127.0.0.1 6379 systemd 配置文件 复制两份 systemd 配置文件分别作为两个从节点的服务启动文件：
1 2 cp -a /lib/systemd/system/redis-server.service /lib/systemd/system/redis-server-6380.service cp -a /lib/systemd/system/redis-server.service /lib/systemd/system/redis-server-6381.service 修改两个配置文件的内容，均为修改项，如下：
1 2 3 4 # redis-server-6380.service [Service] ExecStart=/usr/bin/redis-server /etc/redis/redis-server-6380.conf PIDFile=/run/redis/redis-server-6380.pid 1 2 3 4 # redis-server-6381.service [Service] ExecStart=/usr/bin/redis-server /etc/redis/redis-server-6381.conf PIDFile=/run/redis/redis-server-6381.pid 修改之后，需要执行如下命令进行重新加载：
1 systemctl daemon-reload 启动服务 配置完成后，通过 systemd 的管理命令分别在 3 个终端各启动 1 个服务，命令及显示如下：
1 2 3 4 5 6 7 8 9 10 # 主节点 $ systemctl start redis-server.service $ redis-cli -p 6379 127.0.0.1:6379&gt; INFO Replication # Replication role:master connected_slaves:2 slave0:ip=127.0.0.1,port=6380,state=online,offset=308,lag=0 slave1:ip=127.0.0.1,port=6381,state=online,offset=308,lag=1 # 其它 ... 1 2 3 4 5 6 7 8 9 # 从节点 6380 $ systemctl start redis-server-6380.service $ redis-cli -p 6380 127.0.0.1:6380&gt; INFO Replication # Replication role:slave master_host:127.0.0.1 master_port:6379 # 其它 ... 1 2 3 4 5 6 7 8 9 # 从节点 6381 $ systemctl start redis-server-6381.service $ redis-cli -p 6381 127.0.0.1:6381&gt; INFO Replication # Replication role:slave master_host:127.0.0.1 master_port:6379 # 其它 ... 读写 Redis 数据库 是否发生主从复制，可按如下的命令依次执行进行验证。
1 2 3 4 5 6 7 8 9 # 主节点 127.0.0.1:6379&gt; SET topic master-slave-replication OK # 从节点 6380 127.0.0.1:6380&gt; GET topic &#34;master-slave-replication&#34; # 从节点 6381 127.0.0.1:6381&gt; GET topic &#34;master-slave-replication&#34; 其它 systemd 是 Linux 服务器管理服务的其中一种方式，服务的启动与关闭也可以通过 redis-server 命令或其它方式进行实现。Redis 使用到的目录及文件信息包括：
/run/redis/：存放 Redis 服务的 pid 文件，由 pidfile 配置项决定； /var/log/redis/：存放 Redis 服务的日志文件，由 logfile 配置项决定； /var/lib/redis：存放 RDB 文件，由 dir 和 dbfilename 配置项决定； 完整脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/bin/bash SLAVE1_PORT=6380 SLAVE2_PORT=6381 cat /etc/redis/redis.conf | \ sed &#34;s/^port\ 6379/port\ $SLAVE1_PORT/g&#34; | \ sed &#34;s/^pidfile \/run\/redis\/redis-server\.pid/pidfile \/run\/redis\/redis-server-$SLAVE1_PORT\.pid/g&#34; | \ sed &#34;s/^logfile \/var\/log\/redis\/redis-server\.log/logfile \/var\/log\/redis\/redis-server-$SLAVE1_PORT\.log/g&#34; | \ sed &#34;s/^dbfilename dump\.rdb/dbfilename dump-$SLAVE1_PORT\.rdb/g&#34; | \ sed &#34;\$a\\slaveof 127.0.0.1 6379\\&#34; &gt; /etc/redis/redis-server-$SLAVE1_PORT.conf chown redis.redis /etc/redis/redis-server-$SLAVE1_PORT.conf cat /etc/redis/redis.conf | \ sed &#34;s/^port\ 6379/port\ $SLAVE2_PORT/g&#34; | \ sed &#34;s/^pidfile \/run\/redis\/redis-server\.pid/pidfile \/run\/redis\/redis-server-$SLAVE2_PORT\.pid/g&#34; | \ sed &#34;s/^logfile \/var\/log\/redis\/redis-server\.log/logfile \/var\/log\/redis\/redis-server-$SLAVE2_PORT\.log/g&#34; | \ sed &#34;s/^dbfilename dump\.rdb/dbfilename dump-$SLAVE2_PORT\.rdb/g&#34; | \ sed &#34;\$a\\slaveof 127.0.0.1 6379\\&#34; &gt; /etc/redis/redis-server-$SLAVE2_PORT.conf chown redis.redis /etc/redis/redis-server-$SLAVE2_PORT.conf cat /lib/systemd/system/redis-server.service | \ sed &#34;s/\/etc\/redis\/redis\.conf/\/etc\/redis\/redis-server-$SLAVE1_PORT\.conf/g&#34; | \ sed &#34;s/\/run\/redis\/redis-server\.pid/\/run\/redis\/redis-server-$SLAVE1_PORT\.pid/g&#34; &gt; /lib/systemd/system/redis-server-$SLAVE1_PORT.service chown root.root /lib/systemd/system/redis-server-$SLAVE1_PORT.service cat /lib/systemd/system/redis-server.service | \ sed &#34;s/\/etc\/redis\/redis\.conf/\/etc\/redis\/redis-server-$SLAVE2_PORT\.conf/g&#34; | \ sed &#34;s/\/run\/redis\/redis-server\.pid/\/run\/redis\/redis-server-$SLAVE2_PORT\.pid/g&#34; &gt; /lib/systemd/system/redis-server-$SLAVE2_PORT.service chown root.root /lib/systemd/system/redis-server-$SLAVE2_PORT.service systemctl daemon-reload systemctl start redis-server.service systemctl start redis-server-$SLAVE1_PORT.service systemctl start redis-server-$SLAVE2_PORT.service 总结 Redis 主从复制的配置过程； Redis 服务相关配置项说明；   ]]></content></entry><entry><title>服务相关</title><url>/post/doc-redis-commands/server-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与服务相关的命令。
INFO：查看当前服务器信息 格式：INFO [section]
1 2 3 4 5 6 7 8 9 10 127.0.0.1:6380&gt; INFO # Server redis_version:6.2.6 redis_git_sha1:00000000 redis_git_dirty:0 redis_build_id:9c9e426e2f96cc51 redis_mode:standalone os:Linux 5.4.0-77-generic x86_64 arch_bits:64 # 还有很多 ... SHUTDOWN：客户端断开连接 格式：SHUTDOWN [NOSAVE|SAVE]
1 2 127.0.0.1:6379&gt; SHUTDOWN SAVE not connected&gt; EXIT：退出客户端 1 127.0.0.1:6379&gt; EXIT   ]]></content></entry><entry><title>同源策略 Same-Origin Policy</title><url>/post/old/web-same-origin-policy/</url><categories><category>前端技术</category><category>基础原理</category></categories><tags><tag>Web 安全</tag></tags><content type="html"><![CDATA[  同源策略（Same-Origin Policy，SOP）是一种保护 Web 资源的安全机制，它限制了不同源之间的资源访问。需要说明的是，SOP 只作用于应用脚本，这意味着在 HTML 标签中可以引入不同源的图片、CSS 文件或动态加载的脚本文件（见 验证 1 ）。
同源 URL 统一资源标识符（Uniform Resource Locator，URL）标识了一个 Web 资源，其格式为：
schema://host[:port][/path ...]
其中 schema 可为 http 或 https，port 默认为 80。如果两个 URL 的 schema、host、port 都相同时，则认为这两个 URL 是同源的。现有 URL 为 http://foo.com/bar，以下是其它 URL 是否同源的说明。
URL 是否同源 说明 https://foo.com 否 schema 不同 http://bar.com 否 host 不同 http://foo.com:81/bar 否 port 不同 http://foo.com/zot 是 3 个都相同 访问规则 通常，直接读取跨域资源是不允许的，但仍然可以通过内嵌跨域资源进行访问。以下是允许跨域访问的规则：
方式 说明 iframes 响应头的 X-Frame-Options 字段可以设置 &lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt; 或 object 标签可引用的页面，但跨域读 iframe 里的内容是不允许的 CSS &lt;link&gt; 标签的 href 属性和 CSS 文件中的 @import 指令 forms 此处不应该是读取，而是说 &lt;form&gt; 的 action 属性可以设置不同源的 URL，指的是目标服务可以接收不同源的数据 images 通过 &lt;img&gt; 标签访问跨域图片，但在 canvas 元素里加载跨域图片是不允许的 multimedia 通过 &lt;video&gt; 和 &lt;audio&gt; 标签加载跨域的多媒体资源 script 通过 &lt;script&gt; 标签加载跨域的脚本，但请求跨域的 API 是不允许的 所以以上的规则容易变成 Web 服务攻击的入口，应当警惕。
验证 验证 1 示例目录结构
1 2 3 4 5 6 验证 1 - static - images profile.jpg index.html main.go 1 2 3 4 5 6 7 8 9 10 11 12 13 // main.go package main import ( &#34;log&#34; &#34;net/http&#34; ) func main() { fs := http.FileServer(http.Dir(&#34;./static/&#34;)) http.Handle(&#34;/static/&#34;, http.StripPrefix(&#34;/static&#34;, fs)) log.Fatal(http.ListenAndServe(&#34;:8001&#34;, nil)) } 1 2 3 4 5 6 7 8 9 10 11 12 &lt;!-- index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;验证 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;图片不受同源策略限制&lt;/p&gt; &lt;img width=&#34;100&#34; height=&#34;100&#34; alt=&#34;profile&#34; src=&#34;http://localhost:8001/static/images/profile.jpg&#34;&gt; &lt;/body&gt; &lt;/html&gt; 总结 URL 是否同源取决于 schema、host、port 是否一致； 尽管跨域访问是不允许的，但仍然有一定的跨域可访问规则；   ]]></content></entry><entry><title>Python 读写文件</title><url>/post/old/python-read-and-write-file/</url><categories><category>后端技术</category><category>Python</category></categories><tags><tag>file</tag></tags><content type="html"><![CDATA[  在开发过程中，开发者常常需要对文件执行读写操作，仅以此文记录读写文件的常规用法。
打开和关闭文件 Python 的内建函数 open 可以打开一个文件，可返回一个文件对象 TextIOWrapper（也称文件句柄）。打开的文件应当及时关闭，否则过多的文件对象容易造成内存占用，导致程序运行内存不足。按照是否调用文件对象的 close 方法，有两种打开和关闭文件的代码书写方式：
显式 close 隐式 close 显式 close
1 2 3 4 5 6 7 def open1(): f = open(&amp;#39;./students.dat&amp;#39;) try: lines = f.readlines() print(lines) finally: f.close() 隐式 close
1 2 3 4 def open2(): with open(&amp;#39;./students.dat&amp;#39;) as f: lines = f.readlines() print(lines) 支持 with 语句的对象需要实现 __enter__ 和 __exit__ 两个方法，其中 TextIOWrapper 类实现了 __exit__ 方法，IOBase 类实现了 __enter__ 方法。
上述两个函数的作用相同，都是用于打开 students.dat 文件并打印所有的行。
open 函数 内建函数 open 的签名如下：
1 2 3 4 5 6 7 8 9 10 def open( file: _OpenFile, mode: OpenTextMode = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: _Opener | None = ..., ) -&amp;gt; TextIOWrapper: ... file：字符串文件路径或实现了 os.PathLike 抽象类的实例； mode：打开模式，默认 r，可选； buffering：设置缓冲策略，可选； encoding：编码格式，可选； errors：编码或解码发生错误时的错误信息，可选； …  ]]></content></entry><entry><title>键相关</title><url>/post/doc-redis-commands/key-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与 key 相关的命令。
KEYS：获取数据库中匹配规则的键名 KEYS 命令遍历数据库中的所有键，支持 glob 风格通配符格式，在存在大量键值对的 Redis 服务器上应谨慎使用。
格式：KEYS patten
1 2 3 4 5 6 127.0.0.1:6379&amp;gt; KEYS * (empty array) 127.0.0.1:6379&amp;gt; SET config:logLevel Fatal OK 127.0.0.1:6379&amp;gt; KEYS config:* 1) &amp;#34;config:logLevel&amp;#34; glob 风格通配符格式
符号 含义 ? 匹配一个字符 * 匹配任意多个字符 [] 匹配括号间的任一字符 \ 转义 EXISTS：判断键名是否存在 EXISTS 用于判断键名是否存在，返回值为存在键名的个数。
格式：EXISTS key [key ...]
1 2 3 4 127.0.0.1:6379&amp;gt; EXISTS config:logLevel config:pagination (integer) 1 127.0.0.1:6379&amp;gt; EXISTS config:pagination (integer) 0 EXPIRE：给键设置过期时间 EXPIRE 可以给一个键设置一个以秒为单位的过期时间。
格式：EXPIRE key seconds
1 2 3 4 5 6 7 8 9 10 127.0.0.1:6379&amp;gt; SET user:1:name xiaoming OK 127.0.0.1:6379&amp;gt; EXPIRE user:1:name 5 (integer) 1 127.0.0.1:6379&amp;gt; GET user:1:name &amp;#34;xiaoming&amp;#34; # 5 秒内访问 127.0.0.1:6379&amp;gt; GET user:1:name (nil) # 5 秒后访问 EXPIREAT：给键设置过期时间 EXPIREAT 通过指定一个 UNIX 时间戳为键设置一个过期时间。
格式：EXPIREAT key timestamp
1 2 3 4 5 6 7 127.0.0.1:6379&amp;gt; SET user:1:name xiaoming OK …  ]]></content></entry><entry><title>介绍</title><url>/post/doc-redis-commands/introduction/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html">  Redis 是开源的、高性能的数据结构存储系统，在框架设计中常常被当作缓存服务器。不同于传统的关系型数据库（如 MySQL、PostgreSQL），Redis 将数据以键值对的方式存储于内存并且支持数据持久化。尽管 Redis 采用了单线程模型来处理请求，但其通过 I/O 多路复用技术做到了应用级别的异步，运行的性能也十分良好。
根据操作对象的不同，可将 Redis 中的命令分成以下几类：
键相关命令 字符串值相关命令 列表值相关命令 集合值相关命令 有序集合值相关命令 流类型值相关命令 集群相关命令 服务相关命令   </content></entry><entry><title>集合相关</title><url>/post/doc-redis-commands/set-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与集合相关的命令。
SADD：向集合中添加元素，若元素存在则忽略本次操作 SADD 返回成功添加到集合的元素个数，集合中已存在的元素不作添加处理。
格式：SADD key member [member ...]
1 2 3 4 5 127.0.0.1:6379&gt; SADD odds 1 3 5 7 (integer) 4 127.0.0.1:6379&gt; SADD odds 7 9 (integer) 1 # 此时，只有元素 9 被成功添加 SREM：删除集合中的元素 SREM 返回成功删除的元素个数。
格式：SREM key member [member ...]
1 2 3 4 5 6 127.0.0.1:6379&gt; SREM odds 9 7 (integer) 2 127.0.0.1:6379&gt; SMEMBERS odds 1) &#34;1&#34; 2) &#34;3&#34; 3) &#34;5&#34; SMEMBERS：获取集合中的所有元素 格式：SMEMBERS key
1 2 3 4 127.0.0.1:6379&gt; SMEMBERS odds 1) &#34;1&#34; 2) &#34;3&#34; 3) &#34;5&#34; SCARD：获取集合中元素的个数 格式：SCARD key
1 2 127.0.0.1:6379&gt; SCARD odds (integer) 3 SRANDMEMBER：随机获取集合中指定个数的元素 格式：SRNADMEMBER key [count]
1 2 3 4 5 6 7 8 9 127.0.0.1:6379&gt; SMEMBERS odds 1) &#34;1&#34; 2) &#34;3&#34; 3) &#34;5&#34; 127.0.0.1:6379&gt; SRANDMEMBER odds &#34;1&#34; 127.0.0.1:6379&gt; SRANDMEMBER odds 2 1) &#34;1&#34; 2) &#34;5&#34; SPOP：从集合中随机弹出一个或多个元素 格式：SPOP key [count]
1 2 3 4 5 6 7 8 9 10 127.0.0.1:6379&gt; SPOP odds 1 1) &#34;3&#34; 127.0.0.1:6379&gt; SMEMBERS odds 1) &#34;1&#34; 2) &#34;5&#34; 127.0.0.1:6379&gt; SPOP odds 2 1) &#34;1&#34; 2) &#34;5&#34; 127.0.0.1:6379&gt; SMEMBERS odds (empty array) SDIFF：集合运算，取差集 SDIFF 可以对多个集合进行取差集操作。
格式：SDIFF key [key ...]
1 2 3 4 5 6 7 8 9 10 127.0.0.1:6379&gt; SADD integers 1 2 3 4 5 6 7 8 9 10 (integer) 10 127.0.0.1:6379&gt; SADD odds 1 3 5 7 9 (integer) 5 127.0.0.1:6379&gt; SDIFF integers odds 1) &#34;2&#34; 2) &#34;4&#34; 3) &#34;6&#34; 4) &#34;8&#34; 5) &#34;10&#34; SINTER：集合运算，取交集 SINTER 可以对多个集合进行取交集操作。
格式：SINTER key [key ...]
1 2 3 4 5 6 127.0.0.1:6379&gt; SINTER integers odds 1) &#34;1&#34; 2) &#34;3&#34; 3) &#34;5&#34; 4) &#34;7&#34; 5) &#34;9&#34; SUNION：集合运算，取并集 SUNION 可以对多个集合进行取并集操作。
格式：SUNION key [key ...]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 127.0.0.1:6379&gt; SADD odds 1 3 5 7 9 (integer) 0 127.0.0.1:6379&gt; SADD evens 2 4 6 8 10 (integer) 5 127.0.0.1:6379&gt; SUNION odds evens 1) &#34;1&#34; 2) &#34;2&#34; 3) &#34;3&#34; 4) &#34;4&#34; 5) &#34;5&#34; 6) &#34;6&#34; 7) &#34;7&#34; 8) &#34;8&#34; 9) &#34;9&#34; 10) &#34;10&#34; SDIFFSTORE：集合运算，存储差集 SDIFFSTORE 可以将多个集合的取差集的运算结果保存到另一个键中，返回值为差集的元素个数。
格式：SDIFFSTORE destination key [key ...]
1 2 127.0.0.1:6379&gt; SDIFFSTORE new:odds integers evens (integer) 5 SINTERSTORE：集合运算，存储交集 SINTERSTORE 可以将多个集合的取交集的运算结果保存到另一个键中，返回值为交集的元素个数。
格式：SINTERSTORE destination key [key ...]
1 2 127.0.0.1:6379&gt; SINTERSTORE new:evens integers evens (integer) 5 SUNIONSTORE：集合运算，存储并集 SUNIONSTORE 可以将多个集合的取并集的运算结果保存到另一个键中，返回值为并集的元素个数。
格式：SUNIONSTORE destination key [key ...]
1 2 3 4 5 6 7 8 9 10 11 12 13 127.0.0.1:6379&gt; SUNIONSTORE new:integers odds evens (integer) 10 127.0.0.1:6379&gt; SMEMBERS new:integers 1) &#34;1&#34; 2) &#34;2&#34; 3) &#34;3&#34; 4) &#34;4&#34; 5) &#34;5&#34; 6) &#34;6&#34; 7) &#34;7&#34; 8) &#34;8&#34; 9) &#34;9&#34; 10) &#34;10&#34;   ]]></content></entry><entry><title>流相关</title><url>/post/doc-redis-commands/stream-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与 stream 相关的命令。
XADD：向 stream 添加消息 XADD 可以向 stream 添加消息，返回实体 entry 的 ID。
格式：XADD key *|ID field value [field value ...]
1 2 3 4 127.0.0.1:6379&gt; XADD chat:1:messages * msg &#34;hello world&#34; date 2020 &#34;1648184286632-0&#34; 127.0.0.1:6379&gt; XADD chat:2:messages 1 msg &#34;hello world&#34; date 2020 &#34;1-0&#34; XRANGE：返回 stream 记录的列表 XRANGE 用于获取指定 ID 范围内的 entry，其中 - 和 + 为特征 ID，分别表示最小 ID 和最大 ID。
格式：XRANGE key start stop [COUNT count]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 127.0.0.1:6379&gt; XADD chat:1:messages * msg &#34;hello GO&#34; date 2021 &#34;1648184498673-0&#34; 127.0.0.1:6379&gt; XADD chat:1:messages * msg &#34;hello TypeScript&#34; date 2022 &#34;1648184539697-0&#34; 127.0.0.1:6379&gt; XRANGE chat:1:messages - + 1) 1) &#34;1648184286632-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello world&#34; 3) &#34;date&#34; 4) &#34;2020&#34; 2) 1) &#34;1648184498673-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello GO&#34; 3) &#34;date&#34; 4) &#34;2021&#34; 3) 1) &#34;1648184539697-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello TypeScript&#34; 3) &#34;date&#34; 4) &#34;2022&#34; 127.0.0.1:6379&gt; XRANGE chat:1:messages 1648184286632-0 1648184286632-1 1) 1) &#34;1648184286632-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello world&#34; 3) &#34;date&#34; 4) &#34;2020&#34; 127.0.0.1:6379&gt; XRANGE chat:1:messages 1648184286632-0 1648184498673-1 1) 1) &#34;1648184286632-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello world&#34; 3) &#34;date&#34; 4) &#34;2020&#34; 2) 1) &#34;1648184498673-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello GO&#34; 3) &#34;date&#34; 4) &#34;2021&#34; XREVRANGE XREVRANGE 与 XRANGE 用途相近，但该命令会以倒序的方式返回 entry。
格式：XREVRANGE key end start [COUNT count]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 127.0.0.1:6379&gt; XREVRANGE chat:1:messages 1648184498673-1 1648184286632-0 1) 1) &#34;1648184498673-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello GO&#34; 3) &#34;date&#34; 4) &#34;2021&#34; 2) 1) &#34;1648184286632-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello world&#34; 3) &#34;date&#34; 4) &#34;2020&#34; 127.0.0.1:6379&gt; XREVRANGE chat:1:messages 1648184498673-1 1648184286632-0 COUNT 1 1) 1) &#34;1648184498673-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello GO&#34; 3) &#34;date&#34; 4) &#34;2021&#34; XTRIM：裁剪 stream 格式：XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]
MAXLEN：用于保留最近的 entry
MINID：用于裁剪低于某一 ID 的 entry
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 127.0.0.1:6379&gt; XTRIM chat:1:messages MAXLEN 2 (integer) 1 127.0.0.1:6379&gt; XRANGE chat:1:messages - + 1) 1) &#34;1648184498673-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello GO&#34; 3) &#34;date&#34; 4) &#34;2021&#34; 2) 1) &#34;1648184539697-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello TypeScript&#34; 3) &#34;date&#34; 4) &#34;2022&#34; # 此时最早加入的 entry 已经被裁剪，stream 中保留两条 entry 127.0.0.1:6379&gt; XTRIM chat:1:messages MINID 1648184498674 (integer) 1 # ID 低于 1648184498674 的 entry 会被删除 XDEL：删除 stream 中 entry 格式：XDEL key ID [ID ...]
1 2 3 4 5 6 7 8 127.0.0.1:6379&gt; XRANGE chat:1:messages - + 1) 1) &#34;1648184539697-0&#34; 2) 1) &#34;msg&#34; 2) &#34;hello TypeScript&#34; 3) &#34;date&#34; 4) &#34;2022&#34; 127.0.0.1:6379&gt; XDEL chat:1:messages 1648184539697-0 (integer) 1 XLEN：返回 stream 中 entry 的数目 格式：XLEN key
1 2 3 4 127.0.0.1:6379&gt; XLEN chat:1:messages (integer) 0 127.0.0.1:6379&gt; DEL chat:1:messages (integer) 1 XREAD：从一个或多个 stream 中读取数据 格式：XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
XREAD 可以以阻塞或非阻塞的方式读取 stream 的数据（指定 BLOCK）。在获取 stream 记录时，需要指定记录的 ID。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 127.0.0.1:6379&gt; XRANGE api-request-log - + 1) 1) &#34;1650702336219-0&#34; 2) 1) &#34;remote_addr&#34; 2) &#34;[::1]:54058&#34; 3) &#34;url&#34; 4) &#34;/api/users&#34; 5) &#34;access_time&#34; 6) &#34;1650702336&#34; 7) &#34;time_executed&#34; 8) &#34;0&#34; 9) &#34;body_bytes_sent&#34; 10) &#34;96&#34; 2) 1) &#34;1650702505299-0&#34; 2) 1) &#34;remote_addr&#34; 2) &#34;[::1]:54112&#34; 3) &#34;url&#34; 4) &#34;/api/users&#34; 5) &#34;access_time&#34; 6) &#34;1650702505&#34; 7) &#34;time_executed&#34; 8) &#34;0&#34; 9) &#34;body_bytes_sent&#34; 10) &#34;96&#34; 127.0.0.1:6379&gt; XREAD COUNT 1 BLOCK 1000 STREAMS api-request-log 1650702336219-0 1) 1) &#34;api-request-log&#34; 2) 1) 1) &#34;1650702505299-0&#34; 2) 1) &#34;remote_addr&#34; 2) &#34;[::1]:54112&#34; 3) &#34;url&#34; 4) &#34;/api/users&#34; 5) &#34;access_time&#34; 6) &#34;1650702505&#34; 7) &#34;time_executed&#34; 8) &#34;0&#34; 9) &#34;body_bytes_sent&#34; 10) &#34;96&#34;   ]]></content></entry><entry><title>字符串相关</title><url>/post/doc-redis-commands/string-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与字符串值相关的命令。
SET：设置键值对 SET 用于设置单个值为字符串的健值对。
格式：SET key value
1 2 127.0.0.1:6379&amp;gt; SET user:1:name xiaoming OK SETNX：键不存在时才设置值 SETNX 只有在键不存在的情况下，才可以设置值。
格式：SETNX key value
1 2 3 4 5 6 7 8 9 10 11 12 13 127.0.0.1:6379&amp;gt; SET user:1:name xiaoming OK 127.0.0.1:6379&amp;gt; SETNX user:1:name xiaohong (integer) 0 # 此处设置不成功 127.0.0.1:6379&amp;gt; GET user:1:name &amp;#34;xiaoming&amp;#34; 127.0.0.1:6379&amp;gt; EXISTS user:1:email (integer) 0 # 键 user:1:email 不存在 127.0.0.1:6379&amp;gt; SETNX user:1:email foo@bar.com (integer) 1 # 设置成功 SETEX：设置具有生存时间的键值对 SETEX 可以设置一个具有生存时间的键值对，过期时间的单位为秒。
格式：SETEX key seconds value
1 2 3 4 5 6 7 8 127.0.0.1:6379&amp;gt; SETEX user:1:name 10 xiaoming OK 127.0.0.1:6379&amp;gt; GET user:1:name &amp;#34;xiaoming&amp;#34; # 10 秒内访问 127.0.0.1:6379&amp;gt; GET user:1:name (nil) # 10 秒外访问 PSETEX：设置具有过期时间的键值对 PSETEX 与 SETEX 类似，但其生存时间的单位为微秒。
格式：PSETEX key millIseconds value
1 2 3 4 5 6 7 8 127.0.0.1:6379&amp;gt; PSETEX user:1:name 10000 xiaoming OK 127.0.0.1:6379&amp;gt; GET user:1:name &amp;#34;xiaoming&amp;#34; # 10 …  ]]></content></entry><entry><title>有序集合相关</title><url>/post/doc-redis-commands/zset-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与有序集合相关的命令。
ZADD：添加元素 ZADD 用于将一个或多个带分数的元素添加到有序集合中，返回成功添加到有序集合的元素个数。
当添加元素已在有序集合中时，更新元素的分数使其在有序集合中保持正确的位置。
格式：ZADD key score member [score member ...]
1 2 3 4 127.0.0.1:6379&gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei (integer) 2 127.0.0.1:6379&gt; ZADD student:weights 64.2 xiaoming (integer) 0 ZSCORE：获取元素的分数 格式：ZSCORE key member
1 2 3 4 127.0.0.1:6379&gt; ZSCORE student:weights xiaoming &#34;64.200000000000003&#34; 127.0.0.1:6379&gt; ZSCORE student:weights xiaolei &#34;67.5&#34; ZRANGE：获取指定位置区间上的元素 ZRANGE 可以获取指定位置区间上的元素，包括区间的两端。
格式：ZRANGE key min max
1 2 3 4 5 6 7 127.0.0.1:6379&gt; ZADD student:weights 81.5 xiaopang (integer) 1 127.0.0.1:6379&gt; ZRANGE student:weights 1 2 1) &#34;xiaolei&#34; 2) &#34;xiaopang&#34; 127.0.0.1:6379&gt; ZRANGE student:weights 2 2 1) &#34;xiaopang&#34; ZRANGEBYSCORE：获取指定分数区间上的元素 ZRANGEBYSCORE 可指定分数区间获取元素。
+inf 表示正无穷，-inf 表示负无穷。
格式：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES 1) &#34;xiaolei&#34; 2) &#34;67.5&#34; 3) &#34;xiaopang&#34; 4) &#34;81.5&#34; 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 1 1 1) &#34;xiaopang&#34; 2) &#34;81.5&#34; 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 1 2 1) &#34;xiaopang&#34; 2) &#34;81.5&#34; 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights 65 85 WITHSCORES LIMIT 0 2 1) &#34;xiaolei&#34; 2) &#34;67.5&#34; 3) &#34;xiaopang&#34; 4) &#34;81.5&#34; 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) &#34;xiaoming&#34; 2) &#34;64.200000000000003&#34; 3) &#34;xiaolei&#34; 4) &#34;67.5&#34; 5) &#34;xiaopang&#34; 6) &#34;81.5&#34; ZINCRBY：增加某个元素的分数 ZINCRBY 的返回值为修改后的分数。
格式：ZINCRBY key increment member
1 2 3 4 127.0.0.1:6379&gt; ZINCRBY student:weights 0.5 xiaoming &#34;64.700000000000003&#34; 127.0.0.1:6379&gt; ZINCRBY student:weights -0.5 xiaoming &#34;64.200000000000003&#34; ZCARD：获取集合中元素的个数 格式：ZCARD key
1 2 127.0.0.1:6379&gt; ZCARD student:weights (integer) 3 ZCOUNT：获取指定分数范围内的元素个数 格式：ZCOUNT key min max
1 2 127.0.0.1:6379&gt; ZCOUNT student:weights 65 85 (integer) 2 ZREM：删除一个或多个元素 ZREM 返回删除成功的元素个数。
格式：ZREM key member [member ...]
1 2 3 4 127.0.0.1:6379&gt; ZREM student:weights xiaoming xiaolei (integer) 2 127.0.0.1:6379&gt; ZREM student:weights notaname (integer) 0 ZREMRANGEBYRANK：通过指定位置区间删除集合元素 格式：ZREMRANGEBYRANK key start stop
1 2 3 4 5 6 7 8 9 10 11 12 13 14 127.0.0.1:6379&gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei (integer) 2 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) &#34;xiaoming&#34; 2) &#34;63.200000000000003&#34; 3) &#34;xiaolei&#34; 4) &#34;67.5&#34; 5) &#34;xiaopang&#34; 6) &#34;81.5&#34; 127.0.0.1:6379&gt; ZREMRANGEBYRANK student:weights 0 1 (integer) 2 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) &#34;xiaopang&#34; 2) &#34;81.5&#34; ZREMRANGEBYSCORE：通过指定分数区间删除集合元素 格式：ZREMRANGEBYSCORE key min max
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 127.0.0.1:6379&gt; ZADD student:weights 63.2 xiaoming 67.5 xiaolei 81.5 xiaopang (integer) 3 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) &#34;xiaoming&#34; 2) &#34;63.200000000000003&#34; 3) &#34;xiaolei&#34; 4) &#34;67.5&#34; 5) &#34;xiaopang&#34; 6) &#34;81.5&#34; 127.0.0.1:6379&gt; ZREMRANGEBYSCORE student:weights 80 85 (integer) 1 127.0.0.1:6379&gt; ZRANGEBYSCORE student:weights -inf +inf WITHSCORES 1) &#34;xiaoming&#34; 2) &#34;63.200000000000003&#34; 3) &#34;xiaolei&#34; 4) &#34;67.5&#34; ZRANK：获取元素的排序 格式：ZRANK key member
1 2 3 4 127.0.0.1:6379&gt; ZRANK student:weights xiaolei (integer) 1 127.0.0.1:6379&gt; ZRANK student:weights notaname (nil) ZREVRANK：降序获取元素的排序 格式：ZREVRANK key member
1 2 127.0.0.1:6379&gt; ZREVRANK student:weights xiaolei (integer) 0   ]]></content></entry><entry><title>列表值相关</title><url>/post/doc-redis-commands/list-related/</url><categories><category>后端技术</category><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html"><![CDATA[  Redis 服务器中与列表值相关的命令。
LPUSH：向列表左端添加元素 LPUSH 返回添加元素后列表的长度。
格式：LPUSH key element [element ...]
1 2 3 127.0.0.1:6379&amp;gt; LPUSH colors green yellow red blue gray (integer) 5 # 此时列表为 [gray blue yellow red green] LPUSHX：向列表左端添加元素 LPUSHX 与 LPUSH 类似，但只有在 key 存在的情况，操作才有效。
格式：LPUSHX key element [element ...]
1 2 3 4 127.0.0.1:6379&amp;gt; KEYS colors (empty array) 127.0.0.1:6379&amp;gt; LPUSHX colors red green blue (integer) 0 RPUSH：向列表右端添加元素 RPUSH 返回添加元素后列表的长度。
格式：RPUSH key element [element ...]
1 2 3 4 127.0.0.1:6379&amp;gt; RPUSH colors lightgreen lightyellow lightred lightblue (integer) 9 # 此时列表为 [gray blue yellow red green # lightgreen lightyellow lightred lightblue] RPUSHX：向列表右端添加元素 RPUSHX 与 RPUSH 类似，但只能存在的键有效。
格式：RPUSHX key element [element ...]
1 2 3 4 5 6 127.0.0.1:6379&amp;gt; KEYS colors (empty array) 127.0.0.1:6379&amp;gt; RPUSHX colors red green blue (integer) 0 127.0.0.1:6379&amp;gt; KEYS colors (empty array) LPOP：从列表左端弹出元素 LPOP 返回弹出的元素。
格式：LPOP key [count]
1 2 3 4 5 127.0.0.1:6379&amp;gt; LPOP colors 2 1) …  ]]></content></entry></search>